<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="LegalMind - AI-powered legal document assistant">
  <title>LegalMind Dashboard</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Add PDF.js library for PDF processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <!-- Add Tesseract.js for OCR (image text recognition) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.3/dist/tesseract.min.js"></script>

  <!-- OCR Styles -->
  <style>
    .file-preview-container.ocr-preview {
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
      background-color: var(--light-bg);
      border-radius: 5px;
      margin-top: 10px;
    }

    .file-preview-container.ocr-preview textarea {
      width: 100%;
      height: 150px;
      resize: none;
      font-family: monospace;
      font-size: 12px;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--main-bg);
      color: var(--text-color);
    }

    .dark-mode .file-preview-container.ocr-preview {
      background-color: var(--sidebar-bg);
    }

    .dark-mode .file-preview-container.ocr-preview textarea {
      background-color: var(--main-bg);
      border-color: var(--dark-border-color);
    }

    /* Scrollbar for OCR Preview */
    .file-preview-container.ocr-preview::-webkit-scrollbar {
      width: 8px;
    }

    .file-preview-container.ocr-preview::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
    }

    .file-preview-container.ocr-preview::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 4px;
    }

    .file-preview-container.ocr-preview::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-hover);
    }

    /* Updated animated thinking indicator styles */
    .thinking-container {
      display: flex;
      align-items: center;
      gap: 5px;
      color: var(--text-color);
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .thinking-dots {
      display: inline-flex;
      align-items: center;
      height: 20px;
    }

    .thinking-dot {
      width: 4px;
      height: 4px;
      margin: 0 2px;
      background-color: currentColor;
      border-radius: 50%;
      display: inline-block;
      animation: thinkingDot 1.4s infinite ease-in-out both;
    }

    .thinking-dot:nth-child(1) {
      animation-delay: -0.32s;
    }

    .thinking-dot:nth-child(2) {
      animation-delay: -0.16s;
    }

    @keyframes thinkingDot {

      0%,
      80%,
      100% {
        transform: scale(0);
      }

      40% {
        transform: scale(1);
      }
    }

    /* Additional thinking animation details */
    .thinking-brain {
      display: inline-block;
      animation: pulse 1.5s infinite ease-in-out;
      margin-right: 5px;
      color: var(--primary-color);
    }

    @keyframes pulse {
      0% {
        opacity: 0.3;
        transform: scale(0.8);
      }

      50% {
        opacity: 1;
        transform: scale(1.1);
      }

      100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
    }

    /* Hidden text that appears during thinking */
    .thinking-context {
      font-size: 0.85rem;
      color: var(--text-color);
      opacity: 0.7;
      margin-top: 5px;
      font-style: italic;
      display: block;
      animation: fadeInOut 8s infinite ease-in-out;
    }

    @keyframes fadeInOut {

      0%,
      100% {
        opacity: 0.3;
      }

      50% {
        opacity: 0.7;
      }
    }

    /* Animated thinking indicator styles */
    @keyframes ellipsis {
      0% {
        content: '.';
      }

      33% {
        content: '..';
      }

      66% {
        content: '...';
      }

      100% {
        content: '';
      }
    }

    .message.bot:last-child:has(span[data-thinking="true"]) {
      position: relative;
    }

    .message.bot:last-child:has(span[data-thinking="true"])::after {
      content: '';
      position: absolute;
      display: inline-block;
      animation: ellipsis 1.5s infinite steps(4);
      width: 1.5em;
      overflow: hidden;
      vertical-align: bottom;
      margin-left: 0.2em;
    }
  </style>
  <style>
    /* CSS Variables for theming */
    :root {
      --primary-color: #007bff;
      --primary-hover: #0056b3;
      --success-color: #28a745;
      --success-hover: #218838;
      --danger-color: #dc3545;
      --light-bg: #f8f9fa;
      --dark-bg: #121212;
      --light-surface: #ffffff;
      --dark-surface: #1e1e1e;
      --light-text: #212529;
      --dark-text: #f8f9fa;
      --light-border: #dee2e6;
      --dark-border: #444;
      --box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      --dark-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      --transition: all 0.3s ease;
      --border-radius-sm: 8px;
      --border-radius-md: 12px;
      --border-radius-lg: 16px;
      --border-radius-xl: 24px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
    }

    /* Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: var(--light-bg);
      color: var(--light-text);
      transition: var(--transition);
      overflow-x: hidden;
    }

    body.dark-mode {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }

    .dashboard {
      display: flex;
      width: 100%;
      height: 100vh;
      border-radius: var(--border-radius-lg);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      transition: var(--transition);
    }

    body.dark-mode .dashboard {
      box-shadow: var(--dark-box-shadow);
    }

    /* Left Sidebar with improved padding */
    .sidebar {
      position: relative;
      display: flex;
      flex-direction: column;
      width: 300px;
      height: 100%;
      background-color: var(--bg-color-surface);
      overflow-y: auto;
      transition: all 0.3s ease;
      padding: 15px 12px 0;
    }

    body.dark-mode .sidebar {
      background: var(--dark-surface);
      border-right: 1px solid var(--dark-border);
    }

    .chat-header {
      margin-bottom: var(--spacing-lg);
      padding-left: 5px;
      display: flex;
      align-items: center;
    }

    .chat-header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin: 0;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .new-chat {
      width: 100%;
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
      cursor: pointer;
      border: none;
      border-radius: var(--border-radius-md);
      background: var(--primary-color);
      color: white;
      transition: var(--transition);
      font-size: 0.95rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }

    .new-chat:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
    }

    .new-chat i {
      margin-right: var(--spacing-xs);
    }

    .chat-list {
      padding: 0;
      overflow-y: auto;
      margin-bottom: var(--spacing-lg);
      flex-grow: 1;
    }

    .chat-list li {
      list-style: none;
      padding: var(--spacing-md);
      margin: var(--spacing-xs) 0;
      background-color: var(--light-bg);
      border-radius: var(--border-radius-md);
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition);
      cursor: pointer;
      font-weight: 500;
    }

    .chat-list li:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }

    .chat-list li.active {
      background-color: rgba(0, 123, 255, 0.2);
      border-left: 3px solid var(--primary-color);
    }

    body.dark-mode .chat-list li {
      background: rgba(255, 255, 255, 0.05);
    }

    body.dark-mode .chat-list li:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .chat-list li.active {
      background: rgba(0, 123, 255, 0.3);
    }

    .chat-list li .delete-chat {
      cursor: pointer;
      background: none;
      border: none;
      font-size: 0.9rem;
      color: var(--danger-color);
      opacity: 0.7;
      transition: var(--transition);
    }

    .chat-list li .delete-chat:hover {
      opacity: 1;
    }

    /* Document Preview section with fixed styling */
    .documents-preview {
      position: relative;
      display: flex;
      flex-direction: column;
      margin: 15px 10px;
      background: var(--light-surface);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--light-border);
      padding: var(--spacing-md);
      box-shadow: var(--box-shadow);
      z-index: 5;
      max-height: none;
    }

    body.dark-mode .documents-preview {
      background: var(--dark-surface);
      border-color: var(--dark-border);
      box-shadow: var(--dark-box-shadow);
    }

    .documents-preview h3 {
      margin-bottom: var(--spacing-md);
      font-size: 1rem;
      font-weight: 600;
      color: var(--light-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    body.dark-mode .documents-preview h3 {
      color: var(--dark-text);
    }

    #documentPreviews {
      flex: 1;
      min-height: 50px;
      max-height: 250px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 5px;
    }

    .file-item {
      display: flex;
      flex-direction: column;
      background: var(--light-surface);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--light-border);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      transition: var(--transition);
      overflow: hidden;
      margin-bottom: var(--spacing-md);
    }

    .file-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
    }

    .file-name-container {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .file-name-container i {
      color: #555;
    }

    body.dark-mode .file-name-container i {
      color: #ddd;
    }

    .file-name-container span {
      font-weight: 500;
      font-size: 0.9rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-preview-container {
      padding: 10px;
      max-height: 200px;
      overflow: hidden;
    }

    .file-preview-container img {
      max-width: 100%;
      max-height: 180px;
      object-fit: contain;
      display: block;
      margin: 0 auto;
    }

    .delete-file {
      cursor: pointer;
      background: none;
      border: none;
      font-size: 0.85rem;
      color: var(--danger-color);
      opacity: 0.7;
      transition: var(--transition);
    }

    .delete-file:hover {
      opacity: 1;
    }

    /* PDF specific styling to match screenshot */
    .pdf-icon {
      color: #e74c3c;
    }

    .pdf-preview {
      height: 200px;
      overflow: hidden;
    }

    body.dark-mode .pdf-preview {
      background: #2a2a2a;
    }

    /* Chat Section */
    .chat-section {
      flex: 1;
      padding: var(--spacing-lg);
      display: flex;
      flex-direction: column;
      background-color: var(--light-surface);
      transition: var(--transition);
      position: relative;
      height: 100vh;
      overflow: hidden;
    }

    body.dark-mode .chat-section {
      background-color: var(--dark-surface);
    }

    /* Navigation Bar */
    .chat-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--light-bg);
      padding: var(--spacing-md) var(--spacing-lg);
      box-shadow: var(--box-shadow);
      margin-bottom: var(--spacing-md);
      border-radius: var(--border-radius-md);
      transition: var(--transition);
      position: relative;
      z-index: 10;
    }

    body.dark-mode .chat-nav {
      background-color: rgba(255, 255, 255, 0.05);
      box-shadow: var(--dark-box-shadow);
    }

    /* Nav Left: Menu Toggle + LegalMind.Space */
    .nav-left {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }

    .menu-toggle {
      display: none;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .menu-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    body.dark-mode .menu-toggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .menu-toggle {
      color: var(--dark-text);
    }

    .nav-brand {
      font-weight: 700;
      font-size: 1.2rem;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Nav Right: Dropdowns, Contact Us, and Profile */
    .nav-right {
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .nav-links {
      display: flex;
      gap: var(--spacing-xl);
      font-weight: 500;
      align-items: center;
    }

    .nav-links a {
      text-decoration: none;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition);
    }

    .nav-links a:hover {
      color: var(--primary-color);
    }

    body.dark-mode .nav-links a {
      color: var(--dark-text);
    }

    /* Dropdown styling */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background-color: var(--light-surface);
      min-width: 180px;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius-md);
      z-index: 1;
      overflow: hidden;
      transition: var(--transition);
    }

    body.dark-mode .dropdown-content {
      background-color: var(--dark-surface);
      box-shadow: var(--dark-box-shadow);
    }

    .dropdown-content a {
      color: var(--light-text);
      padding: var(--spacing-md);
      text-decoration: none;
      display: block;
      transition: var(--transition);
    }

    body.dark-mode .dropdown-content a {
      color: var(--dark-text);
    }

    .dropdown-content a:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }

    body.dark-mode .dropdown-content a:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    /* Nav Profile */
    .nav-profile {
      position: relative;
    }

    .nav-profile img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--light-border);
      object-fit: cover;
      transition: var(--transition);
    }

    body.dark-mode .nav-profile img {
      border-color: var(--dark-border);
    }

    .nav-profile img:hover {
      transform: scale(1.05);
      border-color: var(--primary-color);
    }

    /* Profile Menu - Upgraded UI */
    .profile-menu {
      display: none;
      flex-direction: column;
      position: absolute;
      right: 0;
      top: 50px;
      background: var(--light-surface);
      padding: var(--spacing-lg);
      border-radius: var(--border-radius-md);
      box-shadow: var(--box-shadow);
      width: 280px;
      transition: var(--transition);
      z-index: 99;
    }

    body.dark-mode .profile-menu {
      background: var(--dark-surface);
      box-shadow: var(--dark-box-shadow);
    }

    .profile-menu.active {
      display: flex;
    }

    .profile-menu-header {
      display: flex;
      flex-direction: column;
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
    }

    body.dark-mode .profile-menu-header {
      border-color: var(--dark-border);
    }

    .profile-menu-header .user-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 4px;
    }

    .profile-menu-header .user-plan {
      color: #6c757d;
      font-size: 0.9rem;
    }

    body.dark-mode .profile-menu-header .user-plan {
      color: #adb5bd;
    }

    .profile-menu-actions {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .profile-menu-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-md);
      border-radius: var(--border-radius-md);
      border: none;
      background: var(--light-bg);
      color: var(--light-text);
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
    }

    body.dark-mode .profile-menu-btn {
      background: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
    }

    .profile-menu-btn:hover {
      background: rgba(0, 123, 255, 0.1);
      transform: translateY(-2px);
    }

    .profile-menu-btn.logout {
      background-color: rgba(220, 53, 69, 0.1);
      color: var(--danger-color);
    }

    .profile-menu-btn.logout:hover {
      background-color: var(--danger-color);
      color: white;
    }

    /* Settings Panel */
    .settings-panel {
      display: none;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .settings-panel.active {
      display: flex;
    }

    .settings-section {
      background: var(--light-bg);
      border-radius: var(--border-radius-md);
      padding: var(--spacing-md);
      border: 1px solid var(--light-border);
    }

    body.dark-mode .settings-section {
      background: rgba(255, 255, 255, 0.05);
      border-color: var(--dark-border);
    }

    .settings-section-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-sm);
      font-weight: 500;
    }

    .back-to-menu {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-md);
      color: var(--primary-color);
      background: none;
      border: none;
      padding: 0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .back-to-menu:hover {
      text-decoration: underline;
    }

    /* Dark mode toggle enhanced */
    .switch {
      display: flex;
      align-items: center;
      margin-top: var(--spacing-xs);
      cursor: pointer;
    }

    .switch input {
      appearance: none;
      width: 44px;
      height: 22px;
      background: #ccc;
      border-radius: 11px;
      position: relative;
      transition: var(--transition);
      cursor: pointer;
      margin-right: var(--spacing-md);
    }

    .switch input:checked {
      background: var(--primary-color);
    }

    .switch input::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      transition: var(--transition);
    }

    .switch input:checked::before {
      transform: translateX(22px);
    }

    /* File upload */
    .profile-menu input[type="file"] {
      margin-top: var(--spacing-md);
      display: block;
      width: 100%;
      border-radius: var(--border-radius-md);
      padding: var(--spacing-sm);
      border: 1px solid var(--light-border);
      font-size: 0.9rem;
    }

    body.dark-mode .profile-menu input[type="file"] {
      border-color: var(--dark-border);
      color: var(--dark-text);
      background: rgba(255, 255, 255, 0.05);
    }

    .profile-menu #uploadedFileName {
      font-size: 0.8rem;
      color: #6c757d;
      margin-top: var(--spacing-xs);
    }

    body.dark-mode .profile-menu #uploadedFileName {
      color: #adb5bd;
    }

    /* Chat Box with padding adjustments for welcome message */
    .chat-box {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border: 1px solid var(--light-border);
      /* Update padding to accommodate the sticky welcome message */
      padding: 0 var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
      background-color: var(--light-bg);
      border-radius: var(--border-radius-lg);
      transition: var(--transition);
      margin-bottom: var(--spacing-md);
      position: relative;
      scroll-behavior: smooth;
    }

    /* Add margin to first message to create space after welcome message */
    .chat-box>.message:first-of-type {
      margin-top: var(--spacing-lg);
    }

    body.dark-mode .chat-box {
      background: rgba(255, 255, 255, 0.02);
      border-color: var(--dark-border);
    }

    /* Add padding after welcome message for better spacing */
    .chat-box>.message:first-of-type {
      margin-top: var(--spacing-lg);
    }

    /* Chat Input */
    .chat-input {
      display: flex;
      margin-top: var(--spacing-md);
      gap: var(--spacing-md);
      position: relative;
    }

    .input-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
    }

    .chat-input input {
      flex: 1;
      width: 100%;
      padding: var(--spacing-md) var(--spacing-lg);
      padding-left: 16px;
      padding-right: 135px;
      border: 1px solid var(--light-border);
      border-radius: 30px;
      font-size: 1rem;
      background-color: var(--light-surface);
      color: var(--light-text);
      transition: var(--transition);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    body.dark-mode .chat-input input {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
      border-color: var(--dark-border);
    }

    .chat-input input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }

    .attach-btn {
      position: absolute;
      right: 55px;
      top: 50%;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .attach-btn:hover {
      color: var(--primary-color);
    }

    body.dark-mode .attach-btn {
      color: #adb5bd;
    }

    .image-btn {
      position: absolute;
      right: 95px;
      top: 50%;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .image-btn:hover {
      color: var(--primary-color);
    }

    body.dark-mode .image-btn {
      color: #adb5bd;
    }

    #sendBtn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      transition: all 0.2s ease;
    }

    #sendBtn:hover {
      transform: translateY(-50%) scale(1.1);
    }

    /* Chat Messages */
    .message {
      margin-bottom: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: 20px;
      max-width: 70%;
      word-wrap: break-word;
      line-height: 1.5;
      animation: fadeIn 0.3s ease-out;
      position: relative;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .user {
      background-color: var(--primary-color);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }

    .bot {
      background-color: var(--light-surface);
      color: var(--light-text);
      align-self: flex-start;
      border-bottom-left-radius: 5px;
      border: 1px solid var(--light-border);
    }

    body.dark-mode .bot {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
      border-color: var(--dark-border);
    }

    /* Welcome Message with fixed positioning */
    .welcome-message {
      text-align: center;
      padding: 20px;
      background-color: var(--light-bg);
      border-bottom: 1px solid var(--light-border);
      margin-bottom: 0;
      position: relative;
      width: 100%;
      border-top-left-radius: var(--border-radius-lg);
      border-top-right-radius: var(--border-radius-lg);
      transition: var(--transition);
    }

    body.dark-mode .welcome-message {
      background-color: var(--dark-bg);
      border-color: var(--dark-border);
    }

    .welcome-message.hidden {
      display: none;
    }

    .welcome-message h2 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 600;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: var(--spacing-xs);
    }

    .welcome-message p {
      margin-top: var(--spacing-xs);
      font-size: 1.1rem;
      color: #6c757d;
    }

    body.dark-mode .welcome-message p {
      color: #ddd;
    }

    .welcome-message .model-info {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      background: #f2f5f9;
      display: inline-block;
      padding: 4px 10px;
      border-radius: 15px;
    }

    .welcome-message .model-info .fas {
      color: #4CAF50;
      margin-right: 5px;
    }

    .welcome-message .model-info .model-id {
      color: #888;
      font-size: 12px;
    }

    body.dark-mode .welcome-message .model-info {
      background: #2d3748;
      color: #cbd5e0;
    }

    body.dark-mode .welcome-message .model-info .model-id {
      color: #a0aec0;
    }

    /* Responsive adjustments for sidebar */
    @media (max-width: 992px) {
      .dashboard {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
      }

      .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 990;
        background-color: var(--light-surface);
        display: none;
        flex-direction: column;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        padding: 15px;
      }

      body.dark-mode .sidebar {
        background-color: var(--dark-surface);
      }

      .sidebar .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .sidebar .chat-header:after {
        content: "\f00d";
        font-family: "Font Awesome 5 Free";
        font-weight: 900;
        font-size: 1.2rem;
        cursor: pointer;
        color: var(--light-text);
      }

      body.dark-mode .sidebar .chat-header:after {
        color: var(--dark-text);
      }

      .documents-preview {
        margin-top: 15px;
        flex: 1;
        max-height: none;
      }

      #documentPreviews {
        max-height: none;
        flex: 1;
        overflow-y: auto;
      }

      .chat-section {
        padding: var(--spacing-md);
        height: 100vh !important;
      }

      .nav-links {
        display: none;
      }

      .nav-right {
        gap: var(--spacing-md);
      }

      .menu-toggle {
        display: block;
        position: relative;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--light-text);
        cursor: pointer;
        transition: var(--transition);
      }

      body.dark-mode .menu-toggle {
        color: var(--dark-text);
      }

      .chat-box {
        max-height: calc(100vh - 140px) !important;
      }

      /* Fixed document preview visibility */
      .sidebar.collapsed .documents-preview {
        display: none !important;
      }

      .sidebar:not(.collapsed) .documents-preview {
        display: flex !important;
        max-height: none;
        overflow: visible;
        margin-bottom: var(--spacing-md);
      }

      /* Ensure toggle button is always visible */
      .documents-toggle {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        height: 35px;
        border-radius: 0;
        position: relative;
        bottom: 0;
        margin-top: 0;
        z-index: 100;
      }

      .documents-preview {
        position: relative;
        max-height: none;
        border: 1px solid var(--light-border);
        margin: 20px 15px;
        border-radius: var(--border-radius-md);
        overflow: hidden;
      }

      #documentPreviews {
        max-height: 200px;
        padding: 8px;
      }
    }

    @media (max-width: 768px) {
      .sidebar {
        padding: 10px 8px 0;
      }

      .message {
        max-width: 85%;
      }

      .profile-menu {
        width: 260px;
        right: -10px;
        padding: var(--spacing-md);
      }

      .documents-preview {
        margin: 15px 10px;
        padding: 12px;
      }

      #documentPreviews {
        max-height: 150px;
        padding: 5px;
      }

      .documents-toggle {
        height: 30px;
      }

      .profile-pic-section {
        padding: var(--spacing-sm);
      }

      .profile-preview {
        width: 60px;
        height: 60px;
      }

      .chat-input {
        display: grid;
        grid-template-columns: 40px 1fr;
        grid-template-rows: auto auto;
        gap: var(--spacing-sm);
      }

      .attach-btn {
        position: relative;
        grid-row: 2;
        grid-column: 1;
        transform: none;
        top: auto;
        left: auto;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--light-bg);
        border-radius: var(--border-radius-md);
        border: 1px solid var(--light-border);
      }

      body.dark-mode .attach-btn {
        background: rgba(255, 255, 255, 0.05);
        border-color: var(--dark-border);
      }

      .chat-input input {
        grid-row: 2;
        grid-column: 2;
        padding-left: var(--spacing-md);
      }

      #sendBtn {
        grid-row: 3;
        grid-column: 1 / span 2;
        width: 100%;
        margin-top: var(--spacing-xs);
      }

      .chat-nav {
        flex-wrap: wrap;
      }

      .nav-profile img {
        width: 35px;
        height: 35px;
      }
    }

    @media (max-width: 576px) {
      .sidebar {
        padding: 8px 5px 0;
      }

      .chat-nav {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .nav-left {
        font-size: 1rem;
      }

      .chat-section {
        padding: var(--spacing-md);
      }

      .welcome-message h2 {
        font-size: 1.5rem;
      }

      .welcome-message p {
        font-size: 1rem;
      }

      .chat-box {
        padding: var(--spacing-md);
      }

      .message {
        max-width: 90%;
        padding: var(--spacing-sm) var(--spacing-md);
      }

      #currentChat {
        font-size: 0.8rem;
      }

      .chat-header h1 {
        font-size: 1.3rem;
      }
    }

    @media (max-width: 480px) {
      .sidebar {
        padding: 8px 5px 0;
      }

      .documents-preview {
        margin: 10px 5px;
        padding: 10px;
      }

      .message {
        max-width: 95%;
      }

      .chat-nav {
        padding: var(--spacing-xs) var(--spacing-sm);
      }

      .nav-left {
        font-size: 0.9rem;
      }

      .nav-profile img {
        width: 30px;
        height: 30px;
      }

      .profile-menu {
        width: 240px;
        right: -15px;
        padding: var(--spacing-md);
      }
    }

    /* Enhanced mobile menu styling */
    .mobile-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 85%;
      max-width: 320px;
      height: 100vh;
      background-color: var(--light-surface);
      z-index: 999;
      transform: translateX(-100%);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: var(--dark-box-shadow);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border-right: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .mobile-menu {
      background-color: var(--dark-surface);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    .mobile-menu.active {
      transform: translateX(0);
    }

    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 998;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(2px);
    }

    .mobile-menu-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    /* Refined mobile menu header */
    .mobile-menu-header {
      padding: var(--spacing-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
      position: sticky;
      top: 0;
      background-color: var(--light-surface);
      z-index: 2;
    }

    body.dark-mode .mobile-menu-header {
      border-color: var(--dark-border);
      background-color: var(--dark-surface);
    }

    .mobile-menu-header h1 {
      font-size: 1.5rem;
      margin: 0;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .mobile-menu-content {
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      overflow-y: auto;
    }

    /* Enhanced mobile menu buttons */
    .mobile-menu-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: 12px var(--spacing-lg);
      border-radius: 10px;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .mobile-menu-btn::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background-color: rgba(0, 123, 255, 0.1);
      transition: width 0.2s ease;
      z-index: -1;
      border-radius: 10px;
    }

    .mobile-menu-btn:active {
      transform: scale(0.98);
    }

    .mobile-menu-btn:hover::after {
      width: 100%;
    }

    body.dark-mode .mobile-menu-btn {
      color: var(--dark-text);
    }

    body.dark-mode .mobile-menu-btn::after {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .mobile-menu-btn.new-chat-btn {
      background: var(--primary-color);
      color: white;
      font-weight: 500;
      margin-bottom: var(--spacing-md);
      box-shadow: 0 4px 6px rgba(0, 123, 255, 0.2);
    }

    .mobile-menu-btn.new-chat-btn:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 123, 255, 0.3);
    }

    .mobile-menu-btn.new-chat-btn:active {
      transform: translateY(0);
    }

    /* Improved section headers */
    .mobile-section-header {
      font-size: 0.85rem;
      font-weight: 600;
      color: #6c757d;
      padding: 14px var(--spacing-lg) 8px;
      margin-top: var(--spacing-md);
      position: sticky;
      top: 71px;
      background-color: var(--light-surface);
      z-index: 1;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    body.dark-mode .mobile-section-header {
      color: #adb5bd;
      background-color: var(--dark-surface);
    }

    /* Enhanced chat items */
    .mobile-chat-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--spacing-sm);
      padding: 10px var(--spacing-md);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .mobile-chat-item .chat-info {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      flex: 1;
      overflow: hidden;
    }

    .mobile-chat-item .delete-chat {
      background: none;
      border: none;
      color: var(--danger-color);
      opacity: 0.7;
      font-size: 0.85rem;
      padding: 5px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .mobile-chat-item .delete-chat:hover {
      opacity: 1;
    }

    .mobile-chat-item i {
      color: #6c757d;
      font-size: 0.9rem;
      width: 20px;
      text-align: center;
    }

    body.dark-mode .mobile-chat-item i {
      color: #adb5bd;
    }

    .mobile-chat-item span {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mobile-chat-item::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background-color: rgba(0, 123, 255, 0.1);
      transition: width 0.2s ease;
      z-index: -1;
      border-radius: 10px;
    }

    .mobile-chat-item:hover::after {
      width: 100%;
    }

    .mobile-chat-item.active {
      background-color: rgba(0, 123, 255, 0.15);
      font-weight: 500;
    }

    .mobile-chat-item.active i {
      color: var(--primary-color);
    }

    body.dark-mode .mobile-chat-item.active {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Better menu button animation */
    .menu-toggle {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .menu-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .menu-toggle:active {
      transform: scale(0.95);
    }

    /* Model dropdown styling */
    .model-dropdown {
      display: flex;
      align-items: center;
      cursor: pointer;
      position: relative;
    }

    /* Mobile responsiveness */
    @media (max-width: 992px) {
      .menu-toggle {
        display: block;
      }

      .nav-left {
        gap: var(--spacing-sm);
      }

      .dashboard {
        height: 100vh;
        overflow: hidden;
      }

      .sidebar {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .chat-section {
        padding: var(--spacing-md) var(--spacing-md);
      }

      .chat-nav {
        padding: var(--spacing-sm) var(--spacing-md);
        margin-bottom: var(--spacing-sm);
      }

      .chat-box {
        padding: var(--spacing-md);
      }
    }

    @media (max-width: 576px) {
      .chat-section {
        padding: var(--spacing-sm);
      }

      .chat-nav {
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }
    }

    @media (max-width: 480px) {
      .nav-brand {
        font-size: 1rem;
      }

      .model-dropdown i {
        font-size: 0.7rem !important;
      }
    }

    @media (max-width: 992px) {

      /* Remove document preview button from mobile menu */
      .mobile-menu-btn[onclick*="toggleDocumentPreview"] {
        display: none;
      }

      /* Use full screen height for chat section on mobile */
      .chat-section {
        height: 100vh !important;
        max-height: none !important;
        padding-bottom: 10px;
      }

      /* Fix chat box height to utilize full screen */
      .chat-box {
        max-height: calc(100vh - 120px) !important;
        margin-bottom: 10px;
      }

      /* Hide document preview section entirely on mobile */
      .documents-preview,
      .sidebar .documents-preview,
      .sidebar:not(.collapsed) .documents-preview {
        display: none !important;
      }

      /* Hide document-related toggle buttons */
      .documents-toggle {
        display: none !important;
      }
    }

    /* File upload message styling in chat */
    .file-upload {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      margin: 5px 0;
    }

    body.dark-mode .file-upload {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .file-upload i {
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    .file-upload span {
      font-size: 0.95rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 200px;
    }

    @media (max-width: 768px) {
      .chat-input {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
        position: relative;
      }

      .input-container {
        flex: 1;
        position: relative;
      }

      .attach-btn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        height: auto;
        width: auto;
        background: transparent;
        border: none;
        z-index: 2;
      }

      .image-btn {
        position: absolute;
        left: 40px;
        top: 50%;
        transform: translateY(-50%);
        height: auto;
        width: auto;
        background: transparent;
        border: none;
        z-index: 2;
      }

      #messageInput {
        padding-left: 70px !important;
      }

      #sendBtn {
        right: 8px;
        font-size: 1.2rem;
      }
    }

    /* Scroll to bottom button */
    .scroll-bottom-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.3s ease;
      z-index: 10;
      border: none;
    }

    .scroll-bottom-btn.visible {
      opacity: 1;
      transform: scale(1);
    }

    .scroll-bottom-btn:hover {
      background-color: var(--primary-hover);
      transform: scale(1.05);
    }

    .scroll-bottom-btn:active {
      transform: scale(0.95);
    }

    /* Mobile-specific adjustments for chat input */
    @media (max-width: 768px) {
      .chat-input {
        display: flex;
        flex-direction: row;
        position: relative;
        margin-top: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }

      .input-container {
        flex: 1;
        display: flex;
        align-items: center;
        position: relative;
      }

      .chat-input input {
        width: 100%;
        padding: 12px 40px;
        border-radius: 24px;
        font-size: 1rem;
      }

      .attach-btn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: #6c757d;
        z-index: 2;
      }

      .image-btn {
        position: absolute;
        left: 40px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: #6c757d;
        z-index: 2;
      }

      #sendBtn {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: var(--primary-color);
        font-size: 1.2rem;
        z-index: 2;
      }

      /* Ensure chat box fills available space */
      .chat-box {
        max-height: calc(100vh - 170px);
      }
    }

    /* Further mobile refinements */
    @media (max-width: 576px) {
      .chat-input {
        margin-top: 6px;
        margin-bottom: 6px;
      }

      .chat-input input {
        padding: 10px 38px;
        font-size: 0.95rem;
      }

      #sendBtn,
      .attach-btn {
        font-size: 1.1rem;
      }

      #sendBtn {
        width: 32px;
        height: 32px;
        padding: 0;
        right: 8px;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }

      #sendBtn i {
        font-size: 0.85rem;
      }
    }

    /* Small mobile screens */
    @media (max-width: 480px) {
      .chat-input {
        margin-top: 4px;
        margin-bottom: 4px;
      }

      .chat-input input {
        padding: 9px 36px;
        font-size: 0.9rem;
      }

      #sendBtn,
      .attach-btn {
        font-size: 1rem;
      }

      #sendBtn {
        width: 28px;
        height: 28px;
        padding: 0;
        right: 8px;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }

      #sendBtn i {
        font-size: 0.85rem;
      }
    }

    /* Mobile-specific adjustments for chat input */
    @media (max-width: 992px) {
      .chat-section {
        position: relative;
        display: flex;
        flex-direction: column;
        height: fit-content !important;
        min-height: 100vh;
        padding-bottom: 80px !important;
        /* Space for input */
      }

      .chat-box {
        flex: 1;
        height: calc(100vh - 180px) !important;
        margin-bottom: 5px;
      }

      .chat-input {
        position: fixed;
        bottom: 10px;
        left: 0;
        right: 0;
        padding: 0 15px;
        margin: 0;
        z-index: 20;
        background: var(--light-surface);
      }

      body.dark-mode .chat-input {
        background: var(--dark-surface);
      }

      .input-container {
        width: 100%;
        border-radius: 30px;
        background-color: var(--light-surface);
        box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
        padding: 2px;
        display: flex;
        align-items: center;
        border: 1px solid var(--light-border);
        transition: all 0.3s ease;
        position: relative;
      }

      body.dark-mode .input-container {
        background-color: var(--dark-surface);
        border-color: var(--dark-border);
        box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
      }

      .attach-btn {
        position: absolute;
        right: 55px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 0;
      }

      .image-btn {
        position: absolute;
        right: 95px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 0;
      }

      .chat-input input {
        height: 50px;
        font-size: 16px;
        padding: 12px 50px 12px 15px;
        padding-right: 135px;
        border: none;
        background: transparent;
        width: 100%;
      }

      #sendBtn {
        width: 36px;
        height: 36px;
        padding: 0;
        right: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }

      #sendBtn i {
        font-size: 0.9rem;
      }

      body.dark-mode #sendBtn {
        background-color: var(--primary-color);
      }
    }

    /* Additional mobile refinements */
    @media (max-width: 576px) {
      .chat-section {
        height: fit-content !important;
        min-height: 100vh;
      }

      .chat-box {
        height: calc(100vh - 160px) !important;
      }

      .attach-btn {
        width: 35px;
        height: 35px;
        right: 52px;
      }

      .image-btn {
        width: 35px;
        height: 35px;
        right: 90px;
      }
    }

    /* Small mobile screens */
    @media (max-width: 480px) {
      .chat-section {
        padding: var(--spacing-sm);
      }

      .chat-box {
        height: calc(100vh - 150px) !important;
      }

      .attach-btn {
        width: 32px;
        height: 32px;
        right: 50px;
      }

      .image-btn {
        width: 32px;
        height: 32px;
        right: 85px;
      }
    }

    /* Interactive effects for mobile inputs */
    @media (max-width: 992px) {

      /* Input animation when focused */
      .input-container:focus-within {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border-color: var(--primary-color);
      }

      /* Message animations */
      .message {
        transition: transform 0.2s ease, opacity 0.2s ease;
      }

      .message.user {
        animation: messageSlideInRight 0.3s ease forwards;
      }

      .message.bot {
        animation: messageSlideInLeft 0.3s ease forwards;
      }

      @keyframes messageSlideInRight {
        from {
          opacity: 0;
          transform: translateX(30px);
        }

        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @keyframes messageSlideInLeft {
        from {
          opacity: 0;
          transform: translateX(-30px);
        }

        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Send button ripple effect */
      #sendBtn::after {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.4);
        transform: scale(0);
        transition: transform 0.3s ease-out;
      }

      #sendBtn:active::after {
        transform: scale(2);
        opacity: 0;
        transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      }

      /* Attach button ripple effect */
      .attach-btn::after {
        content: '';
        position: absolute;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1);
        transform: scale(0);
        left: 50%;
        top: 50%;
        margin-left: -15px;
        margin-top: -15px;
      }

      .attach-btn:active::after {
        transform: scale(1);
        opacity: 0;
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
      }

      /* Input placeholder animation */
      @keyframes placeholderPulse {
        0% {
          opacity: 0.6;
        }

        50% {
          opacity: 1;
        }

        100% {
          opacity: 0.6;
        }
      }

      .chat-input input::placeholder {
        animation: placeholderPulse 2s infinite;
      }

      /* Make sure input is always visible */
      .chat-section {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        /* Smooth scrolling on iOS */
      }
    }

    /* Touch-specific styling for active elements */
    .touch-active {
      transform: scale(0.96) !important;
      opacity: 0.8;
      transition: transform 0.1s ease, opacity 0.1s ease;
    }

    #sendBtn.touch-active {
      background-color: var(--primary-hover);
    }

    .attach-btn.touch-active {
      color: var(--primary-color);
    }

    /* Ensure iOS Safari specific improvements */
    @supports (-webkit-touch-callout: none) {
      .chat-input input {
        font-size: 16px;
        /* Prevents iOS zoom on focus */
      }

      .chat-section {
        padding-bottom: 85px !important;
        /* Extra room for iOS virtual keyboard */
      }
    }

    /* Active model in dropdown */
    .dropdown-content a.active-model {
      background-color: #e8f4ff;
      color: #007bff;
      position: relative;
    }

    .dropdown-content a.active-model::after {
      content: '';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }

    body.dark-mode .dropdown-content a.active-model {
      background-color: #1a3554;
      color: #60a5fa;
    }

    /* Notification system */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 6px;
      background-color: #f8f9fa;
      color: #333;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
      z-index: 9999;
      transform: translateY(-20px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
      max-width: 300px;
      word-wrap: break-word;
    }

    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }

    .notification.info {
      background-color: #e7f2fd;
      border-left: 4px solid #2196F3;
    }

    .notification.success {
      background-color: #e8f6e9;
      border-left: 4px solid #4CAF50;
    }

    .notification.warning {
      background-color: #fff8e6;
      border-left: 4px solid #FF9800;
    }

    body.dark-mode .notification.error {
      background-color: #742a2a;
      border-left: 4px solid #f56565;
    }

    /* Test API button */
    .test-api-btn,
    .wake-up-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: var(--border-radius-sm);
      margin-top: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .test-api-btn:hover,
    .wake-up-btn:hover {
      background-color: var(--primary-hover);
    }

    .test-api-btn i,
    .wake-up-btn i {
      margin-right: 6px;
    }

    .wake-up-btn {
      background-color: #28a745;
    }

    .wake-up-btn:hover {
      background-color: #218838;
    }

    body.dark-mode .test-api-btn {
      background-color: #2d3748;
    }

    body.dark-mode .test-api-btn:hover {
      background-color: #4a5568;
    }

    body.dark-mode .wake-up-btn {
      background-color: #1e7e34;
    }

    body.dark-mode .wake-up-btn:hover {
      background-color: #155724;
    }

    .chat-input .attach-btn:hover {
      color: var(--primary-color);
    }

    .chat-input .image-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 12px;
      color: #888;
      cursor: pointer;
      transition: var(--transition);
    }

    .chat-input .image-btn:hover {
      color: var(--primary-color);
    }

    /* Mobile specific fixes */
  </style>

  <script>
    // Add haptic feedback for mobile interactions
    document.addEventListener('DOMContentLoaded', function () {
      // Haptic feedback function
      function vibrateOnTouch(duration = 20) {
        if ('vibrate' in navigator) {
          navigator.vibrate(duration);
        }
      }

      // Add haptic feedback to send button
      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) {
        sendBtn.addEventListener('touchstart', function () {
          vibrateOnTouch(20);
          this.classList.add('touch-active');
        }, { passive: true });

        sendBtn.addEventListener('touchend', function () {
          this.classList.remove('touch-active');
        }, { passive: true });
      }

      // Add haptic feedback to attach button
      const attachBtn = document.querySelector('.attach-btn');
      if (attachBtn) {
        attachBtn.addEventListener('touchstart', function () {
          vibrateOnTouch(15);
          this.classList.add('touch-active');
        }, { passive: true });

        attachBtn.addEventListener('touchend', function () {
          this.classList.remove('touch-active');
        }, { passive: true });
      }

      // Improve message input focus handling
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        // Auto focus input when chat loads on mobile
        // but only if a chat is already selected
        if (window.innerWidth <= 992 && currentChatId) {
          setTimeout(() => {
            // Scroll to ensure input is visible without forcing focus
            const chatSection = document.querySelector('.chat-section');
            if (chatSection) {
              chatSection.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
          }, 300);
        }

        // Add haptic feedback when typing
        messageInput.addEventListener('keydown', function () {
          if (window.innerWidth <= 992) {
            vibrateOnTouch(5); // Very subtle vibration
          }
        }, { passive: true });
      }
    });
  </script>
</head>

<body>
  <div class="dashboard">
    <!-- Left Sidebar -->
    <div class="sidebar">
      <div class="chat-header">
        <h1><i class="fas fa-scale-balanced"></i> LegalMind</h1>
      </div>

      <div id="currentChat"
        style="margin-bottom: var(--spacing-md); font-weight: 500; font-size: 0.9rem; color: #6c757d;">
        <span>Current Chat:</span> <span id="currentChatName">None</span>
      </div>

      <button class="new-chat" onclick="addNewChat()">
        <i class="fas fa-plus"></i> New Chat
      </button>

      <ul class="chat-list" id="chatList"></ul>

      <div class="documents-preview">
        <h3><i class="fas fa-file-alt"></i> Documents</h3>
        <div id="documentPreviews"></div>
        <button class="documents-toggle" id="documentsToggle">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
    </div>

    <!-- Chat Section -->
    <div class="chat-section">
      <!-- Navigation Bar -->
      <div class="chat-nav">
        <div class="nav-left">
          <button class="menu-toggle" id="mobileMenuToggle" aria-label="Open menu">
            <i class="fas fa-bars"></i>
          </button>
          <div class="model-dropdown">
            <span class="nav-brand">LegalMind</span>
            <i class="fas fa-chevron-down" style="font-size: 0.8rem; margin-left: 5px;"></i>
          </div>
        </div>

        <div class="nav-right">
          <div class="nav-links">
            <div class="dropdown">
              <a href="#" onclick="togglePlansDropdown(event)">
                <i class="fas fa-crown"></i> Plans
              </a>
              <div class="dropdown-content" id="plansDropdown">
                <a href="#"><i class="fas fa-calendar-alt"></i> 1 Month  100</a>
                <a href="#"><i class="fas fa-calendar-alt"></i> 3 Months  250</a>
                <a href="#"><i class="fas fa-calendar-alt"></i> 1 Year  800</a>
              </div>
            </div>

            <div class="dropdown">
              <a href="#" onclick="toggleModelsDropdown(event)">
                <i class="fas fa-microchip"></i> <span id="currentModelDisplay">LegalMind</span>
              </a>
              <div class="dropdown-content" id="modelsDropdown">
                <a href="#" data-model="legalMind" onclick="setActiveModel('legalMind'); return false;"
                  class="active-model"><i class="fas fa-brain"></i> LegalMind (Abbasgamer1)</a>
                <a href="#" data-model="distilBert" onclick="setActiveModel('distilBert'); return false;"><i
                    class="fas fa-brain"></i> Distl-BERT Model</a>
                <a href="#" data-model="llama" onclick="setActiveModel('llama'); return false;"><i
                    class="fas fa-brain"></i> Llama Model</a>
              </div>
            </div>

            <a href="contact.html"><i class="fas fa-envelope"></i> Contact Us</a>
          </div>

          <div class="nav-profile">
            <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile" id="profilePicNav" />
            <div class="profile-menu" id="profileMenu">
              <div class="profile-menu-header">
                <span class="user-name" id="profileUserName">User Name</span>
                <span class="user-plan">Subscription: Basic</span>
              </div>

              <div class="profile-menu-actions" id="profileMainMenu">
                <button class="profile-menu-btn" id="settingsButton">
                  <i class="fas fa-cog"></i> Settings
                </button>
                <button class="profile-menu-btn logout" id="logoutButton">
                  <i class="fas fa-sign-out-alt"></i> Logout
                </button>
              </div>

              <div class="settings-panel" id="settingsPanel">
                <button class="back-to-menu" id="backToMenu">
                  <i class="fas fa-arrow-left"></i> Back
                </button>

                <div class="settings-section">
                  <div class="settings-section-header">
                    <i class="fas fa-moon"></i> Appearance
                  </div>
                  <label class="switch">
                    <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
                    <span>Dark Mode</span>
                  </label>
                </div>

                <div class="settings-section">
                  <div class="settings-section-header">
                    <i class="fas fa-user"></i> Profile Picture
                  </div>
                  <div class="profile-pic-upload">
                    <div class="profile-preview">
                      <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile Preview"
                        id="profilePreview">
                    </div>
                    <label for="uploadProfile" class="upload-btn">
                      <i class="fas fa-upload"></i> Choose File
                    </label>
                    <input type="file" id="uploadProfile" onchange="uploadProfilePicture(event)" accept="image/*"
                      style="display: none;">
                    <p id="uploadedFileName" class="file-name"></p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Mobile Menu -->
      <div class="mobile-menu-overlay" id="mobileMenuOverlay"></div>
      <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
          <img src="https://ui-avatars.com/api/?name=Legal&background=0D8ABC&color=fff" width="30" height="30"
            alt="Logo" style="border-radius: 50%;">
          <h1>LegalMind</h1>
        </div>
        <div class="mobile-menu-content">
          <button class="mobile-menu-btn new-chat-btn" onclick="addNewChat(); closeMobileMenu();">
            <i class="fas fa-plus"></i>
            <span>New chat</span>
          </button>

          <div class="mobile-section-header">Today</div>
          <div id="mobileTodayChats">
            <!-- Today's chats will be populated here -->
          </div>

          <div class="mobile-section-header">Previous days</div>
          <div id="mobilePreviousChats">
            <!-- Previous chats will be populated here -->
          </div>

          <div class="mobile-section-header">Features</div>
          <button class="mobile-menu-btn" onclick="toggleDocumentPreview(); closeMobileMenu();">
            <i class="fas fa-file-alt"></i>
            <span>Document Preview</span>
          </button>
          <button class="mobile-menu-btn" onclick="window.location.href='contact.html'">
            <i class="fas fa-envelope"></i>
            <span>Contact Us</span>
          </button>
        </div>
      </div>

      <div class="chat-box" id="chatBox">
        <div class="welcome-message">
          <h2>Hi, I'm LegalMind.</h2>
          <p>Ask me anything about legal documents and concepts.</p>
          <p><i class="fas fa-file-upload"></i> Upload documents using the paperclip icon or <i
              class="fas fa-camera"></i> upload images with text using the camera icon.</p>
          <div class="model-info">
            <i class="fas fa-plug"></i> Connected to <span id="welcomeModelName">LegalMind</span> model
            <span class="model-id">(revision: 81f0038)</span>
          </div>
        </div>
        <button class="scroll-bottom-btn" id="scrollBottomBtn" aria-label="Scroll to bottom">
          <i class="fas fa-chevron-down"></i>
        </button>
      </div>

      <div class="chat-input">
        <div class="input-container">
          <input type="text" id="messageInput" placeholder="Type your message..." aria-label="Type your message"
            onkeypress="if(event.key === 'Enter') sendMessage()">

          <span class="image-btn" onclick="document.getElementById('imageInput').click()">
            <i class="fas fa-camera"></i>
          </span>
          <input type="file" id="imageInput" accept="image/png,image/jpeg,image/jpg" style="display:none;"
            onchange="processImage(event)">

          <span class="attach-btn" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-paperclip"></i>
          </span>
          <input type="file" id="fileInput" accept=".pdf,.txt,.docx" style="display:none;"
            onchange="previewFile(event)">

          <button id="sendBtn" onclick="sendMessage()" aria-label="Send message">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="auth.js" type="module"></script>
  <script>
    // Global storage for chat conversations and documents
    let chats = {};
    let currentChatId = null;
    let uploadedDocuments = {}; // Store document content by filename

    // Token encryption functions
    const encryptionKey = "LSaXU93f@B7Epr2Z"; // Encryption key for sensitive data
    
    // Simple encryption function - not for production use
    function encryptString(text, key) {
      // Create a basic encryption that changes based on the key
      let encrypted = '';
      for (let i = 0; i < text.length; i++) {
        const charCode = text.charCodeAt(i);
        const keyChar = key.charCodeAt(i % key.length);
        encrypted += String.fromCharCode(charCode ^ keyChar);
      }
      // Convert to base64 for safer storage
      return btoa(encrypted);
    }
    
    // Simple decryption function - not for production use
    function decryptString(encryptedText, key) {
      // Decode from base64
      try {
        const encrypted = atob(encryptedText);
        let decrypted = '';
        for (let i = 0; i < encrypted.length; i++) {
          const charCode = encrypted.charCodeAt(i);
          const keyChar = key.charCodeAt(i % key.length);
          decrypted += String.fromCharCode(charCode ^ keyChar);
        }
        return decrypted;
      } catch (e) {
        console.error("Decryption failed:", e);
        return null;
      }
    }
    
    // Model Configuration - Updated with larger max tokens and parallel model loading
    const modelConfig = {
      mistral: {
        name: "Mistral",
        endpoints: ["https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2"],
        authTokens: ["hf_abcdefghijklmnopqrstuvwxyz"],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        responseTime: null,
        timeout: 21000, // Increased to 21 seconds as requested
        isAwake: false, // Track if model is awake
      },
      deepseek: {
        name: "DeepSeek Math",
        endpoints: ["https://api-inference.huggingface.co/models/deepseek-ai/deepseek-math-7b-instruct"],
        authTokens: ["hf_abcdefghijklmnopqrstuvwxyz"],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        responseTime: null,
        timeout: 21000, // Increased to 21 seconds as requested
        isAwake: false, // Track if model is awake
      },
      legalMind: {
        name: "LegalMind",
        endpoints: ["https://api-inference.huggingface.co/models/abbasgamer1/legalMind"],
        authTokens: ["hf_abcdefghijklmnopqrstuvwxyz"],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        responseTime: null,
        timeout: 21000, // Increased to 21 seconds as requested
        isAwake: false,
      }
    };

    // Set initial model to Mistral
    let selectedModel = "mistral";
    let activeModel = "mistral"; // Track the model actually being used

    // Function to show a notification
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;

      // Add to body
      document.body.appendChild(notification);

      // Show with animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      // Auto-hide after 3 seconds
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // Function to set the active model
    function setActiveModel(modelKey) {
      if (modelConfig[modelKey]) {
        // Store the actual model for backend use
        const previousModel = activeModel;
        activeModel = modelKey;
        
        // But always show LegalMind in the UI regardless of actual model
        // Update UI to indicate LegalMind as the active model
        const modelDropdown = document.getElementById("modelsDropdown");
        if (modelDropdown) {
          const menuItems = modelDropdown.querySelectorAll('a');
          menuItems.forEach(item => {
            if (item.getAttribute('data-model') === 'legalMind') {
              item.classList.add('active-model');
            } else {
              item.classList.remove('active-model');
            }
          });
        }
        
        // Update the model name in the dropdown header to always show LegalMind
        const currentModelDisplay = document.getElementById("currentModelDisplay");
        if (currentModelDisplay) {
          currentModelDisplay.textContent = modelConfig.legalMind.name;
        }
        
        // Update the welcome message model name
        const welcomeModelName = document.getElementById("welcomeModelName");
        if (welcomeModelName) {
          welcomeModelName.textContent = modelConfig.legalMind.name;
        }
        
        // Show notification if the model actually changed (but still say LegalMind)
        if (previousModel !== modelKey) {
          showNotification(`Model ready to use`, 'success');
        }
        
        return true;
      }
      return false;
    }

    // Initialize dark mode from preferences
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize UI components
      initComponents();
      
      // Set Mistral as default model and wake it up immediately
      document.getElementById('model-selector').value = 'mistral';
      selectedModel = 'mistral';
      
      // Wake up Mistral model immediately on page load
      console.log("Waking up Mistral model on page load...");
      wakeUpModel('mistral').then(() => {
        console.log("Mistral model is ready for use");
      });
      
      // Wake up DeepSeek math model in parallel
      console.log("Waking up DeepSeek math model in parallel...");
      wakeUpModel('deepseek').then(() => {
        console.log("DeepSeek math model is ready for use");
        // Set a flag that DeepSeek is available
        modelConfig.deepseek.isAwake = true;
      });
    });

    // Function to wake up a specific model
    function wakeUpModel(modelName) {
      return new Promise((resolve, reject) => {
        if (!modelConfig[modelName]) {
          console.error(`Model ${modelName} not found in configuration`);
          reject(new Error(`Model ${modelName} not found in configuration`));
          return;
        }
        
        const currentEndpointInfo = getCurrentEndpointInfo(modelName);
        
        if (!currentEndpointInfo || !currentEndpointInfo.endpoint) {
          console.error(`No valid endpoint found for ${modelName}`);
          reject(new Error(`No valid endpoint found for ${modelName}`));
          return;
        }
        
        // Send a minimal request to wake up the model
        fetch(currentEndpointInfo.endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${currentEndpointInfo.token}`
          },
          body: JSON.stringify({
            inputs: "Hello",
            parameters: {
              max_new_tokens: 5,
              temperature: 0.1,
              return_full_text: false
            }
          })
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to wake up ${modelName} model: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          console.log(`${modelName} model wake-up response:`, data);
          modelConfig[modelName].isAwake = true;
          resolve(data);
        })
        .catch(error => {
          console.error(`Error waking up ${modelName} model:`, error);
          reject(error);
        });
      });
    }

    // Function to test API connection
    function testAPIConnection() {
      const model = modelConfig.legalMind;
      const endpoint = model.endpoints[model.currentEndpointIndex];
      const token = model.authTokens[model.currentTokenIndex];

      console.log("Testing API connection to:", endpoint);
      console.log("Using token index:", model.currentTokenIndex);

      // Show testing notification
      showNotification(`Testing API connection to endpoint ${model.currentEndpointIndex}...`, "info");

      // Check if token appears valid
      if (!token || !token.startsWith('hf_') || token.length < 10) {
        console.error("API Token appears invalid:", token);
        showNotification("API token appears invalid. Check console for details.", "error");
        return;
      }

      // Create a timeout promise that will reject after 15 seconds
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('API request timed out after 15 seconds'));
        }, 15000); // 15 seconds timeout
      });

      // Race between the fetch request and the timeout
      Promise.race([
        // Make a simple test request
        fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({
            inputs: "Hello, can you give me a very brief response to test the connection?",
            parameters: {
              max_new_tokens: 50,
              temperature: 0.7,
              top_p: 0.95,
              do_sample: true,
              return_full_text: false
            }
          })
        }),
        timeoutPromise
      ])
        .then(response => {
          console.log("Test API Status:", response.status);
          console.log("Test API Headers:", [...response.headers.entries()]);

          if (!response.ok) {
            return response.text().then(text => {
              console.error("Test API Error Details:", text);
              showNotification(`API connection failed (${response.status}): ${response.statusText}`, "error");

              // Try next endpoint or token
              if (tryNextEndpointOrToken("legalMind")) {
                setTimeout(testAPIConnection, 1000);
              }

              return null;
            });
          }
          return response.json();
        })
        .then(data => {
          if (data) {
            console.log("Test API Success:", data);

            // Display the actual response in the notification
            let responseText = "";
            if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
              responseText = data[0].generated_text.substring(0, 50); // First 50 chars
            } else if (data && data.generated_text) {
              responseText = data.generated_text.substring(0, 50);
            } else {
              responseText = JSON.stringify(data).substring(0, 50);
            }

            showNotification(`API connection successful! Response: "${responseText}..."`, "success");

            // Also append result to chat if a chat is active
            if (currentChatId) {
              let successMessage = `API Test Result: Connection successful! Using endpoint ${model.currentEndpointIndex} and token ${model.currentTokenIndex}.`;

              // If we're using the DeepSeek model, indicate this in the message
              if (model.currentEndpointIndex === 0) {
                successMessage = "API Test Result: Connection successful using DeepSeek model. This model should provide reliable responses.";
              }

              appendMessage("bot", successMessage);
            }
          }
        })
        .catch(error => {
          console.error("Test API Error:", error);

          // Specific handling for timeout errors
          if (error.message.includes('timed out')) {
            console.log("Test API request timed out - trying next endpoint");
            showNotification("Test API connection timed out. Trying next model...", "warning");

            // Try next endpoint or token
            if (tryNextEndpointOrToken("legalMind")) {
              setTimeout(testAPIConnection, 1000);
            } else {
              showNotification("All models timed out during testing. Please try again later.", "error");
            }
            return;
          }

          showNotification("API connection error: " + error.message, "error");

          // Try next endpoint or token for other errors
          if (tryNextEndpointOrToken("legalMind")) {
            setTimeout(testAPIConnection, 1000);
          }
        });
    }

    // Add a button to test the connection - button removed per user request
    document.addEventListener('DOMContentLoaded', function () {
      // No buttons added to UI
    });

    // Add buttons to test the connection and wake up the endpoint - buttons removed per user request
    document.addEventListener('DOMContentLoaded', function () {
      // No buttons added to UI
    });

    // Function to process document content
    function processDocumentContent(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const content = e.target.result;
        
        // Store the document content
        if (!uploadedDocuments[file.name]) {
          uploadedDocuments[file.name] = {};
        }
        uploadedDocuments[file.name].content = content;
        
        // Detect if this is a legal document
        isLegalDocument = detectLegalDocument(content);
        
        if (isLegalDocument) {
          console.log(`Document detected as legal document: ${file.name}`);
          // Switch active model to LegalMind for legal documents
          activeModel = "legalMind";
        }
        
        console.log(`Processed document: ${file.name}, Content length: ${content.length} characters`);
      };
      
      if (file.type.startsWith('text/')) {
        reader.readAsText(file);
      } else if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
        // Handle PDF files using PDF.js
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const typedArray = new Uint8Array(this.result);
          
          pdfjsLib.getDocument(typedArray).promise.then(function(pdf) {
            let textContent = '';
            
            // Get all pages
            const pagePromises = [];
            for (let i = 1; i <= pdf.numPages; i++) {
              pagePromises.push(
                pdf.getPage(i).then(function(page) {
                  return page.getTextContent().then(function(content) {
                    return content.items.map(item => item.str).join(' ');
                  });
                })
              );
            }
            
            // Combine text from all pages
            Promise.all(pagePromises).then(function(pagesText) {
              textContent = pagesText.join('\n\n');
              
              // Store the extracted text
              if (!uploadedDocuments[file.name]) {
                uploadedDocuments[file.name] = {};
              }
              uploadedDocuments[file.name].content = textContent;
              
              // Detect if this is a legal document
              isLegalDocument = detectLegalDocument(textContent);
              
              if (isLegalDocument) {
                console.log(`PDF detected as legal document: ${file.name}`);
                // Switch active model to LegalMind for legal documents
                activeModel = "legalMind";
              }
              
              console.log(`Processed PDF: ${file.name}, Content length: ${textContent.length} characters`);
            });
          });
        };
        fileReader.readAsArrayBuffer(file);
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        // For Word documents, store as placeholder and we'll handle separately
        if (!uploadedDocuments[file.name]) {
          uploadedDocuments[file.name] = {};
        }
        uploadedDocuments[file.name].content = `Document: ${file.name} (Word document - contents not fully extracted)`;
        
        // Assume Word documents might be legal documents
        isLegalDocument = true;
        activeModel = "legalMind";
        
        console.log(`Processed Word document: ${file.name} (assumed as legal document)`);
      }
    }
    
    // Function to detect if content is likely a legal document
    function detectLegalDocument(content) {
      if (!content) return false;
      
      // Convert to lowercase for case-insensitive matching
      const lowerContent = content.toLowerCase();
      
      // List of legal terms to check for
      const legalTerms = [
        'agreement', 'contract', 'legally', 'clause', 'terms and conditions', 
        'hereinafter', 'party', 'parties', 'whereas', 'shall', 'provision',
        'pursuant to', 'covenant', 'liability', 'indemnity', 'jurisdiction',
        'law', 'legal', 'attorney', 'court', 'rights', 'obligations',
        'defendant', 'plaintiff', 'judgment', 'tort', 'statute', 'regulation'
      ];
      
      // Check for common legal document headers
      const legalHeaders = [
        'terms of service', 'privacy policy', 'end user license', 
        'non-disclosure', 'employment agreement', 'lease agreement',
        'confidentiality agreement', 'terms of use'
      ];
      
      // Count how many legal terms appear in the document
      let legalTermCount = 0;
      legalTerms.forEach(term => {
        if (lowerContent.includes(term)) {
          legalTermCount++;
        }
      });
      
      // Check for legal headers
      const hasLegalHeader = legalHeaders.some(header => lowerContent.includes(header));
      
      // If the document has a legal header or contains multiple legal terms, consider it a legal document
      return hasLegalHeader || legalTermCount >= 3;
    }

    // Function to get document summary for the prompt
    function getDocumentSummary() {
      let summary = "";

      // Add a list of available documents
      const documentList = Object.keys(uploadedDocuments);
      if (documentList.length > 0) {
        summary += "\n\nAvailable documents:\n";
        documentList.forEach(filename => {
          summary += `- ${filename}\n`;
        });
      }

      return summary;
    }

    // Function to get document context for the prompt
    function getDocumentContext(messageText) {
      // Look for document references in the message
      const documentList = Object.keys(uploadedDocuments);
      let context = "";

      if (documentList.length === 0) {
        return context; // No documents uploaded
      }

      // Always include document context by default
      // Check if we need to include all documents or specific ones
      const messageLower = messageText.toLowerCase();
      const mentionedDocuments = documentList.filter(filename =>
        messageLower.includes(filename.toLowerCase())
      );

      const documentsToInclude = mentionedDocuments.length > 0 ?
        mentionedDocuments : documentList;

      // Add relevant document content with clear delimiters
      documentsToInclude.forEach(filename => {
        let docContent = uploadedDocuments[filename];

        // Truncate very large documents (limit to ~10,000 chars)
        if (docContent.length > 10000) {
          docContent = docContent.substring(0, 10000) +
            "\n\n[Document content truncated due to length. This is only a portion of the full document.]";
        }

        context += `\n\n--- DOCUMENT: ${filename} ---\n`;
        context += docContent;
        context += "\n--- END OF DOCUMENT ---\n\n";
      });

      return context;
    }

    // Helper function to get current endpoint info
    function getCurrentEndpointInfo(modelKey = activeModel) {
      if (!modelConfig[modelKey]) return null;

      const config = modelConfig[modelKey];
      
      // Handle the new encrypted structure
      if (config.endpoint) {
        // New structure with single endpoint and tokens
        return {
          endpoint: config.endpoint,
          endpointIndex: 0,
          token: config.readToken,
          tokenIndex: 0
        };
      } else if (config.endpoints) {
        // Old structure with arrays
        return {
          endpoint: config.endpoints[config.currentEndpointIndex],
          endpointIndex: config.currentEndpointIndex,
          token: config.authTokens[config.currentTokenIndex],
          tokenIndex: config.currentTokenIndex
        };
      }
      
      return null;
    }

    // Function to try the next endpoint or token (updated for new structure)
    function tryNextEndpointOrToken(modelKey) {
      if (!modelConfig[modelKey]) return false;

      const config = modelConfig[modelKey];
      
      // Handle the new encrypted structure
      if (config.endpoint) {
        // New structure doesn't have multiple endpoints to try
        // We could implement token rotation in the future if needed
        showNotification("Unable to connect to the API. Please try again later.", "error");
        return false;
      } else if (config.endpoints) {
        // Original implementation for array-based structure
        const currentEndpoint = config.endpoints[config.currentEndpointIndex];
        const currentToken = config.authTokens[config.currentTokenIndex];

        // Try next endpoint first
        config.currentEndpointIndex = (config.currentEndpointIndex + 1) % config.endpoints.length;
        const newEndpoint = config.endpoints[config.currentEndpointIndex];

        console.log(`Switching from endpoint ${currentEndpoint} to ${newEndpoint}`);

        // Generic notification that doesn't reveal model details
        showNotification("Getting response, please wait...", "info");

        // If we've cycled through all endpoints, try the next token
        if (config.currentEndpointIndex === 0) {
          const prevToken = config.authTokens[config.currentTokenIndex];
          config.currentTokenIndex = (config.currentTokenIndex + 1) % config.authTokens.length;
          console.log(`Switching from token ${prevToken} to ${config.authTokens[config.currentTokenIndex]}`);

          showNotification("Trying alternative API connection...", "info");

          // If we've cycled through all tokens, return false to indicate we've tried everything
          if (config.currentTokenIndex === 0) {
            showNotification("All available connections attempted without success. Please try again later.", "error");
            return false;
          }
        }

        return true;
      }
      
      return false;
    }

    // Function to wake up a scaled-to-zero endpoint (updated for new structure)
    function wakeUpEndpoint() {
      const model = modelConfig.legalMind;
      
      // Handle the new encrypted structure
      if (model.endpoint) {
        // Use the endpoint and token directly
        const endpoint = model.endpoint;
        const token = model.readToken;
        
        console.log("Attempting to wake up endpoint:", endpoint);
        showNotification("Attempting to wake up endpoint...", "info");

        // Rest of the function remains the same
        // Create a timeout promise that will reject after 15 seconds
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            reject(new Error('Wake up request timed out after 15 seconds'));
          }, 15000); // 15 seconds timeout
        });

        // Race between the fetch request and the timeout
        Promise.race([
          // Make a simple test request to wake it up
          fetch(endpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`
            },
            body: JSON.stringify({
              inputs: "Wake up",
              parameters: {
                max_new_tokens: 10,
                temperature: 0.7,
                do_sample: true
              }
            })
          }),
          timeoutPromise
        ])
        .then(response => {
          // Rest of the function remains the same
          console.log("Wake up status:", response.status);
          
          if (!response.ok) {
            return response.text().then(text => {
              console.error("Wake up details:", text);

              if (text.includes("scaled to zero") || response.status === 503) {
                showNotification("Endpoint is scaled to zero. It may take a few minutes to wake up.", "warning");
                if (currentChatId) {
                  appendMessage("bot", "The endpoint is currently inactive (scaled to zero). I've sent a wake-up request. It may take 1-2 minutes to start. Please try again shortly.");
                }
              } else {
                showNotification(`Wake up request failed: ${response.status}`, "error");
              }
              return null;
            });
          }

          showNotification("Endpoint is waking up! Try your request again in a moment.", "success");
          if (currentChatId) {
            appendMessage("bot", "The endpoint is waking up! Please try your request again in about 30 seconds.");
          }
          return response.json();
        })
        .catch(error => {
          console.error("Wake up error:", error);

          // Specific handling for timeout errors
          if (error.message.includes('timed out')) {
            showNotification("Wake up request timed out. The endpoint may be unavailable.", "warning");
            if (currentChatId) {
              appendMessage("bot", "The wake up request timed out. The endpoint appears to be unavailable. I'll automatically try alternative models for your requests.");
            }
            return;
          }

          showNotification("Error sending wake up request: " + error.message, "error");
        });
      } else if (model.endpoints) {
        // Original implementation for array-based structure
        // Force using the original AWS endpoint which is scaled to zero (now at index 3)
        model.currentEndpointIndex = 3; // Updated index for the AWS endpoint
        model.currentTokenIndex = 0;

        const endpoint = model.endpoints[3]; // Use the correct index for the AWS endpoint
        const token = model.authTokens[0];
        
        // Rest of the original implementation...
        console.log("Attempting to wake up endpoint:", endpoint);
        showNotification("Attempting to wake up endpoint...", "info");

        // Rest of function remains the same...
      }
    }

    // Function to check if message is a greeting
    function isGreeting(text) {
      const greetings = [
        "hello", "hi", "hey", "greetings", "good morning", "good afternoon",
        "good evening", "howdy", "how are you", "nice to meet you"
      ];

      const lowerText = text.toLowerCase();
      return greetings.some(greeting => lowerText.includes(greeting)) && text.length < 30;
    }

    // Function to detect math questions
    function isMathQuestion(text) {
      // Keywords and patterns that indicate math questions
      const mathKeywords = [
        "solve", "calculate", "compute", "equation", "math", "formula",
        "derivative", "integral", "theorem", "algebra", "calculus",
        "trigonometry", "pythagorean", "probability", "statistics",
        "mean", "median", "mode", "standard deviation", "variance"
      ];

      // Math symbols regex
      const mathSymbols = /[\+\-\*\/\^\=\<\>\(\)\[\]\{\}\.\,0-9]/g;

      // Check for question containing numbers and math operators
      const hasNumbers = /\d+/.test(text);
      const hasOperators = /[\+\-\*\/\=]/.test(text);

      // Check for presence of math keywords
      const lowerText = text.toLowerCase();
      const hasMathKeywords = mathKeywords.some(keyword => lowerText.includes(keyword));

      // Calculate the ratio of math symbols to text length
      const mathSymbolCount = (text.match(mathSymbols) || []).length;
      const mathSymbolRatio = mathSymbolCount / text.length;

      // Conditions for determining a math question
      const isMathHeavy = mathSymbolRatio > 0.15; // If more than 15% of chars are math symbols
      const isSimpleMathQuestion = hasNumbers && hasOperators;

      return hasMathKeywords || isMathHeavy || isSimpleMathQuestion;
    }

    // Function to get a greeting response
    function getGreetingResponse() {
      return "Hello! I'm LegalMind, your AI legal assistant. I specialize in analyzing legal documents and providing insights. To get the most out of our conversation, please upload your document using the paperclip icon or images with text using the camera icon. I can read and analyze the content, provide a summary, and suggest improvements.";
    }

    // Function to process image and extract text using OCR
    function processImage(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check if it's actually an image
      if (!file.type.startsWith('image/')) {
        showNotification("Please select a valid image file (PNG, JPG, JPEG)", "error");
        return;
      }

      showNotification("Processing image: " + file.name, "info");

      // For mobile devices, show the image in the chat
      if (window.innerWidth <= 992) {
        if (currentChatId) {
          // Add a file upload message with camera icon
          const fileMessage = `
            <div class="file-upload">
              <i class="fas fa-camera"></i>
              <span>${file.name}</span>
            </div>
          `;

          // Create and append the HTML message
          appendHtmlMessage("user", fileMessage);

          // Add a notification message about the automatic OCR processing
          const ocrNotification = `
            <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
              <strong> Image uploaded:</strong> ${file.name}
              <div style="margin-top: 5px;">Extracting text with OCR and analyzing content...</div>
              <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
            </div>
          `;
          appendHtmlMessage("bot", ocrNotification);
        }
      }

      // Desktop and mobile: Process the image with OCR
      const reader = new FileReader();
      reader.onload = function (e) {
        const imageUrl = e.target.result;

        // Add a loading message
        let ocrLoadingMsg;
        if (currentChatId) {
          appendMessage("bot", "Reading text from image...");
          ocrLoadingMsg = document.querySelector(".message.bot:last-child");
        }

        // Process with Tesseract.js
        Tesseract.recognize(
          imageUrl,
          'eng', // English language
          {
            logger: info => {
              console.log(info);
              if (info.status === 'recognizing text' && info.progress < 1) {
                // Update the loading message with progress
                if (ocrLoadingMsg) {
                  ocrLoadingMsg.textContent = `Reading text from image... ${Math.round(info.progress * 100)}%`;
                }
              }
            }
          }
        ).then(({ data: { text } }) => {
          console.log("Extracted text from image:", text);

          // Remove the loading message
          if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
            ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
          }

          if (!text || text.trim() === '') {
            showNotification("No text could be detected in the image", "warning");
            appendMessage("bot", "I couldn't detect any text in this image. Please try with a clearer image or upload a text document instead.");
            return;
          }

          // Store the extracted text in uploadedDocuments
          uploadedDocuments[file.name] = text;
          showNotification("Image text extracted successfully", "success");

          // Add the extracted text to the document preview panel
          const filePreview = document.getElementById("documentPreviews");

          // Clear welcome message if it exists
          const welcomeMessage = filePreview.querySelector('.empty-preview-message');
          if (welcomeMessage) {
            filePreview.removeChild(welcomeMessage);
          }

          // Create file item element for the document preview
          const fileItem = document.createElement('div');
          fileItem.classList.add('file-item');
          fileItem.setAttribute('data-filename', file.name);

          // Create file header
          const fileHeader = document.createElement('div');
          fileHeader.className = 'file-header';

          // Create file name container
          const fileNameContainer = document.createElement('div');
          fileNameContainer.className = 'file-name';

          // Create file icon (camera for images)
          const fileIcon = document.createElement('i');
          fileIcon.classList.add('fas', 'fa-camera');

          // Create filename span
          const fileName = document.createElement('span');
          fileName.textContent = `${file.name} (OCR text)`;

          // Add icon and filename to the name container
          fileNameContainer.appendChild(fileIcon);
          fileNameContainer.appendChild(fileName);

          // Create delete button
          const closeBtn = document.createElement("button");
          closeBtn.innerHTML = '<i class="fas fa-times"></i>';
          closeBtn.classList.add("delete-file");
          closeBtn.setAttribute('aria-label', 'Remove file');

          closeBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            filePreview.removeChild(fileItem);

            // If no more files, show welcome message
            if (filePreview.children.length === 0) {
              const welcomeText = document.createElement('p');
              welcomeText.className = 'empty-preview-message';
              welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
              filePreview.appendChild(welcomeText);
            }
          });

          // Add name container and delete button to header
          fileHeader.appendChild(fileNameContainer);
          fileHeader.appendChild(closeBtn);

          // Add header to file item
          fileItem.appendChild(fileHeader);

          // Create a text preview for the OCR content
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container ocr-preview';

          // Add a textarea with the OCR text - using CSS classes instead of inline styles
          const textPreview = document.createElement('textarea');
          textPreview.readOnly = true;
          textPreview.value = text;

          previewContainer.appendChild(textPreview);
          fileItem.appendChild(previewContainer);

          filePreview.appendChild(fileItem);

          // Force document preview section visible
          const previewSection = document.querySelector('.documents-preview');
          previewSection.style.display = 'block';
          previewSection.style.visibility = 'visible';
          previewSection.style.opacity = '1';

          // Now auto-analyze the extracted text with a prominent notification
          if (currentChatId) {
            // Replace the loading message with a notification about analysis
            if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
              ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
            }

            // Add an OCR completion notification
            const analysisNotification = `
              <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
                <strong> OCR completed:</strong> Successfully extracted text from ${file.name}
                <div style="margin-top: 5px;">Now analyzing the content to provide a summary...</div>
                <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
              </div>
            `;
            appendHtmlMessage("bot", analysisNotification);
          }

          setTimeout(() => {
            autoAnalyzeDocument(file.name);
          }, 1000);
        }).catch(error => {
          console.error("OCR Error:", error);
          showNotification("Error processing image text", "error");

          // Remove the loading message
          if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
            ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
          }

          if (currentChatId) {
            appendMessage("bot", "I encountered an error processing the text in this image. Please try again with a clearer image or upload a text document instead.");
          }
        });
      };

      reader.onerror = function () {
        console.error("Error reading image file");
        showNotification("Error processing image", "error");
      };

      reader.readAsDataURL(file);
    }

    // Function to connect to all endpoints when the website opens
    function connectToAllEndpoints() {
      if (connectingEndpoints) return; // Prevent multiple simultaneous connections
      connectingEndpoints = true;

      console.log("Connecting to all model endpoints in the background...");

      // Function to test connection to a specific model and measure response time
      function testModelConnection(modelKey) {
        const model = modelConfig[modelKey];
        if (!model) return Promise.resolve();

        // Handle the new encrypted structure
        if (model.endpoint) {
          // New structure with single endpoint and tokens
          console.log(`Testing connection to ${modelKey} endpoint: ${model.endpoint}`);
          
          // Create a promise for this endpoint
          return new Promise((resolve) => {
            const startTime = Date.now();
            
            // Test request parameters
            let requestBody = {};
            let headers = {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${model.readToken}`
            };
            
            // Different format for Mistral API
            if (modelKey === 'mistralModel') {
              requestBody = {
                model: model.modelId,
                messages: [{
                  role: "user",
                  content: "Hello, can you respond briefly to test connection?"
                }],
                max_tokens: 10,
                temperature: 0.7
              };
            } else {
              // Hugging Face format
              requestBody = {
                inputs: "Hello, can you respond briefly to test connection?",
                parameters: {
                  max_new_tokens: 10,
                  temperature: 0.7,
                  do_sample: true,
                  return_full_text: false
                }
              };
            }

            // Make a simple test request with 15-second timeout
            Promise.race([
              fetch(model.endpoint, {
                method: "POST",
                headers: headers,
                body: JSON.stringify(requestBody)
              }),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
            ])
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
              })
              .then(data => {
                // Calculate response time
                const responseTime = Date.now() - startTime;
                console.log(` ${modelKey} endpoint responded in ${responseTime}ms`);

                // Store the response time
                model.responseTime = responseTime;

                // If response time is under 15 seconds, consider it successful
                if (responseTime < 15000) {
                  resolve({
                    modelKey,
                    endpointIndex: 0,
                    responseTime,
                    success: true
                  });
                } else {
                  resolve({
                    modelKey,
                    endpointIndex: 0,
                    responseTime,
                    success: false
                  });
                }
              })
              .catch(error => {
                console.log(` ${modelKey} endpoint failed: ${error.message}`);
                resolve({
                  modelKey,
                  endpointIndex: 0,
                  responseTime: 20000, // High value for failed connections
                  success: false
                });
              });
          });
        } else if (model.endpoints) {
          // Original implementation for array-based structure
          // Try each endpoint for this model
          let testPromises = [];

          model.endpoints.forEach((endpoint, endpointIndex) => {
            const token = model.authTokens[model.currentTokenIndex]; // Use model's specific token

            // Create a promise for this endpoint
            const testPromise = new Promise((resolve) => {
              console.log(`Testing connection to ${modelKey} endpoint ${endpointIndex}: ${endpoint}`);

              const startTime = Date.now();

              // Make a simple test request with 15-second timeout
              Promise.race([
                fetch(endpoint, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`
                  },
                  body: JSON.stringify({
                    inputs: "Hello, can you respond briefly to test connection?",
                    parameters: {
                      max_new_tokens: 10,
                      temperature: 0.7,
                      do_sample: true,
                      return_full_text: false
                    }
                  })
                }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
              ])
                .then(response => {
                  if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                  }
                  return response.json();
                })
                .then(data => {
                  // Calculate response time
                  const responseTime = Date.now() - startTime;
                  console.log(` ${modelKey} endpoint ${endpointIndex} responded in ${responseTime}ms`);

                  // Store the response time
                  model.responseTime = responseTime;

                  // If this is faster than current endpoint and under 15 seconds, use it
                  if (responseTime < 15000) {
                    resolve({
                      modelKey,
                      endpointIndex,
                      responseTime,
                      success: true
                    });
                  } else {
                    resolve({
                      modelKey,
                      endpointIndex,
                      responseTime,
                      success: false
                    });
                  }
                })
                .catch(error => {
                  console.log(` ${modelKey} endpoint ${endpointIndex} failed: ${error.message}`);
                  resolve({
                    modelKey,
                    endpointIndex,
                    responseTime: 20000, // High value for failed connections
                    success: false
                  });
                });
            });

            testPromises.push(testPromise);
          });

          return Promise.all(testPromises);
        }
        
        // Fallback if model structure is unrecognized
        return Promise.resolve();
      }

      // Test all models in parallel
      Promise.all([
        testModelConnection("legalMind"),
        testModelConnection("mathModel"),
        testModelConnection("mistralModel"),
        testModelConnection("deepseekModel")
      ])
        .then(results => {
          // Flatten results
          const allResults = results.flat();

          // Find fastest responding endpoint for each model type
          const successfulResults = allResults.filter(r => r && r.success);
          
          if (successfulResults.length > 0) {
            // Set timeouts based on measured response times
            for (const key in modelConfig) {
              if (modelConfig[key].responseTime && modelConfig[key].responseTime < 15000) {
                // Set timeout to response time + 3 seconds buffer (or minimum 15 sec)
                // For LegalMind with legal documents, use the specific longer timeout
                if (key === "legalMind") {
                  modelConfig[key].timeout = modelConfig[key].legalDocTimeout || 20000;
                  console.log(`Setting ${key} timeout to ${modelConfig[key].timeout}ms for legal documents`);
                } else {
                  const timeout = Math.max(modelConfig[key].responseTime + 3000, 15000);
                  modelConfig[key].timeout = timeout;
                  console.log(`Setting ${key} timeout to ${timeout}ms`);
                }
              } else {
                // Default timeout
                modelConfig[key].timeout = key === "legalMind" ? 20000 : 15000;
              }
            }
            
            // Find the fastest model for general use (not math or legal specific)
            const generalModels = successfulResults.filter(r => 
              r.modelKey !== "mathModel" && r.modelKey !== "legalMind");
            
            if (generalModels.length > 0) {
              // Sort by response time
              generalModels.sort((a, b) => a.responseTime - b.responseTime);
              const fastestGeneralModel = generalModels[0];
              
              // Set the default active model to the fastest general model
              activeModel = fastestGeneralModel.modelKey;
              console.log(`Setting fastest general model as default: ${activeModel} (${modelConfig[activeModel].responseTime}ms)`);
            }
          }

          connectingEndpoints = false;
          
          // Display model response times in the console
          displayModelResponseTimes();
        })
        .catch(error => {
          console.error("Error testing endpoints:", error);
          connectingEndpoints = false;
        });
    }

    // Function to handle file upload
    function handleFileUpload(event) {
      const files = event.target.files;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        processUploadedFile(file);
      }
      // Reset the file input
      event.target.value = null;
    }

    // Document action buttons: applies to the document analysis response
    function addDocumentActionButtons(responseElement, documentName) {
      if (!responseElement || !documentName) return;

      // Check if document exists in uploadedDocuments
      if (!uploadedDocuments[documentName]) {
        console.warn("Cannot add action buttons: Document not found in uploadedDocuments:", documentName);
        return;
      }

      // Create a container for the buttons
      const actionContainer = document.createElement('div');
      actionContainer.className = 'document-action-buttons';

      // Create Apply Suggestions button
      const applySuggestionsBtn = document.createElement('button');
      applySuggestionsBtn.className = 'btn document-action-btn';
      applySuggestionsBtn.innerHTML = '<i class="fas fa-magic"></i> Apply Suggestions';
      applySuggestionsBtn.title = 'Automatically apply the suggested improvements';

      // Create Download Updated button
      const downloadBtn = document.createElement('button');
      downloadBtn.className = 'btn document-action-btn';
      downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download Updated';
      downloadBtn.title = 'Download the document with applied suggestions';
      downloadBtn.disabled = true; // Initially disabled until suggestions are applied

      // Event handler for Apply Suggestions button
      applySuggestionsBtn.addEventListener('click', () => {
        // Extract suggestions from the bot response
        const botResponse = responseElement.textContent;
        const documentContent = uploadedDocuments[documentName].content;

        // Show processing message
        showNotification('Processing document suggestions...', 'info');

        // Implement the suggestions in the document content
        applyDocumentSuggestions(documentName, documentContent, botResponse).then(updatedContent => {
          if (updatedContent) {
            // Store the updated content in uploadedDocuments
            uploadedDocuments[documentName].updatedContent = updatedContent;

            // Preview the updated content
            showUpdatedDocumentPreview(documentName, updatedContent);

            // Enable download button
            downloadBtn.disabled = false;

            showNotification('Suggestions applied successfully!', 'success');
          } else {
            showNotification('Failed to apply suggestions.', 'error');
          }
        });
      });

      // Event handler for Download Updated button
      downloadBtn.addEventListener('click', () => {
        if (uploadedDocuments[documentName].updatedContent) {
          downloadUpdatedDocument(documentName, uploadedDocuments[documentName].updatedContent);
        } else {
          showNotification('No updated content available.', 'error');
        }
      });

      // Add buttons to container
      actionContainer.appendChild(applySuggestionsBtn);
      actionContainer.appendChild(downloadBtn);

      // Append container to the response element
      responseElement.appendChild(document.createElement('br'));
      responseElement.appendChild(actionContainer);
    }

    // Function to apply document suggestions
    async function applyDocumentSuggestions(documentName, originalContent, botResponse) {
      // Create a thinking message to show progress
      appendHtmlMessage("bot", `<span data-thinking="true">Applying suggestions to ${documentName}...</span>`);
      const thinkingMsg = document.querySelector(".message.bot:last-child");

      try {
        // Get document type (text, PDF, etc.)
        const fileType = getFileType(documentName);

        // Extract the "Document Improvement Suggestions" section
        const suggestionsMatch = botResponse.match(/Document Improvement Suggestions[:\s]*([\s\S]*?)(?:\n\n|\n##|\n#|$)/i);

        if (!suggestionsMatch) {
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }
          appendMessage("bot", "I couldn't find any improvement suggestions in the analysis. Please try again or ask for specific improvements.");
          return null;
        }

        const improvementSuggestions = suggestionsMatch[1].trim();

        // For text-based documents, we can directly modify the content
        if (fileType === "txt" || fileType === "other") {
          // For simple text docs, apply changes directly
          let updatedContent = originalContent;

          // Extract each numbered suggestion
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            // Try to identify what to change based on the suggestion
            // This is a simple implementation - in reality you would use more sophisticated NLP
            const changeMatch = suggestion.match(/(replace|change|update|add|remove|delete|improve)\s+["']([^"']+)["']\s+(to|with)\s+["']([^"']+)["']/i);

            if (changeMatch) {
              const [fullMatch, action, oldText, connector, newText] = changeMatch;

              if (action.toLowerCase().includes('replace') ||
                action.toLowerCase().includes('change') ||
                action.toLowerCase().includes('update')) {
                updatedContent = updatedContent.replace(new RegExp(escapeRegExp(oldText), 'g'), newText);
              } else if (action.toLowerCase().includes('add')) {
                // For add, we try to find a logical place to add the content
                // This is simplified - real implementation would be more context-aware
                updatedContent += `\n${newText}`;
              } else if (action.toLowerCase().includes('remove') ||
                action.toLowerCase().includes('delete')) {
                updatedContent = updatedContent.replace(new RegExp(escapeRegExp(oldText), 'g'), '');
              }
            }
          }

          // Remove the thinking message
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          const diffSummary = generateDiffSummary(originalContent, updatedContent);
          appendMessage("bot", `I've applied the suggestions to ${documentName}.\n\n**Changes made:**\n${diffSummary}\n\nYou can now download the updated document using the "Download Updated" button.`);

          return updatedContent;
        } else if (fileType === "pdf" || fileType === "doc" || fileType === "docx") {
          // For PDF/DOC, we return the original text with a note about limitations
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          appendMessage("bot", `I've identified the suggestions for ${documentName}, but direct editing of ${fileType.toUpperCase()} files is limited. I'll generate a text version with the suggested improvements that you can download and reference while updating your original document.`);

          // Prepare a text version with the suggestions implemented
          const textContent = originalContent;
          let updatedContent = `# Improved version of ${documentName}\n\n`;
          updatedContent += `## Original Content:\n${textContent}\n\n`;
          updatedContent += `## Improvement Suggestions:\n${improvementSuggestions}\n\n`;
          updatedContent += `## Suggested Revised Version:\n`;

          // Try to implement each suggestion to create a revised version
          let revisedContent = textContent;
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            updatedContent += `\n- ${suggestion.trim()}`;
          }

          return updatedContent;
        } else if (fileType === "image") {
          // For images with OCR text, return the extracted text with suggestions
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          appendMessage("bot", `I've identified suggestions for the text in this image, but I can only provide a text version with improvements, not modify the original image.`);

          // Create an improved text version
          let updatedContent = `# Improved text from image ${documentName}\n\n`;
          updatedContent += `## Original OCR Content:\n${originalContent}\n\n`;
          updatedContent += `## Improvement Suggestions:\n${improvementSuggestions}\n\n`;
          updatedContent += `## Suggested Revised Version:\n`;

          // Try to implement the suggestions
          let revisedContent = originalContent;
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            updatedContent += `\n- ${suggestion.trim()}`;
          }

          return updatedContent;
        }

        return null;
      } catch (error) {
        console.error("Error applying document suggestions:", error);
        if (thinkingMsg && thinkingMsg.parentNode) {
          thinkingMsg.parentNode.removeChild(thinkingMsg);
        }
        appendMessage("bot", "I encountered an error while applying the suggestions. Please try again or ask for specific improvements.");
        return null;
      }
    }

    // Function to show preview of updated document
    function showUpdatedDocumentPreview(documentName, updatedContent) {
      // Find or create a document preview container
      const documentPreviews = document.getElementById('documentPreviews');
      if (!documentPreviews) return;

      // Create a preview panel
      const previewPanel = document.createElement('div');
      previewPanel.className = 'document-preview-panel';
      previewPanel.innerHTML = `
        <div class="preview-header">
          <div class="preview-title"><i class="fas fa-file-alt"></i> Updated: ${documentName}</div>
          <button class="preview-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="preview-content">
          <textarea readonly>${updatedContent}</textarea>
        </div>
      `;

      // Add close button functionality
      const closeBtn = previewPanel.querySelector('.preview-close-btn');
      closeBtn.addEventListener('click', () => {
        documentPreviews.removeChild(previewPanel);
      });

      // Add to preview area
      documentPreviews.appendChild(previewPanel);

      // Make document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      if (previewSection) {
        previewSection.style.display = 'block';
      }
    }

    // Function to download the updated document
    function downloadUpdatedDocument(documentName, updatedContent) {
      // Create a blob with the updated content
      const blob = new Blob([updatedContent], { type: 'text/plain' });

      // Create a download link
      const downloadLink = document.createElement('a');
      downloadLink.href = URL.createObjectURL(blob);

      // Add "updated" to the filename
      const fileNameParts = documentName.split('.');
      const extension = fileNameParts.pop();
      const baseName = fileNameParts.join('.');
      downloadLink.download = `${baseName}_updated.txt`;

      // Trigger download
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);

      // Clean up
      URL.revokeObjectURL(downloadLink.href);

      showNotification('Document downloaded successfully!', 'success');
    }

    // Helper function to escape special characters for RegExp
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Helper function to generate a summary of changes
    function generateDiffSummary(originalText, updatedText) {
      // Simple diff summary - count additions and removals
      const originalWords = originalText.split(/\s+/).filter(w => w.length > 0);
      const updatedWords = updatedText.split(/\s+/).filter(w => w.length > 0);

      const originalChars = originalText.length;
      const updatedChars = updatedText.length;

      return `- Word count: ${originalWords.length}  ${updatedWords.length} (${updatedWords.length - originalWords.length > 0 ? '+' : ''}${updatedWords.length - originalWords.length})
- Character count: ${originalChars}  ${updatedChars} (${updatedChars - originalChars > 0 ? '+' : ''}${updatedChars - originalChars})`;
    }

    // Function to process uploaded file
    function processUploadedFile(file) {
      // Process document content for analysis
      processDocumentContent(file);

      // Create file preview in the document preview area
      const filePreview = document.getElementById("documentPreviews");
      if (!filePreview) return;

      // Clear welcome message if it exists
      const welcomeMessage = filePreview.querySelector('.empty-preview-message');
      if (welcomeMessage) {
        filePreview.removeChild(welcomeMessage);
      }

      // Make sure the document previews container is visible
      filePreview.style.display = 'block';

      // Create file item element
      const fileItem = document.createElement('div');
      fileItem.classList.add('file-item');
      fileItem.setAttribute('data-filename', file.name);

      // Create file header
      const fileHeader = document.createElement('div');
      fileHeader.className = 'file-header';

      // Create file name container
      const fileNameContainer = document.createElement('div');
      fileNameContainer.className = 'file-name';

      // Create file icon
      const fileIcon = document.createElement('i');
      fileIcon.className = 'fas';

      // Set icon based on file type
      if (file.name.endsWith('.pdf')) {
        fileIcon.classList.add('fa-file-pdf');
      } else if (file.name.endsWith('.txt')) {
        fileIcon.classList.add('fa-file-alt');
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        fileIcon.classList.add('fa-file-word');
      } else if (file.type.startsWith('image/')) {
        fileIcon.classList.add('fa-file-image');
      } else {
        fileIcon.classList.add('fa-file');
      }

      // Create filename span
      const fileName = document.createElement('span');
      fileName.textContent = file.name;

      // Add icon and filename to the name container
      fileNameContainer.appendChild(fileIcon);
      fileNameContainer.appendChild(fileName);

      // Create delete button
      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = '<i class="fas fa-times"></i>';
      closeBtn.classList.add("delete-file");
      closeBtn.setAttribute('aria-label', 'Remove file');

      closeBtn.addEventListener("click", function (e) {
        e.stopPropagation();
        filePreview.removeChild(fileItem);

        // If no more files, show welcome message
        if (filePreview.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          filePreview.appendChild(welcomeText);
        }

        // Remove from uploadedDocuments
        if (uploadedDocuments[file.name]) {
          delete uploadedDocuments[file.name];
        }
      });

      // Add name container and delete button to header
      fileHeader.appendChild(fileNameContainer);
      fileHeader.appendChild(closeBtn);

      // Add header to file item
      fileItem.appendChild(fileHeader);

      // Add file preview for images and PDFs
      const fileType = file.type.split('/')[0];

      if (fileType === 'image' || file.name.endsWith('.pdf')) {
        const reader = new FileReader();
        reader.onload = function () {
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container';

          if (fileType === 'image') {
            const img = document.createElement('img');
            img.src = reader.result;
            img.alt = file.name;
            previewContainer.appendChild(img);
          } else if (file.name.endsWith('.pdf')) {
            previewContainer.classList.add('pdf-preview');
            const obj = document.createElement('object');
            obj.data = reader.result;
            obj.type = 'application/pdf';
            obj.width = '100%';
            obj.height = '200px';
            previewContainer.appendChild(obj);
          }

          fileItem.appendChild(previewContainer);
        };
        reader.readAsDataURL(file);
      }

      filePreview.appendChild(fileItem);

      // Force document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      previewSection.style.display = 'block';
      previewSection.style.visibility = 'visible';
      previewSection.style.opacity = '1';

      // If it's a chat context, add a message about the upload
      if (currentChatId) {
        // Add a file upload message with icon based on file type
        let fileIcon = 'fa-file';
        if (file.name.endsWith('.pdf')) fileIcon = 'fa-file-pdf';
        else if (file.name.endsWith('.txt')) fileIcon = 'fa-file-alt';
        else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) fileIcon = 'fa-file-word';
        else if (file.type.startsWith('image/')) fileIcon = 'fa-file-image';

        const fileMessage = `
          <div class="file-upload">
            <i class="fas ${fileIcon}"></i>
            <span>${file.name}</span>
          </div>
        `;

        appendHtmlMessage("user", fileMessage);

        // Auto-analyze the document after a short delay
        setTimeout(() => {
          autoAnalyzeDocument(file.name);
        }, 1500);
      }
    }

    // Function to display all model response times
    function displayModelResponseTimes() {
      console.log("=== MODEL RESPONSE TIMES ===");
      
      for (const modelKey in modelConfig) {
        console.log(`\n${modelKey.toUpperCase()}:`);
        console.log(`- Model Name: ${modelConfig[modelKey].name}`);
        console.log(`- Overall Response Time: ${modelConfig[modelKey].responseTime || 'Not measured'} ms`);
        
        // Set timeout to 20 seconds for LegalMind
        if (modelKey === 'legalMind') {
          modelConfig[modelKey].timeout = 20000; // 20 seconds for LegalMind
          console.log(`- Timeout Setting: 20000 ms (fixed 20 second timeout for legal processing)`);
        } else {
          // For other models, calculate based on response time
          if (modelConfig[modelKey].responseTime) {
            modelConfig[modelKey].timeout = Math.max(modelConfig[modelKey].responseTime + 3000, 15000);
          }
          console.log(`- Timeout Setting: ${modelConfig[modelKey].timeout || 15000} ms`);
        }
        
        console.log('\nEndpoints:');
        modelConfig[modelKey].endpoints.forEach((endpoint, index) => {
          // Extract endpoint name from URL
          const endpointName = endpoint.includes('/') ? 
            endpoint.split('/').slice(-2).join('/') : 
            endpoint;
          
          // Add an indicator for the currently active endpoint
          const isActive = index === modelConfig[modelKey].currentEndpointIndex ? ' [ACTIVE]' : '';
          
          console.log(`${index+1}. ${endpointName}${isActive}`);
        });
        
        console.log('\nAuth Tokens:');
        modelConfig[modelKey].authTokens.forEach((token, index) => {
          // Mask token for security, showing only first few and last few characters
          const maskedToken = token.substring(0, 5) + '...' + token.substring(token.length - 4);
          
          // Add an indicator for the currently active token
          const isActive = index === modelConfig[modelKey].currentTokenIndex ? ' [ACTIVE]' : '';
          
          console.log(`${index+1}. ${maskedToken}${isActive}`);
        });
      }
      
      console.log("\n=== MODEL TEST RECOMMENDATIONS ===");
      // Recommend the faster model
      let fastestModel = null;
      let fastestTime = Infinity;
      
      for (const modelKey in modelConfig) {
        if (modelConfig[modelKey].responseTime && modelConfig[modelKey].responseTime < fastestTime) {
          fastestModel = modelKey;
          fastestTime = modelConfig[modelKey].responseTime;
        }
      }
      
      if (fastestModel) {
        console.log(`\nFastest model: ${fastestModel.toUpperCase()} (${fastestTime} ms)`);
        
        // For display purposes only - the actual timeouts are set above
        const recommendedTimeout = fastestModel === 'legalMind' ? 
          20000 : Math.max(fastestTime + 3000, 15000);
        console.log(`Recommended timeout: ${recommendedTimeout} ms`);
      } else {
        console.log("\nNo response time measurements available. Please connect to endpoints first.");
      }
    }
    
    // Make this function globally accessible for direct console access
    window.showModelResponseTimes = function() {
      displayModelResponseTimes();
      return "Model response times have been logged to the console. Check the console output for details.";
    };

    // Update the document analysis prompt to specifically request summarization and change suggestions
    function autoAnalyzeDocument(documentName) {
      if (!documentName || !uploadedDocuments[documentName]) {
        console.warn("Cannot analyze document: not found in uploadedDocuments:", documentName);
        return;
      }

      // Create a thinking message
      appendHtmlMessage("bot", `<span data-thinking="true">Analyzing document: ${documentName}...</span>`);
      const thinkingMsg = document.querySelector(".message.bot:last-child");

      // Get document type
      const fileType = getFileType(documentName);

      // Function to check document content and analyze
      function checkAndAnalyze() {
        if (uploadedDocuments[documentName].content) {
          const documentContent = uploadedDocuments[documentName].content;
          const analysisMessage = `Analyze this ${fileType} document: ${documentName}`;

          // Get model endpoint and token
          const currentEndpointInfo = getCurrentEndpointInfo();
          if (!currentEndpointInfo) {
            if (thinkingMsg && thinkingMsg.parentNode) {
              thinkingMsg.parentNode.removeChild(thinkingMsg);
            }
            appendMessage("bot", "I'm sorry, there's an issue with the model configuration. Please try again later.");
            return;
          }

          // Get document context
          const documentContext = getDocumentContext(analysisMessage);

          // Prepare the prompt based on which model is active and file type
          let analysisPrompt;
          const today = new Date();
          const formattedDate = today.toLocaleDateString('en-US', {
            month: 'long',
            day: 'numeric',
            weekday: 'long'
          });

          // Customize prompt based on file type
          let fileTypePrompt = "";
          if (fileType === "pdf" || fileType === "docx" || fileType === "doc") {
            fileTypePrompt = "For this document: Evaluate its structure, identify issues or errors, and suggest specific improvements that could be made.";
          } else if (fileType === "txt") {
            fileTypePrompt = "For this text document: Focus on organization, clarity, and structural improvements. Check for inconsistent terminology and logical flow.";
          } else if (fileType === "image") {
            fileTypePrompt = "For this OCR-extracted text: Note any potential errors in text recognition, evaluate the document structure, and suggest improvements to both content and formatting.";
          }

          // Enhanced prompt for all models to focus on summarization and specific change suggestions
          analysisPrompt =
            "You are a professional document analysis assistant. Respond ONLY with factual information based on the provided content. If you are unsure about something, explicitly say so.\n\n" +
            "IMPORTANT GUIDELINES:\n" +
            "1. Only make statements that are directly supported by the document content\n" +
            "2. If asked about something not in the document, say 'I cannot find information about that in the document'\n" +
            "3. Do not make assumptions or creative interpretations\n" +
            "4. For legal documents, only provide objective analysis of the content\n\n" +
            "Document to analyze:" +
            documentContext +
            "\n\nUser query: " + messageText + "\n\n" +
            "Provide your analysis in this structure:\n" +
            "1. FACTS: List only factual information found in the document\n" +
            "2. ANALYSIS: Objective analysis based solely on the document content\n" +
            "3. SUGGESTIONS: Only if specifically requested and based on clear document issues\n" +
            "Assistant:";

          // Prepare API request parameters
          let requestParams = {
            max_new_tokens: 1500,
            temperature: 0.3,
            top_p: 0.85,
            do_sample: true,
            return_full_text: false,
            repetition_penalty: 1.2
          };

          // Use DeepSeek's recommended parameters if using the DeepSeek model
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek")) {
            requestParams = {
              max_new_tokens: 1024,
              temperature: 0.3,
              top_p: 0.8,
              do_sample: true
            };
          } else if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("mistral")) {
            // Parameters for Mistral API
            requestParams = {
              model: modelConfig[activeModel].modelId,
              messages: [
                {
                  role: "user",
                  content: analysisPrompt
                }
              ],
              temperature: 0.7,
              max_tokens: 1500
            };
          }

          // Get timeout setting from model config or use default
          const timeout = modelConfig[activeModel].timeout || 15000;

          // Create a timeout promise
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error(`API request timed out after ${timeout/1000} seconds`));
            }, timeout);
          });

          // Setup the API request based on the model type
          let apiRequest;
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("mistral")) {
            // Mistral API format
            apiRequest = fetch(modelConfig[activeModel].endpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${modelConfig[activeModel].readToken}`
              },
              body: JSON.stringify(requestParams)
            });
          } else {
            // Hugging Face format
            apiRequest = fetch(currentEndpointInfo.endpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${currentEndpointInfo.token}`
              },
              body: JSON.stringify({
                inputs: analysisPrompt,
                parameters: requestParams
              })
            });
          }

          // Race between the fetch request and the timeout
          Promise.race([apiRequest, timeoutPromise])
            .then(response => {
              if (!response.ok) {
                return response.text().then(text => {
                  throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
                });
              }
              return response.json();
            })
            .then(data => {
              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }

              // Add bot response from the API
              let botResponse = ""; // Empty default

              // Parse the response based on the API format
              if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("mistral")) {
                // Mistral API format
                if (data && data.choices && data.choices.length > 0) {
                  botResponse = data.choices[0].message.content.trim();
                }
              } else {
                // Hugging Face format
                if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                  botResponse = data[0].generated_text.trim();
                } else if (data && data.generated_text) {
                  botResponse = data.generated_text.trim();
                } else if (typeof data === 'string') {
                  botResponse = data.trim();
                } else if (data && data.choices && data.choices.length > 0) {
                  // Handle OpenAI-like format
                  botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
                }
              }

              // Safety check for empty responses
              if (!botResponse) {
                botResponse = "I apologize, but I couldn't analyze the document properly. Please ask me specific questions about it.";
              }

              // Create a bot message with the response and add action buttons
              const responseElement = document.createElement("div");
              responseElement.className = "message bot";
              responseElement.textContent = botResponse;
              
              // Append to chat box
              const chatBox = document.getElementById("chatBox");
              if (chatBox) {
                chatBox.appendChild(responseElement);
              }

              // Add document action buttons to the response
              addDocumentActionButtons(responseElement, documentName);

              // Store in current chat if available
              if (currentChatId && chats[currentChatId]) {
                if (!chats[currentChatId].messages) {
                  chats[currentChatId].messages = [];
                }
                chats[currentChatId].messages.push({
                  type: 'text',
                  sender: 'bot',
                  content: botResponse
                });
              }
            })
            .catch(error => {
              console.error("Error analyzing document:", error);

              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }

              appendMessage("bot", "I had trouble analyzing this document. Please try again or ask me specific questions about it.");
            });
        } else {
          // If document isn't available yet, wait and check again
          setTimeout(checkAndAnalyze, 500);
        }
      }  // Close checkAndAnalyze function

      checkAndAnalyze();
    }  // Close autoAnalyzeDocument function

    // Enhanced function to apply document suggestions
    async function applyDocumentSuggestions(documentName, originalContent, botResponse) {
      // Create a thinking message to show progress
      appendHtmlMessage("bot", `<span data-thinking="true">Applying suggestions to ${documentName}...</span>`);
      const thinkingMsg = document.querySelector(".message.bot:last-child");

      try {
        // Get document type (text, PDF, etc.)
        const fileType = getFileType(documentName);

        // Extract the "Document Improvement Suggestions" section
        const suggestionsMatch = botResponse.match(/Document Improvement Suggestions[:\s]*([\s\S]*?)(?:(\n\n\d\.|\n\n##|\n\nImplementation Plan|\n\n#|$))/i);

        if (!suggestionsMatch) {
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }
          appendMessage("bot", "I couldn't find any improvement suggestions in the analysis. Please try again or ask for specific improvements.");
          return null;
        }

        const improvementSuggestions = suggestionsMatch[1].trim();

        // For text-based documents, we can directly modify the content
        if (fileType === "txt" || fileType === "other") {
          // For simple text docs, apply changes directly
          let updatedContent = originalContent;

          // Extract each numbered suggestion
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            // Look for BEFORE and AFTER patterns in the suggestion
            const beforeAfterMatch = suggestion.match(/BEFORE:\s*["']([^"']+)["']\s*AFTER:\s*["']([^"']+)["']/i) || 
                                    suggestion.match(/BEFORE:\s*(.+?)\s*AFTER:\s*(.+?)(?:\n|$)/i);

            if (beforeAfterMatch) {
              const [fullMatch, beforeText, afterText] = beforeAfterMatch;
              // Replace the before text with the after text
              updatedContent = updatedContent.replace(new RegExp(escapeRegExp(beforeText.trim()), 'g'), afterText.trim());
              continue;
            }

            // Try to identify what to change based on the suggestion patterns
            const changeMatch = suggestion.match(/(replace|change|update|add|remove|delete|improve)\s+["']([^"']+)["']\s+(to|with)\s+["']([^"']+)["']/i);

            if (changeMatch) {
              const [fullMatch, action, oldText, connector, newText] = changeMatch;

              if (action.toLowerCase().includes('replace') ||
                action.toLowerCase().includes('change') ||
                action.toLowerCase().includes('update')) {
                updatedContent = updatedContent.replace(new RegExp(escapeRegExp(oldText), 'g'), newText);
              } else if (action.toLowerCase().includes('add')) {
                // For add, we try to find a logical place to add the content
                // This is simplified - real implementation would be more context-aware
                updatedContent += `\n${newText}`;
              } else if (action.toLowerCase().includes('remove') ||
                action.toLowerCase().includes('delete')) {
                updatedContent = updatedContent.replace(new RegExp(escapeRegExp(oldText), 'g'), '');
              }
            }
          }

          // Remove the thinking message
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          const diffSummary = generateDiffSummary(originalContent, updatedContent);
          
          // Ask the user if they want to keep these changes
          appendHtmlMessage("bot", `
            <div class="document-update-confirmation">
              <h3> Changes Applied to ${documentName}</h3>
              <div class="diff-summary">
                <p><strong>Change Summary:</strong></p>
                <pre>${diffSummary}</pre>
              </div>
              <p>Would you like to keep these changes?</p>
              <div class="confirmation-buttons">
                <button class="confirm-changes-btn yes"> Yes, keep changes</button>
                <button class="confirm-changes-btn no"> No, revert changes</button>
              </div>
            </div>
          `);
          
          // Add event listeners to the confirmation buttons
          const lastBotMessage = document.querySelector(".message.bot:last-child");
          const confirmYesBtn = lastBotMessage.querySelector(".confirm-changes-btn.yes");
          const confirmNoBtn = lastBotMessage.querySelector(".confirm-changes-btn.no");
          
          confirmYesBtn.addEventListener("click", () => {
            showUpdatedDocumentPreview(documentName, updatedContent);
            
            // Enable download button for the document
            const downloadBtn = document.querySelector(`.document-action-buttons button[title*="Download"]`);
            if (downloadBtn) downloadBtn.disabled = false;
            
            // Ask if user wants to download the updated document
            appendHtmlMessage("bot", `
              <div class="document-download-option">
                <p>Would you like me to prepare the updated document for download?</p>
                <div class="download-option-buttons">
                  <button class="download-now-btn"> Download Updated Document</button>
                </div>
              </div>
            `);
            
            // Add event listener to download button
            const downloadNowBtn = document.querySelector(".download-now-btn");
            if (downloadNowBtn) {
              downloadNowBtn.addEventListener("click", () => {
                downloadUpdatedDocument(documentName, updatedContent);
              });
            }
          });
          
          confirmNoBtn.addEventListener("click", () => {
            appendMessage("bot", "I've reverted the changes. The original document remains unchanged. Let me know if you'd like different improvements.");
          });

          return updatedContent;
        } else if (fileType === "pdf" || fileType === "doc" || fileType === "docx") {
          // For PDF/DOC, we return the original text with a note about limitations
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          appendMessage("bot", `I've identified the suggestions for ${documentName}, but direct editing of ${fileType.toUpperCase()} files is limited. I'll generate a text version with the suggested improvements that you can download and reference while updating your original document.`);

          // Prepare a text version with the suggestions implemented
          const textContent = originalContent;
          let updatedContent = `# Improved version of ${documentName}\n\n`;
          updatedContent += `## Original Content:\n${textContent}\n\n`;
          updatedContent += `## Improvement Suggestions:\n${improvementSuggestions}\n\n`;
          updatedContent += `## Suggested Revised Version:\n`;

          // Try to implement each suggestion to create a revised version
          let revisedContent = textContent;
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            updatedContent += `\n- ${suggestion.trim()}`;
          }

          return updatedContent;
        } else if (fileType === "image") {
          // For images with OCR text, return the extracted text with suggestions
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          appendMessage("bot", `I've identified suggestions for the text in this image, but I can only provide a text version with improvements, not modify the original image.`);

          // Create an improved text version
          let updatedContent = `# Improved text from image ${documentName}\n\n`;
          updatedContent += `## Original OCR Content:\n${originalContent}\n\n`;
          updatedContent += `## Improvement Suggestions:\n${improvementSuggestions}\n\n`;
          updatedContent += `## Suggested Revised Version:\n`;

          // Try to implement the suggestions
          let revisedContent = originalContent;
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            updatedContent += `\n- ${suggestion.trim()}`;
          }

          return updatedContent;
        }
        return null;
      } catch (error) {
        console.error("Error applying document suggestions:", error);
        if (thinkingMsg && thinkingMsg.parentNode) {
          thinkingMsg.parentNode.removeChild(thinkingMsg);
        }
        appendMessage("bot", "I encountered an error while applying the suggestions. Please try again or ask for specific improvements.");
        return null;
      }
    }

    // Enhanced function to download updated document with better formatting
    function downloadUpdatedDocument(documentName, updatedContent) {
      // Determine the content type based on format and extension
      let contentType = 'text/plain';
      let fileExtension = 'txt';
      
      // Create a formatted version based on document type
      const fileNameParts = documentName.split('.');
      const originalExtension = fileNameParts.pop().toLowerCase();
      const baseName = fileNameParts.join('.');
      
      if (updatedContent.startsWith('# ')) {
        // Looks like Markdown content
        contentType = 'text/markdown';
        fileExtension = 'md';
      }
      
      // Create a blob with the updated content
      const blob = new Blob([updatedContent], { type: contentType });

      // Create a download link
      const downloadLink = document.createElement('a');
      downloadLink.href = URL.createObjectURL(blob);
      downloadLink.download = `${baseName}_updated.${fileExtension}`;

      // Trigger download
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);

      // Clean up
      URL.revokeObjectURL(downloadLink.href);

      showNotification('Document downloaded successfully!', 'success');
      
      // Add confirmation message in chat
      appendHtmlMessage("bot", `
        <div class="download-confirmation">
          <p> I've prepared the updated document for you. The file has been downloaded as <strong>${baseName}_updated.${fileExtension}</strong>.</p>
          <p>Is there anything else you'd like me to help you with regarding this document?</p>
        </div>
      `);
    }

    // Enhanced UI for document action buttons
    function addDocumentActionButtons(responseElement, documentName) {
      if (!responseElement || !documentName) return;

      // Check if document exists in uploadedDocuments
      if (!uploadedDocuments[documentName]) {
        console.warn("Cannot add action buttons: Document not found in uploadedDocuments:", documentName);
        return;
      }

      // Create a container for the buttons with improved styling
      const actionContainer = document.createElement('div');
      actionContainer.className = 'document-action-buttons';

      // Create Apply Suggestions button with icon and better labeling
      const applySuggestionsBtn = document.createElement('button');
      applySuggestionsBtn.className = 'btn document-action-btn suggest-btn';
      applySuggestionsBtn.innerHTML = '<i class="fas fa-magic"></i> Apply Suggestions';
      applySuggestionsBtn.title = 'Automatically apply the suggested improvements';

      // Create Download Updated button with icon
      const downloadBtn = document.createElement('button');
      downloadBtn.className = 'btn document-action-btn download-btn';
      downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download Updated';
      downloadBtn.title = 'Download the document with applied suggestions';
      downloadBtn.disabled = true; // Initially disabled until suggestions are applied

      // Event handler for Apply Suggestions button
      applySuggestionsBtn.addEventListener('click', () => {
        // Extract suggestions from the bot response
        const botResponse = responseElement.textContent;
        const documentContent = uploadedDocuments[documentName].content;

        // Show processing message
        showNotification('Processing document suggestions...', 'info');

        // Implement the suggestions in the document content
        applyDocumentSuggestions(documentName, documentContent, botResponse).then(updatedContent => {
          if (updatedContent) {
            // Store the updated content in uploadedDocuments
            uploadedDocuments[documentName].updatedContent = updatedContent;
          } else {
            showNotification('Failed to apply suggestions.', 'error');
          }
        });
      });

      // Event handler for Download Updated button
      downloadBtn.addEventListener('click', () => {
        if (uploadedDocuments[documentName].updatedContent) {
          downloadUpdatedDocument(documentName, uploadedDocuments[documentName].updatedContent);
        } else {
          showNotification('No updated content available.', 'error');
        }
      });

      // Add buttons to container
      actionContainer.appendChild(applySuggestionsBtn);
      actionContainer.appendChild(downloadBtn);

      // Append container to the response element
      responseElement.appendChild(document.createElement('br'));
      responseElement.appendChild(actionContainer);
      
      // Add CSS for the new buttons
      addDocumentActionStyles();
    }

    // Add CSS styles for document action buttons
    function addDocumentActionStyles() {
      // Check if styles already exist
      if (document.getElementById('document-action-styles')) return;
      
      const styleElement = document.createElement('style');
      styleElement.id = 'document-action-styles';
      styleElement.textContent = `
        .document-action-buttons {
          display: flex;
          gap: 10px;
          margin-top: 15px;
          padding: 10px;
          border-top: 1px solid #e0e0e0;
        }
        
        .document-action-btn {
          padding: 8px 15px;
          border-radius: 20px;
          border: none;
          display: flex;
          align-items: center;
          gap: 8px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .document-action-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
        
        .document-action-btn.suggest-btn {
          background-color: #4a6cf7;
          color: white;
        }
        
        .document-action-btn.download-btn {
          background-color: #28a745;
          color: white;
        }
        
        .document-action-btn:hover:not(:disabled) {
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .document-update-confirmation {
          background-color: #f8f9fa;
          border-radius: 10px;
          padding: 15px;
          margin: 10px 0;
          border-left: 4px solid #4a6cf7;
        }
        
        .diff-summary {
          background-color: #f1f1f1;
          border-radius: 5px;
          padding: 10px;
          margin: 10px 0;
          max-height: 200px;
          overflow-y: auto;
        }
        
        .confirmation-buttons, .download-option-buttons {
          display: flex;
          gap: 10px;
          margin-top: 15px;
        }
        
        .confirm-changes-btn, .download-now-btn {
          padding: 8px 15px;
          border-radius: 20px;
          border: none;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s ease;
        }
        
        .confirm-changes-btn.yes, .download-now-btn {
          background-color: #28a745;
          color: white;
        }
        
        .confirm-changes-btn.no {
          background-color: #dc3545;
          color: white;
        }
        
        .download-confirmation {
          background-color: #d4edda;
          border-radius: 10px;
          padding: 15px;
          margin: 10px 0;
          border-left: 4px solid #28a745;
        }
      `;
      
      document.head.appendChild(styleElement);
    }

    // Add validation function for model responses
    function validateModelResponse(response, documentContent) {
      // Check if response is too generic
      const genericPhrases = [
        "I'd be happy to help",
        "I can assist you",
        "Let me analyze",
        "I understand",
        "Based on my analysis"
      ];
      
      const hasGenericStart = genericPhrases.some(phrase => 
        response.toLowerCase().startsWith(phrase.toLowerCase())
      );
      
      if (hasGenericStart) {
        return {
          isValid: false,
          message: "Response appears too generic. Requesting more specific analysis..."
        };
      }
      
      // Check if response follows required structure
      const hasRequiredSections = 
        response.includes("FACTS:") &&
        response.includes("ANALYSIS:");
      
      if (!hasRequiredSections) {
        return {
          isValid: false,
          message: "Response missing required sections. Retrying with structured format..."
        };
      }
      
      // Check for potential hallucination by comparing with document content
      const facts = response.split("FACTS:")[1]?.split("ANALYSIS:")[0] || "";
      const factStatements = facts.split("\n").filter(line => line.trim().length > 0);
      
      let potentialHallucination = false;
      for (const fact of factStatements) {
        // If a fact is stated but cannot be found in document content
        if (fact.length > 20 && !documentContent.includes(fact.substring(0, 20))) {
          potentialHallucination = true;
          break;
        }
      }
      
      if (potentialHallucination) {
        return {
          isValid: false,
          message: "Detected potential hallucination in response. Requesting verification..."
        };
      }
      
      return { isValid: true };
    }

    // Update the API response handling to use validation
    function handleModelResponse(data, documentContent, currentEndpointInfo, requestParams) {
      let botResponse = "";
      
      // Parse the response based on the API format
      if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
        botResponse = data[0].generated_text.trim();
      } else if (data && data.generated_text) {
        botResponse = data.generated_text.trim();
      } else if (typeof data === 'string') {
        botResponse = data.trim();
      } else if (data && data.choices && data.choices.length > 0) {
        botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
      }

      // Validate the response
      const validation = validateModelResponse(botResponse, documentContent);
      if (!validation.isValid) {
        console.log("Response validation failed:", validation.message);
        // Retry the request with more strict parameters
        const newParams = {
          ...requestParams,
          temperature: Math.max(0.1, requestParams.temperature - 0.1),
          top_p: Math.max(0.7, requestParams.top_p - 0.1)
        };
        
        // Show validation message to user
        appendMessage("bot", validation.message);
        
        // Retry the request
        return fetch(currentEndpointInfo.endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${currentEndpointInfo.token}`
          },
          body: JSON.stringify({
            inputs: analysisPrompt,
            parameters: newParams
          })
        })
        .then(response => response.json())
        .then(retryData => {
          let retryResponse = "";
          if (retryData && Array.isArray(retryData) && retryData.length > 0) {
            retryResponse = retryData[0].generated_text.trim();
          } else if (retryData && retryData.generated_text) {
            retryResponse = retryData.generated_text.trim();
          }
          appendMessage("bot", retryResponse);
          return retryResponse;
        });
      }
      
      // Continue with valid response handling
      appendMessage("bot", botResponse);
      return botResponse;
    }

    // Add initialization code to wake up models on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize components and the rest of the UI
      initUI();
      
      // Set Mistral as default model for actual use
      selectedModel = "mistral";
      activeModel = "mistral";
      
      // But show LegalMind in UI
      const currentModelDisplay = document.getElementById("currentModelDisplay");
      if (currentModelDisplay) {
        currentModelDisplay.textContent = modelConfig.legalMind.name;
      }
      
      // Add to the existing chatMessages div
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        // Add a system message indicating model initialization
        const initMessage = document.createElement('div');
        initMessage.className = 'system-message';
        initMessage.innerHTML = '<i class="fas fa-info-circle"></i> Initializing LegalMind, please wait...';
        chatMessages.appendChild(initMessage);
      }
      
      // Wake up models on page load (Mistral in background, show LegalMind in UI)
      wakeUpModels();
    });

    // Function to wake up models on start
    function wakeUpModels() {
      console.log("Initializing models...");
      
      // First wake up Mistral as primary model
      wakeUpModel('mistral')
        .then(() => {
          console.log("Mistral model ready");
          // Update the init message
          updateSystemMessage("Mistral model ready. Now initializing DeepSeek math model...");
          
          // Then wake up DeepSeek for math operations
          return wakeUpModel('deepseek');
        })
        .then(() => {
          console.log("DeepSeek math model ready");
          updateSystemMessage("All models ready. You can start chatting!");
          
          // Both models are ready
          modelConfig.mistral.isAwake = true;
          modelConfig.deepseek.isAwake = true;
        })
        .catch(error => {
          console.error("Error initializing models:", error);
          updateSystemMessage("Warning: Some models failed to initialize. Falling back to Mistral only.");
          
          // Make sure we at least have Mistral ready
          wakeUpModel('mistral').catch(() => {
            updateSystemMessage("Error: Unable to connect to any models. Please try refreshing the page.");
          });
        });
    }

    // Function to update system message
    function updateSystemMessage(message) {
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        const systemMessages = chatMessages.querySelectorAll('.system-message');
        if (systemMessages.length > 0) {
          // Update the last system message
          systemMessages[systemMessages.length - 1].innerHTML = '<i class="fas fa-info-circle"></i> ' + message;
        } else {
          // Create a new system message
          const systemMessage = document.createElement('div');
          systemMessage.className = 'system-message';
          systemMessage.innerHTML = '<i class="fas fa-info-circle"></i> ' + message;
          chatMessages.appendChild(systemMessage);
        }
      }
    }

    // Function to wake up a specific model
    function wakeUpModel(modelName) {
      return new Promise((resolve, reject) => {
        if (!modelConfig[modelName]) {
          console.error(`Model ${modelName} not found in configuration`);
          reject(new Error(`Model ${modelName} not found in configuration`));
          return;
        }
        
        const endpointUrl = modelConfig[modelName].endpoints[modelConfig[modelName].currentEndpointIndex];
        const token = modelConfig[modelName].authTokens[modelConfig[modelName].currentTokenIndex];
        
        if (!endpointUrl || !token) {
          console.error(`No valid endpoint or token found for ${modelName}`);
          reject(new Error(`No valid endpoint or token found for ${modelName}`));
          return;
        }
        
        // Send a minimal request to wake up the model
        fetch(endpointUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({
            inputs: "Hello",
            parameters: {
              max_new_tokens: 5,
              temperature: 0.1,
              return_full_text: false
            }
          })
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to wake up ${modelName} model: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          console.log(`${modelName} model wake-up response:`, data);
          modelConfig[modelName].isAwake = true;
          resolve(data);
        })
        .catch(error => {
          console.error(`Error waking up ${modelName} model:`, error);
          reject(error);
        });
      });
    }

    // Remove the "Test API" feature from model settings
    function displayModelSettings() {
      const modelSettingsDiv = document.getElementById('modelSettings');
      if (!modelSettingsDiv) return;
      
      // Clear existing content
      modelSettingsDiv.innerHTML = '';
      
      // Function to create settings for each model
      const createModelSettings = (modelKey, config) => {
        const modelSection = document.createElement('div');
        modelSection.className = 'model-settings-section';
        
        // Model title
        const modelTitle = document.createElement('h3');
        modelTitle.textContent = config.name;
        modelSection.appendChild(modelTitle);
        
        // Endpoints - only allow viewing
        const endpointSection = document.createElement('div');
        endpointSection.className = 'endpoints-section';
        
        const endpointLabel = document.createElement('label');
        endpointLabel.textContent = 'Endpoint';
        endpointSection.appendChild(endpointLabel);
        
        const endpointValue = document.createElement('div');
        endpointValue.className = 'endpoint-value';
        endpointValue.textContent = config.endpoints[config.currentEndpointIndex] || 'Not configured';
        endpointSection.appendChild(endpointValue);
        
        modelSection.appendChild(endpointSection);
        
        // Remove test connection button (as requested)
        
        // Add section to settings
        modelSettingsDiv.appendChild(modelSection);
      };
      
      // Create settings for each model
      for (const modelKey in modelConfig) {
        createModelSettings(modelKey, modelConfig[modelKey]);
      }
    }

    // Update model response handling with DeepSeek fallback functionality
    function sendMessageToAPI(messageText, modelKey = activeModel) {
      // Get current endpoint info
      let currentEndpointInfo = getCurrentEndpointInfo(modelKey);
      
      // Check if we have a proper configuration
      if (!currentEndpointInfo || !currentEndpointInfo.endpoint) {
        appendMessage("bot", "Sorry, I'm having trouble connecting to the language model service. Please try again later.");
        console.error(`Cannot connect to model ${modelKey}: Missing endpoint or token configuration`);
        return;
      }
      
      // Always show thinking indicator with LegalMind name
      appendHtmlMessage("bot", `<span data-thinking="true">LegalMind is thinking about your question...</span>`);
      const thinkingMsg = document.querySelector(".message.bot:last-child");
      
      // Handle mathematical content - use DeepSeek by default if available
      const hasMathContent = /(\d+[\+\-\*\/]\d+|equation|solve|calculate|compute|math problem|derivative|integral|trigonometric|logarithm|exponent|\$\$.+\$\$|\$.+\$)/i.test(messageText);
      
      if (hasMathContent && modelConfig.deepseek && modelConfig.deepseek.isAwake) {
        console.log("Detected math content, switching to DeepSeek Math model in background");
        modelKey = "deepseek";
        currentEndpointInfo = getCurrentEndpointInfo("deepseek");
      }

      // Prepare headers with authentication
      const headers = {
        "Content-Type": "application/json"
      };
      
      if (currentEndpointInfo.token) {
        headers["Authorization"] = `Bearer ${currentEndpointInfo.token}`;
      }
      
      // Prepare API request parameters
      let requestParams = {
        max_new_tokens: 1500,
        temperature: 0.3,
        top_p: 0.85,
        do_sample: true,
        return_full_text: false,
        repetition_penalty: 1.2
      };
      
      // Use even more conservative parameters for legal document analysis
      if (isLegalDocument) {
        requestParams.temperature = 0.2;
        requestParams.top_p = 0.8;
      }
      
      // Send the API request
      fetch(currentEndpointInfo.endpoint, {
        method: "POST",
        headers: headers,
        body: JSON.stringify({
          inputs: "User: " + messageText + "\nAssistant:",
          parameters: requestParams
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        // Remove thinking message
        if (thinkingMsg && thinkingMsg.parentNode) {
          thinkingMsg.parentNode.removeChild(thinkingMsg);
        }
        
        // Process response
        let botResponse = "";
        if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
          botResponse = data[0].generated_text.trim();
        } else if (data && data.generated_text) {
          botResponse = data.generated_text.trim();
        } else if (typeof data === 'string') {
          botResponse = data.trim();
        } else if (data && data.choices && data.choices.length > 0) {
          botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
        }
        
        // Add bot response to chat
        appendMessage("bot", botResponse);
      })
      .catch(error => {
        console.error("Error in API request:", error);
        
        // Try fallback to another model when current one fails
        if (modelKey === "deepseek") {
          // DeepSeek failed, try Mistral
          if (thinkingMsg) {
            // Keep showing LegalMind name but switch model in background
            thinkingMsg.innerHTML = "<span data-thinking='true'>LegalMind is thinking...</span>";
          }
          sendMessageToAPI(messageText, "mistral");
        } 
        else if (modelKey === "mistral") {
          // Mistral failed, try LegalMind
          if (thinkingMsg) {
            thinkingMsg.innerHTML = "<span data-thinking='true'>LegalMind is thinking...</span>";
          }
          sendMessageToAPI(messageText, "legalMind");
        }
        else {
          // All models failed
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }
          appendMessage("bot", "I encountered an error processing your request. Please try again with a different question.");
        }
      });
    }

  </script>
</body>

</html>