<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="LegalMind - AI-powered legal document assistant">
  <title>LegalMind Dashboard</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Add PDF.js library for PDF processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <!-- Add Tesseract.js for OCR (image text recognition) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.3/dist/tesseract.min.js"></script>
  
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  
  <!-- Initialize Firebase -->
  <script>
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyB9TKLmKIVO7-YWKv1iORqnax0sru249sY",
      authDomain: "legalmind-users.firebaseapp.com",
      projectId: "legalmind-users",
      storageBucket: "legalmind-users.firebaseapp.com",
      messagingSenderId: "321034025311",
      appId: "1:321034025311:web:d8a01ac0c02d5b152b1eea"
    };
    
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    
    // Set persistence to LOCAL for better auth state persistence
    firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
      .then(() => {
        console.log("Firebase persistence set to LOCAL");
      })
      .catch((error) => {
        console.error("Error setting persistence:", error);
      });
  </script>
  
  <!-- OCR Styles -->
  <style>
    .file-preview-container.ocr-preview {
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
      background-color: var(--light-bg);
      border-radius: 5px;
      margin-top: 10px;
    }
    
    .file-preview-container.ocr-preview textarea {
      width: 100%;
      height: 150px;
      resize: none;
      font-family: monospace;
      font-size: 12px;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--main-bg);
      color: var(--text-color);
    }
    
    .dark-mode .file-preview-container.ocr-preview {
      background-color: var(--sidebar-bg);
    }
    
    .dark-mode .file-preview-container.ocr-preview textarea {
      background-color: var(--main-bg);
      border-color: var(--dark-border-color);
    }
    
    /* Scrollbar for OCR Preview */
    .file-preview-container.ocr-preview::-webkit-scrollbar {
      width: 8px;
    }
    
    .file-preview-container.ocr-preview::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
    }
    
    .file-preview-container.ocr-preview::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 4px;
    }
    
    .file-preview-container.ocr-preview::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-hover);
    }
    
    /* Updated animated thinking indicator styles */
    .thinking-container {
      display: flex;
      align-items: center;
      gap: 5px;
      color: var(--text-color);
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .thinking-dots {
      display: inline-flex;
      align-items: center;
      height: 20px;
    }
    
    .thinking-dot {
      width: 4px;
      height: 4px;
      margin: 0 2px;
      background-color: currentColor;
      border-radius: 50%;
      display: inline-block;
      animation: thinkingDot 1.4s infinite ease-in-out both;
    }
    
    .thinking-dot:nth-child(1) {
      animation-delay: -0.32s;
    }
    
    .thinking-dot:nth-child(2) {
      animation-delay: -0.16s;
    }
    
    @keyframes thinkingDot {
      0%,
      80%,
      100% {
        transform: scale(0);
      }
      40% {
        transform: scale(1);
      }
    }
    
    /* Additional thinking animation details */
    .thinking-brain {
      display: inline-block;
      animation: pulse 1.5s infinite ease-in-out;
      margin-right: 5px;
      color: var(--primary-color);
    }
    
    @keyframes pulse {
      0% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      50% {
        opacity: 1;
        transform: scale(1.1);
      }
      100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
    }
    
    /* Hidden text that appears during thinking */
    .thinking-context {
      font-size: 0.85rem;
      color: var(--text-color);
      opacity: 0.7;
      margin-top: 5px;
      font-style: italic;
      display: block;
      animation: fadeInOut 8s infinite ease-in-out;
    }
    
    @keyframes fadeInOut {
      0%,
      100% {
        opacity: 0.3;
      }
      50% {
        opacity: 0.7;
      }
    }
    
    /* Animated thinking indicator styles */
    @keyframes ellipsis {
      0% {
        content: '.';
      }
      33% {
        content: '..';
      }
      66% {
        content: '...';
      }
      100% {
        content: '';
      }
    }
    
    .message.bot:last-child:has(span[data-thinking="true"]) {
      position: relative;
    }
    
    .message.bot:last-child:has(span[data-thinking="true"])::after {
      content: '';
      position: absolute;
      display: inline-block;
      animation: ellipsis 1.5s infinite steps(4);
      width: 1.5em;
      overflow: hidden;
      vertical-align: bottom;
      margin-left: 0.2em;
    }
  </style>
  <style>
    /* CSS Variables for theming */
    :root {
      --primary-color: #007bff;
      --primary-hover: #0056b3;
      --success-color: #28a745;
      --success-hover: #218838;
      --danger-color: #dc3545;
      --light-bg: #f8f9fa;
      --dark-bg: #121212;
      --light-surface: #ffffff;
      --dark-surface: #1e1e1e;
      --light-text: #212529;
      --dark-text: #f8f9fa;
      --light-border: #dee2e6;
      --dark-border: #444;
      --box-shadow: 0 5px 15px rgba(0,0,0,0.08);
      --dark-box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      --transition: all 0.3s ease;
      --border-radius-sm: 8px;
      --border-radius-md: 12px;
      --border-radius-lg: 16px;
      --border-radius-xl: 24px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
    }

    /* Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: var(--light-bg);
      color: var(--light-text);
      transition: var(--transition);
      overflow-x: hidden;
    }
    
    body.dark-mode {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }
    
    .dashboard {
      display: flex;
      width: 100%;
      height: 100vh;
      border-radius: var(--border-radius-lg);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      transition: var(--transition);
    }
    
    body.dark-mode .dashboard {
      box-shadow: var(--dark-box-shadow);
    }
    
    /* Left Sidebar with improved padding */
    .sidebar {
      position: relative;
      display: flex;
      flex-direction: column;
      width: 300px;
      height: 100%;
      background-color: var(--bg-color-surface);
      overflow-y: auto;
      transition: all 0.3s ease;
      padding: 15px 12px 0;
    }
    
    body.dark-mode .sidebar {
      background: var(--dark-surface);
      border-right: 1px solid var(--dark-border);
    }
    
    .chat-header {
      margin-bottom: var(--spacing-lg);
      padding-left: 5px;
      display: flex;
      align-items: center;
    }
    
    .chat-header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin: 0;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    
    .new-chat {
      width: 100%;
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
      cursor: pointer;
      border: none;
      border-radius: var(--border-radius-md);
      background: var(--primary-color);
      color: white;
      transition: var(--transition);
      font-size: 0.95rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }
    
    .new-chat:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
    }
    
    .new-chat i {
      margin-right: var(--spacing-xs);
    }
    
    .chat-list {
      padding: 0;
      overflow-y: auto;
      margin-bottom: var(--spacing-lg);
      flex-grow: 1;
    }
    
    .chat-list li {
      list-style: none;
      padding: var(--spacing-md);
      margin: var(--spacing-xs) 0;
      background-color: var(--light-bg);
      border-radius: var(--border-radius-md);
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition);
      cursor: pointer;
      font-weight: 500;
    }
    
    .chat-list li:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }
    
    .chat-list li.active {
      background-color: rgba(0, 123, 255, 0.2);
      border-left: 3px solid var(--primary-color);
    }
    
    body.dark-mode .chat-list li {
      background: rgba(255, 255, 255, 0.05);
    }
    
    body.dark-mode .chat-list li:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    body.dark-mode .chat-list li.active {
      background: rgba(0, 123, 255, 0.3);
    }
    
    .chat-list li .delete-chat {
      cursor: pointer;
      background: none;
      border: none;
      font-size: 0.9rem;
      color: var(--danger-color);
      opacity: 0.7;
      transition: var(--transition);
    }
    
    .chat-list li .delete-chat:hover {
      opacity: 1;
    }
    
    /* Document Preview section with fixed styling */
    .documents-preview {
      position: relative;
      display: flex;
      flex-direction: column;
      margin: 15px 10px;
      background: var(--light-surface);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--light-border);
      padding: var(--spacing-md);
      box-shadow: var(--box-shadow);
      z-index: 5;
      max-height: none;
    }
    
    body.dark-mode .documents-preview {
      background: var(--dark-surface);
      border-color: var(--dark-border);
      box-shadow: var(--dark-box-shadow);
    }
    
    .documents-preview h3 {
      margin-bottom: var(--spacing-md);
      font-size: 1rem;
      font-weight: 600;
      color: var(--light-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }
    
    body.dark-mode .documents-preview h3 {
      color: var(--dark-text);
    }
    
    #documentPreviews {
      flex: 1;
      min-height: 50px;
      max-height: 250px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 5px;
    }
    
    .file-item {
      display: flex;
      flex-direction: column;
      background: var(--light-surface);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--light-border);
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: var(--transition);
      overflow: hidden;
      margin-bottom: var(--spacing-md);
    }
    
    .file-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
    }
    
    .file-name-container {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .file-name-container i {
      color: #555;
    }
    
    body.dark-mode .file-name-container i {
      color: #ddd;
    }
    
    .file-name-container span {
      font-weight: 500;
      font-size: 0.9rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .file-preview-container {
      padding: 10px;
      max-height: 200px;
      overflow: hidden;
    }
    
    .file-preview-container img {
      max-width: 100%;
      max-height: 180px;
      object-fit: contain;
      display: block;
      margin: 0 auto;
    }
    
    .delete-file {
      cursor: pointer;
      background: none;
      border: none;
      font-size: 0.85rem;
      color: var(--danger-color);
      opacity: 0.7;
      transition: var(--transition);
    }
    
    .delete-file:hover {
      opacity: 1;
    }
    
    /* PDF specific styling to match screenshot */
    .pdf-icon {
      color: #e74c3c;
    }
    
    .pdf-preview {
      height: 200px;
      overflow: hidden;
    }
    
    body.dark-mode .pdf-preview {
      background: #2a2a2a;
    }
    
    /* Chat Section */
    .chat-section {
      flex: 1;
      padding: var(--spacing-lg);
      display: flex;
      flex-direction: column;
      background-color: var(--light-surface);
      transition: var(--transition);
      position: relative;
      height: 100vh;
      overflow: hidden;
    }
    
    body.dark-mode .chat-section {
      background-color: var(--dark-surface);
    }
    
    /* Navigation Bar */
    .chat-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--light-bg);
      padding: var(--spacing-md) var(--spacing-lg);
      box-shadow: var(--box-shadow);
      margin-bottom: var(--spacing-md);
      border-radius: var(--border-radius-md);
      transition: var(--transition);
      position: relative;
      z-index: 10;
    }
    
    body.dark-mode .chat-nav {
      background-color: rgba(255, 255, 255, 0.05);
      box-shadow: var(--dark-box-shadow);
    }
    
    /* Nav Left: Menu Toggle + LegalMind.Space */
    .nav-left {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }
    
    .menu-toggle {
      display: none;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    
    .menu-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    
    body.dark-mode .menu-toggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    body.dark-mode .menu-toggle {
      color: var(--dark-text);
    }
    
    .nav-brand {
      font-weight: 700;
      font-size: 1.2rem;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    
    /* Nav Right: Dropdowns, Contact Us, and Profile */
    .nav-right {
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
    }
    
    .nav-links {
      display: flex;
      gap: var(--spacing-xl);
      font-weight: 500;
      align-items: center;
    }
    
    .nav-links a {
      text-decoration: none;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition);
    }
    
    .nav-links a:hover {
      color: var(--primary-color);
    }
    
    body.dark-mode .nav-links a {
      color: var(--dark-text);
    }
    
    /* Dropdown styling */
    .dropdown {
      position: relative;
      display: inline-block;
    }
    
    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background-color: var(--light-surface);
      min-width: 180px;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius-md);
      z-index: 1;
      overflow: hidden;
      transition: var(--transition);
    }
    
    body.dark-mode .dropdown-content {
      background-color: var(--dark-surface);
      box-shadow: var(--dark-box-shadow);
    }
    
    .dropdown-content a {
      color: var(--light-text);
      padding: var(--spacing-md);
      text-decoration: none;
      display: block;
      transition: var(--transition);
    }
    
    body.dark-mode .dropdown-content a {
      color: var(--dark-text);
    }
    
    .dropdown-content a:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }
    
    body.dark-mode .dropdown-content a:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }
    
    /* Nav Profile */
    .nav-profile {
      position: relative;
    }
    
    .nav-profile img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--light-border);
      object-fit: cover;
      transition: var(--transition);
    }
    
    body.dark-mode .nav-profile img {
      border-color: var(--dark-border);
    }
    
    .nav-profile img:hover {
      transform: scale(1.05);
      border-color: var(--primary-color);
    }
    
    /* Profile Menu - Upgraded UI */
    .profile-menu {
      display: none;
      flex-direction: column;
      position: absolute;
      right: 0;
      top: 50px;
      background: var(--light-surface);
      padding: var(--spacing-lg);
      border-radius: var(--border-radius-md);
      box-shadow: var(--box-shadow);
      width: 280px;
      transition: var(--transition);
      z-index: 99;
    }
    
    body.dark-mode .profile-menu {
      background: var(--dark-surface);
      box-shadow: var(--dark-box-shadow);
    }
    
    .profile-menu.active {
      display: flex;
    }
    
    .profile-menu-header {
      display: flex;
      flex-direction: column;
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
    }
    
    body.dark-mode .profile-menu-header {
      border-color: var(--dark-border);
    }
    
    .profile-menu-header .user-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 4px;
    }
    
    .profile-menu-header .user-plan {
      color: #6c757d;
      font-size: 0.9rem;
    }
    
    body.dark-mode .profile-menu-header .user-plan {
      color: #adb5bd;
    }
    
    .profile-menu-actions {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }
    
    .profile-menu-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-md);
      border-radius: var(--border-radius-md);
      border: none;
      background: var(--light-bg);
      color: var(--light-text);
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
    }
    
    body.dark-mode .profile-menu-btn {
      background: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
    }
    
    .profile-menu-btn:hover {
      background: rgba(0, 123, 255, 0.1);
      transform: translateY(-2px);
    }
    
    .profile-menu-btn.logout {
      background-color: rgba(220, 53, 69, 0.1);
      color: var(--danger-color);
    }
    
    .profile-menu-btn.logout:hover {
      background-color: var(--danger-color);
      color: white;
    }
    
    /* Settings Panel */
    .settings-panel {
      display: none;
      flex-direction: column;
      gap: var(--spacing-md);
    }
    
    .settings-panel.active {
      display: flex;
    }
    
    .settings-section {
      background: var(--light-bg);
      border-radius: var(--border-radius-md);
      padding: var(--spacing-md);
      border: 1px solid var(--light-border);
    }
    
    body.dark-mode .settings-section {
      background: rgba(255, 255, 255, 0.05);
      border-color: var(--dark-border);
    }
    
    .settings-section-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-sm);
      font-weight: 500;
    }
    
    .back-to-menu {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-md);
      color: var(--primary-color);
      background: none;
      border: none;
      padding: 0;
      font-size: 0.9rem;
      cursor: pointer;
    }
    
    .back-to-menu:hover {
      text-decoration: underline;
    }
    
    /* Dark mode toggle enhanced */
    .switch {
      display: flex;
      align-items: center;
      margin-top: var(--spacing-xs);
      cursor: pointer;
    }
    
    .switch input {
      appearance: none;
      width: 44px;
      height: 22px;
      background: #ccc;
      border-radius: 11px;
      position: relative;
      transition: var(--transition);
      cursor: pointer;
      margin-right: var(--spacing-md);
    }
    
    .switch input:checked {
      background: var(--primary-color);
    }
    
    .switch input::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      transition: var(--transition);
    }
    
    .switch input:checked::before {
      transform: translateX(22px);
    }
    
    /* File upload */
    .profile-menu input[type="file"] {
      margin-top: var(--spacing-md);
      display: block;
      width: 100%;
      border-radius: var(--border-radius-md);
      padding: var(--spacing-sm);
      border: 1px solid var(--light-border);
      font-size: 0.9rem;
    }
    
    body.dark-mode .profile-menu input[type="file"] {
      border-color: var(--dark-border);
      color: var(--dark-text);
      background: rgba(255, 255, 255, 0.05);
    }
    
    .profile-menu #uploadedFileName {
      font-size: 0.8rem;
      color: #6c757d;
      margin-top: var(--spacing-xs);
    }
    
    body.dark-mode .profile-menu #uploadedFileName {
      color: #adb5bd;
    }
    
    /* Chat Box with padding adjustments for welcome message */
    .chat-box {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border: 1px solid var(--light-border);
      /* Update padding to accommodate the sticky welcome message */
      padding: 0 var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
      background-color: var(--light-bg);
      border-radius: var(--border-radius-lg);
      transition: var(--transition);
      margin-bottom: var(--spacing-md);
      position: relative;
      scroll-behavior: smooth;
    }
    
    /* Add margin to first message to create space after welcome message */
    .chat-box > .message:first-of-type {
      margin-top: var(--spacing-lg);
    }
    
    body.dark-mode .chat-box {
      background: rgba(255, 255, 255, 0.02);
      border-color: var(--dark-border);
    }
    
    /* Add padding after welcome message for better spacing */
    .chat-box > .message:first-of-type {
      margin-top: var(--spacing-lg);
    }
    
    /* Chat Input */
    .chat-input {
      display: flex;
      margin-top: var(--spacing-md);
      gap: var(--spacing-md);
      position: relative;
    }
    
    .input-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
    }
    
    .chat-input input {
      flex: 1;
      width: 100%;
      padding: var(--spacing-md) var(--spacing-lg);
      padding-left: 16px;
      padding-right: 135px;
      border: 1px solid var(--light-border);
      border-radius: 30px;
      font-size: 1rem;
      background-color: var(--light-surface);
      color: var(--light-text);
      transition: var(--transition);
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    body.dark-mode .chat-input input {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
      border-color: var(--dark-border);
    }
    
    .chat-input input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }
    
    .attach-btn {
      position: absolute;
      right: 55px;
      top: 50%;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }
    
    .attach-btn:hover {
      color: var(--primary-color);
    }
    
    body.dark-mode .attach-btn {
      color: #adb5bd;
    }
    
    .image-btn {
      position: absolute;
      right: 95px;
      top: 50%;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }
    
    .image-btn:hover {
      color: var(--primary-color);
    }
    
    body.dark-mode .image-btn {
      color: #adb5bd;
    }
    
    #sendBtn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      transition: all 0.2s ease;
    }
    
    #sendBtn:hover {
      transform: translateY(-50%) scale(1.1);
    }
    
    /* Chat Messages */
    .message {
      margin-bottom: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: 20px;
      max-width: 70%;
      word-wrap: break-word;
      line-height: 1.5;
      animation: fadeIn 0.3s ease-out;
      position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .user {
      background-color: var(--primary-color);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }
    
    .bot {
      background-color: var(--light-surface);
      color: var(--light-text);
      align-self: flex-start;
      border-bottom-left-radius: 5px;
      border: 1px solid var(--light-border);
      font-size: 0.9rem; /* Smaller font size for bot messages */
    }
    
    body.dark-mode .bot {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
      border-color: var(--dark-border);
    }
    
    /* Additional styles for better readability with smaller text */
    .message.bot p {
      margin: 8px 0;
      line-height: 1.5;
    }
    
    .message.bot h3.section-header {
      font-size: 1rem; /* Slightly larger than regular text */
    }
    
    .message.bot .list-item {
      margin: 6px 0;
    }
    
    /* Welcome Message with fixed positioning */
    .welcome-message {
      text-align: center;
      padding: 20px;
      background-color: var(--light-bg);
      border-bottom: 1px solid var(--light-border);
      margin-bottom: 0;
      position: relative;
      width: 100%;
      border-top-left-radius: var(--border-radius-lg);
      border-top-right-radius: var(--border-radius-lg);
      transition: var(--transition);
    }
    
    body.dark-mode .welcome-message {
      background-color: var(--dark-bg);
      border-color: var(--dark-border);
    }
    
    .welcome-message.hidden {
      display: none;
    }
    
    .welcome-message h2 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 600;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: var(--spacing-xs);
    }

    .welcome-message p {
      margin-top: var(--spacing-xs);
      font-size: 1.1rem;
      color: #6c757d;
    }

    body.dark-mode .welcome-message p {
      color: #ddd;
    }
    
    .welcome-message .model-info {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      background: #f2f5f9;
      display: inline-block;
      padding: 4px 10px;
      border-radius: 15px;
    }
    
    .welcome-message .model-info .fas {
      color: #4CAF50;
      margin-right: 5px;
    }
    
    .welcome-message .model-info .model-id {
      color: #888;
      font-size: 12px;
    }
    
    body.dark-mode .welcome-message .model-info {
      background: #2d3748;
      color: #cbd5e0;
    }
    
    body.dark-mode .welcome-message .model-info .model-id {
      color: #a0aec0;
    }
    
    /* Responsive adjustments for sidebar */
    @media (max-width: 992px) {
      .dashboard {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
      }
      
      .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 990;
        background-color: var(--light-surface);
        display: none;
        flex-direction: column;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        padding: 15px;
      }
      
      body.dark-mode .sidebar {
        background-color: var(--dark-surface);
      }
      
      .sidebar .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .sidebar .chat-header:after {
        content: "\f00d";
        font-family: "Font Awesome 5 Free";
        font-weight: 900;
        font-size: 1.2rem;
        cursor: pointer;
        color: var(--light-text);
      }
      
      body.dark-mode .sidebar .chat-header:after {
        color: var(--dark-text);
      }
      
      .documents-preview {
        margin-top: 15px;
        flex: 1;
        max-height: none;
      }
      
      #documentPreviews {
        max-height: none;
        flex: 1;
        overflow-y: auto;
      }
      
      .chat-section {
        padding: var(--spacing-md);
        height: 100vh !important;
      }
      
      .nav-links {
        display: none;
      }
      
      .nav-right {
        gap: var(--spacing-md);
      }
      
      .menu-toggle {
        display: block;
        position: relative;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--light-text);
        cursor: pointer;
        transition: var(--transition);
      }
      
      body.dark-mode .menu-toggle {
        color: var(--dark-text);
      }
      
      .chat-box {
        max-height: calc(100vh - 140px) !important;
      }
      
      /* Fixed document preview visibility */
      .sidebar.collapsed .documents-preview {
        display: none !important;
      }
      
      .sidebar:not(.collapsed) .documents-preview {
        display: flex !important;
        max-height: none;
        overflow: visible;
        margin-bottom: var(--spacing-md);
      }
      
      /* Ensure toggle button is always visible */
      .documents-toggle {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        height: 35px;
        border-radius: 0;
        position: relative;
        bottom: 0;
        margin-top: 0;
        z-index: 100;
      }
      
      .documents-preview {
        position: relative;
        max-height: none;
        border: 1px solid var(--light-border);
        margin: 20px 15px;
        border-radius: var(--border-radius-md);
        overflow: hidden;
      }
      
      #documentPreviews {
        max-height: 200px;
        padding: 8px;
      }
    }

    @media (max-width: 768px) {
      .sidebar {
        padding: 10px 8px 0;
      }
      
      .message {
        max-width: 85%;
      }
      
      .profile-menu {
        width: 260px;
        right: -10px;
        padding: var(--spacing-md);
      }
      
      .documents-preview {
        margin: 15px 10px;
        padding: 12px;
      }
      
      #documentPreviews {
        max-height: 150px;
        padding: 5px;
      }
      
      .documents-toggle {
        height: 30px;
      }
      
      .profile-pic-section {
        padding: var(--spacing-sm);
      }
      
      .profile-preview {
        width: 60px;
        height: 60px;
      }
      
      .chat-input {
        display: grid;
        grid-template-columns: 40px 1fr;
        grid-template-rows: auto auto;
        gap: var(--spacing-sm);
      }
      
      .attach-btn {
        position: relative;
        grid-row: 2;
        grid-column: 1;
        transform: none;
        top: auto;
        left: auto;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--light-bg);
        border-radius: var(--border-radius-md);
        border: 1px solid var(--light-border);
      }
      
      body.dark-mode .attach-btn {
        background: rgba(255, 255, 255, 0.05);
        border-color: var(--dark-border);
      }
      
      .chat-input input {
        grid-row: 2;
        grid-column: 2;
        padding-left: var(--spacing-md);
      }
      
      #sendBtn {
        grid-row: 3;
        grid-column: 1 / span 2;
        width: 100%;
        margin-top: var(--spacing-xs);
      }
      
      .chat-nav {
        flex-wrap: wrap;
      }
      
      .nav-profile img {
        width: 35px;
        height: 35px;
      }
    }

    @media (max-width: 576px) {
      .sidebar {
        padding: 8px 5px 0;
      }
      
      .chat-nav {
        padding: var(--spacing-sm) var(--spacing-md);
      }
      
      .nav-left {
        font-size: 1rem;
      }
      
      .chat-section {
        padding: var(--spacing-md);
      }
      
      .welcome-message h2 {
        font-size: 1.5rem;
      }
      
      .welcome-message p {
        font-size: 1rem;
      }
      
      .chat-box {
        padding: var(--spacing-md);
      }
      
      .message {
        max-width: 90%;
        padding: var(--spacing-sm) var(--spacing-md);
      }
      
      #currentChat {
        font-size: 0.8rem;
      }
      
      .chat-header h1 {
        font-size: 1.3rem;
      }
    }

    @media (max-width: 480px) {
      .sidebar {
        padding: 8px 5px 0;
      }
      
      .documents-preview {
        margin: 10px 5px;
        padding: 10px;
      }
      
      .message {
        max-width: 95%;
      }
      
      .chat-nav {
        padding: var(--spacing-xs) var(--spacing-sm);
      }
      
      .nav-left {
        font-size: 0.9rem;
      }
      
      .nav-profile img {
        width: 30px;
        height: 30px;
      }
      
      .profile-menu {
        width: 240px;
        right: -15px;
        padding: var(--spacing-md);
      }
    }

    /* Enhanced mobile menu styling */
    .mobile-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 85%;
      max-width: 320px;
      height: 100vh;
      background-color: var(--light-surface);
      z-index: 999;
      transform: translateX(-100%);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: var(--dark-box-shadow);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border-right: 1px solid rgba(0,0,0,0.1);
    }

    body.dark-mode .mobile-menu {
      background-color: var(--dark-surface);
      border-right: 1px solid rgba(255,255,255,0.1);
    }

    .mobile-menu.active {
      transform: translateX(0);
    }

    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 998;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(2px);
    }

    .mobile-menu-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    /* Refined mobile menu header */
    .mobile-menu-header {
      padding: var(--spacing-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
      position: sticky;
      top: 0;
      background-color: var(--light-surface);
      z-index: 2;
    }

    body.dark-mode .mobile-menu-header {
      border-color: var(--dark-border);
      background-color: var(--dark-surface);
    }

    .mobile-menu-header h1 {
      font-size: 1.5rem;
      margin: 0;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .mobile-menu-content {
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      overflow-y: auto;
    }

    /* Enhanced mobile menu buttons */
    .mobile-menu-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: 12px var(--spacing-lg);
      border-radius: 10px;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .mobile-menu-btn::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background-color: rgba(0, 123, 255, 0.1);
      transition: width 0.2s ease;
      z-index: -1;
      border-radius: 10px;
    }

    .mobile-menu-btn:active {
      transform: scale(0.98);
    }

    .mobile-menu-btn:hover::after {
      width: 100%;
    }

    body.dark-mode .mobile-menu-btn {
      color: var(--dark-text);
    }

    body.dark-mode .mobile-menu-btn::after {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .mobile-menu-btn.new-chat-btn {
      background: var(--primary-color);
      color: white;
      font-weight: 500;
      margin-bottom: var(--spacing-md);
      box-shadow: 0 4px 6px rgba(0, 123, 255, 0.2);
    }

    .mobile-menu-btn.new-chat-btn:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 123, 255, 0.3);
    }

    .mobile-menu-btn.new-chat-btn:active {
      transform: translateY(0);
    }

    /* Improved section headers */
    .mobile-section-header {
      font-size: 0.85rem;
      font-weight: 600;
      color: #6c757d;
      padding: 14px var(--spacing-lg) 8px;
      margin-top: var(--spacing-md);
      position: sticky;
      top: 71px;
      background-color: var(--light-surface);
      z-index: 1;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    body.dark-mode .mobile-section-header {
      color: #adb5bd;
      background-color: var(--dark-surface);
    }

    /* Enhanced chat items */
    .mobile-chat-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--spacing-sm);
      padding: 10px var(--spacing-md);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .mobile-chat-item .chat-info {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      flex: 1;
      overflow: hidden;
    }

    .mobile-chat-item .delete-chat {
      background: none;
      border: none;
      color: var(--danger-color);
      opacity: 0.7;
      font-size: 0.85rem;
      padding: 5px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .mobile-chat-item .delete-chat:hover {
      opacity: 1;
    }

    .mobile-chat-item i {
      color: #6c757d;
      font-size: 0.9rem;
      width: 20px;
      text-align: center;
    }

    body.dark-mode .mobile-chat-item i {
      color: #adb5bd;
    }

    .mobile-chat-item span {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mobile-chat-item::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background-color: rgba(0, 123, 255, 0.1);
      transition: width 0.2s ease;
      z-index: -1;
      border-radius: 10px;
    }

    .mobile-chat-item:hover::after {
      width: 100%;
    }

    .mobile-chat-item.active {
      background-color: rgba(0, 123, 255, 0.15);
      font-weight: 500;
    }

    .mobile-chat-item.active i {
      color: var(--primary-color);
    }

    body.dark-mode .mobile-chat-item.active {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Better menu button animation */
    .menu-toggle {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .menu-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .menu-toggle:active {
      transform: scale(0.95);
    }

    /* Model dropdown styling */
    .model-dropdown {
      display: flex;
      align-items: center;
      cursor: pointer;
      position: relative;
    }

    /* Mobile responsiveness */
    @media (max-width: 992px) {
      .menu-toggle {
        display: block;
      }
      
      .nav-left {
        gap: var(--spacing-sm);
      }
      
      .dashboard {
        height: 100vh;
        overflow: hidden;
      }
      
      .sidebar {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .chat-section {
        padding: var(--spacing-md) var(--spacing-md);
      }
      
      .chat-nav {
        padding: var(--spacing-sm) var(--spacing-md);
        margin-bottom: var(--spacing-sm);
      }
      
      .chat-box {
        padding: var(--spacing-md);
      }
    }

    @media (max-width: 576px) {
      .chat-section {
        padding: var(--spacing-sm);
      }
      
      .chat-nav {
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }
    }

    @media (max-width: 480px) {
      .nav-brand {
        font-size: 1rem;
      }
      
      .model-dropdown i {
        font-size: 0.7rem !important;
      }
    }

    @media (max-width: 992px) {
      /* Remove document preview button from mobile menu */
      .mobile-menu-btn[onclick*="toggleDocumentPreview"] {
        display: none;
      }
      
      /* Use full screen height for chat section on mobile */
      .chat-section {
        height: 100vh !important;
        max-height: none !important;
        padding-bottom: 10px;
      }
      
      /* Fix chat box height to utilize full screen */
      .chat-box {
        max-height: calc(100vh - 120px) !important;
        margin-bottom: 10px;
      }

      /* Hide document preview section entirely on mobile */
      .documents-preview,
      .sidebar .documents-preview,
      .sidebar:not(.collapsed) .documents-preview {
        display: none !important;
      }
      
      /* Hide document-related toggle buttons */
      .documents-toggle {
        display: none !important;
      }
    }

    /* File upload message styling in chat */
    .file-upload {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      margin: 5px 0;
    }

    body.dark-mode .file-upload {
      background-color: rgba(255,255,255,0.1);
    }

    .file-upload i {
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    .file-upload span {
      font-size: 0.95rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 200px;
    }

    @media (max-width: 768px) {
      .chat-input {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
        position: relative;
      }
      
      .input-container {
        flex: 1;
        position: relative;
      }
      
      .attach-btn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        height: auto;
        width: auto;
        background: transparent;
        border: none;
        z-index: 2;
      }
      
      .image-btn {
        position: absolute;
        left: 40px;
        top: 50%;
        transform: translateY(-50%);
        height: auto;
        width: auto;
        background: transparent;
        border: none;
        z-index: 2;
      }
      
      #messageInput {
        padding-left: 70px !important;
      }
      
      #sendBtn {
        right: 8px;
        font-size: 1.2rem;
      }
    }

    /* Scroll to bottom button */
    .scroll-bottom-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.3s ease;
      z-index: 10;
      border: none;
    }
    
    .scroll-bottom-btn.visible {
      opacity: 1;
      transform: scale(1);
    }
    
    .scroll-bottom-btn:hover {
      background-color: var(--primary-hover);
      transform: scale(1.05);
    }
    
    .scroll-bottom-btn:active {
      transform: scale(0.95);
    }
    
    /* Mobile-specific adjustments for chat input */
    @media (max-width: 768px) {
      .chat-input {
        display: flex;
        flex-direction: row;
        position: relative;
        margin-top: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }
      
      .input-container {
        flex: 1;
        display: flex;
        align-items: center;
        position: relative;
      }
      
      .chat-input input {
        width: 100%;
        padding: 12px 40px;
        border-radius: 24px;
        font-size: 1rem;
      }
      
      .attach-btn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: #6c757d;
        z-index: 2;
      }
      
      .image-btn {
        position: absolute;
        left: 40px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: #6c757d;
        z-index: 2;
      }
      
      #sendBtn {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: var(--primary-color);
        font-size: 1.2rem;
        z-index: 2;
      }
      
      /* Ensure chat box fills available space */
      .chat-box {
        max-height: calc(100vh - 170px);
      }
    }
    
    /* Further mobile refinements */
    @media (max-width: 576px) {
      .chat-input {
        margin-top: 6px;
        margin-bottom: 6px;
      }
      
      .chat-input input {
        padding: 10px 38px;
        font-size: 0.95rem;
      }
      
      #sendBtn, .attach-btn {
        font-size: 1.1rem;
      }

      #sendBtn {
        width: 32px;
        height: 32px;
        padding: 0;
        right: 8px;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }
      
      #sendBtn i {
        font-size: 0.85rem;
      }
    }
    
    /* Small mobile screens */
    @media (max-width: 480px) {
      .chat-input {
        margin-top: 4px;
        margin-bottom: 4px;
      }
      
      .chat-input input {
        padding: 9px 36px;
        font-size: 0.9rem;
      }
      
      #sendBtn, .attach-btn {
        font-size: 1rem;
      }

      #sendBtn {
        width: 28px;
        height: 28px;
        padding: 0;
        right: 8px;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }
      
      #sendBtn i {
        font-size: 0.85rem;
      }
    }

    /* Mobile-specific adjustments for chat input */
    @media (max-width: 992px) {
      .chat-section {
        position: relative;
        display: flex;
        flex-direction: column;
        height: fit-content !important;
        min-height: 100vh;
        padding-bottom: 80px !important; /* Space for input */
      }
      
      .chat-box {
        flex: 1;
        height: calc(100vh - 180px) !important;
        margin-bottom: 5px;
      }
      
      .chat-input {
        position: fixed;
        bottom: 10px;
        left: 0;
        right: 0;
        padding: 0 15px;
        margin: 0;
        z-index: 20;
        background: var(--light-surface);
      }
      
      body.dark-mode .chat-input {
        background: var(--dark-surface);
      }
      
      .input-container {
        width: 100%;
        border-radius: 30px;
        background-color: var(--light-surface);
        box-shadow: 0 2px 15px rgba(0,0,0,0.1);
        padding: 2px;
        display: flex;
        align-items: center;
        border: 1px solid var(--light-border);
        transition: all 0.3s ease;
        position: relative;
      }
      
      body.dark-mode .input-container {
        background-color: var(--dark-surface);
        border-color: var(--dark-border);
        box-shadow: 0 2px 15px rgba(0,0,0,0.2);
      }
      
      .attach-btn {
        position: absolute;
        right: 55px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 0;
      }
      
      .image-btn {
        position: absolute;
        right: 95px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 0;
      }
      
      .chat-input input {
        height: 50px;
        font-size: 16px;
        padding: 12px 50px 12px 15px;
        padding-right: 135px;
        border: none;
        background: transparent;
        width: 100%;
      }
      
      #sendBtn {
        width: 36px;
        height: 36px;
        padding: 0;
        right: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }
      
      #sendBtn i {
        font-size: 0.9rem;
      }
      
      body.dark-mode #sendBtn {
        background-color: var(--primary-color);
      }
    }

    /* Additional mobile refinements */
    @media (max-width: 576px) {
      .chat-section {
        height: fit-content !important;
        min-height: 100vh;
      }
      
      .chat-box {
        height: calc(100vh - 160px) !important;
      }
      
      .attach-btn {
        width: 35px;
        height: 35px;
        right: 52px;
      }
      
      .image-btn {
        width: 35px;
        height: 35px;
        right: 90px;
      }
    }

    /* Small mobile screens */
    @media (max-width: 480px) {
      .chat-section {
        padding: var(--spacing-sm);
      }
      
      .chat-box {
        height: calc(100vh - 150px) !important;
      }
      
      .attach-btn {
        width: 32px;
        height: 32px;
        right: 50px;
      }
      
      .image-btn {
        width: 32px;
        height: 32px;
        right: 85px;
      }
    }

    /* Interactive effects for mobile inputs */
    @media (max-width: 992px) {
      /* Input animation when focused */
      .input-container:focus-within {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        border-color: var(--primary-color);
      }
      
      /* Message animations */
      .message {
        transition: transform 0.2s ease, opacity 0.2s ease;
      }
      
      .message.user {
        animation: messageSlideInRight 0.3s ease forwards;
      }
      
      .message.bot {
        animation: messageSlideInLeft 0.3s ease forwards;
      }
      
      @keyframes messageSlideInRight {
        from {
          opacity: 0;
          transform: translateX(30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      
      @keyframes messageSlideInLeft {
        from {
          opacity: 0;
          transform: translateX(-30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      
      /* Send button ripple effect */
      #sendBtn::after {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.4);
        transform: scale(0);
        transition: transform 0.3s ease-out;
      }
      
      #sendBtn:active::after {
        transform: scale(2);
        opacity: 0;
        transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      }
      
      /* Attach button ripple effect */
      .attach-btn::after {
        content: '';
        position: absolute;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1);
        transform: scale(0);
        left: 50%;
        top: 50%;
        margin-left: -15px;
        margin-top: -15px;
      }
      
      .attach-btn:active::after {
        transform: scale(1);
        opacity: 0;
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
      }
      
      /* Input placeholder animation */
      @keyframes placeholderPulse {
        0% { opacity: 0.6; }
        50% { opacity: 1; }
        100% { opacity: 0.6; }
      }
      
      .chat-input input::placeholder {
        animation: placeholderPulse 2s infinite;
      }
      
      /* Make sure input is always visible */
      .chat-section {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      }
    }

    /* Touch-specific styling for active elements */
    .touch-active {
      transform: scale(0.96) !important;
      opacity: 0.8;
      transition: transform 0.1s ease, opacity 0.1s ease;
    }
    
    #sendBtn.touch-active {
      background-color: var(--primary-hover);
    }
    
    .attach-btn.touch-active {
      color: var(--primary-color);
    }
    
    /* Ensure iOS Safari specific improvements */
    @supports (-webkit-touch-callout: none) {
      .chat-input input {
        font-size: 16px; /* Prevents iOS zoom on focus */
      }
      
      .chat-section {
        padding-bottom: 85px !important; /* Extra room for iOS virtual keyboard */
      }
    }
    
    /* Active model in dropdown */
    .dropdown-content a.active-model {
      background-color: #e8f4ff;
      color: #007bff;
      position: relative;
    }
    
    .dropdown-content a.active-model::after {
      content: '';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    body.dark-mode .dropdown-content a.active-model {
      background-color: #1a3554;
      color: #60a5fa;
    }
    
    /* Notification system */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 6px;
      background-color: #f8f9fa;
      color: #333;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
      z-index: 9999;
      transform: translateY(-20px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
      max-width: 300px;
      word-wrap: break-word;
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .notification.info {
      background-color: #e7f2fd;
      border-left: 4px solid #2196F3;
    }
    
    .notification.success {
      background-color: #e8f6e9;
      border-left: 4px solid #4CAF50;
    }
    
    .notification.warning {
      background-color: #fff8e6;
      border-left: 4px solid #FF9800;
    }
    
    .notification.error {
      background-color: #fdeded;
      border-left: 4px solid #F44336;
    }
    
    body.dark-mode .notification {
      background-color: #2d3748;
      color: #e2e8f0;
    }
    
    body.dark-mode .notification.info {
      background-color: #1a365d;
      border-left: 4px solid #4299e1;
    }
    
    body.dark-mode .notification.success {
      background-color: #1c4532;
      border-left: 4px solid #48bb78;
    }
    
    body.dark-mode .notification.warning {
      background-color: #744210;
      border-left: 4px solid #ed8936;
    }
    
    body.dark-mode .notification.error {
      background-color: #742a2a;
      border-left: 4px solid #f56565;
    }
    
    /* Test API button */
    .test-api-btn, .wake-up-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: var(--border-radius-sm);
      margin-top: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .test-api-btn:hover, .wake-up-btn:hover {
      background-color: var(--primary-hover);
    }
    
    .test-api-btn i, .wake-up-btn i {
      margin-right: 6px;
    }
    
    .wake-up-btn {
      background-color: #28a745;
    }
    
    .wake-up-btn:hover {
      background-color: #218838;
    }
    
    body.dark-mode .test-api-btn {
      background-color: #2d3748;
    }
    
    body.dark-mode .test-api-btn:hover {
      background-color: #4a5568;
    }
    
    body.dark-mode .wake-up-btn {
      background-color: #1e7e34;
    }
    
    body.dark-mode .wake-up-btn:hover {
      background-color: #155724;
    }

    .chat-input .attach-btn:hover {
      color: var(--primary-color);
    }
    
    .chat-input .image-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 12px;
      color: #888;
      cursor: pointer;
      transition: var(--transition);
    }
    
    .chat-input .image-btn:hover {
      color: var(--primary-color);
    }
    
    /* Mobile specific fixes */
  </style>
  
  <script>
    // Add haptic feedback for mobile interactions
    document.addEventListener('DOMContentLoaded', function() {
      // Haptic feedback function
      function vibrateOnTouch(duration = 20) {
        if ('vibrate' in navigator) {
          navigator.vibrate(duration);
        }
      }
      
      // Add haptic feedback to send button
      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) {
        sendBtn.addEventListener('touchstart', function() {
          vibrateOnTouch(20);
          this.classList.add('touch-active');
        }, { passive: true });
        
        sendBtn.addEventListener('touchend', function() {
          this.classList.remove('touch-active');
        }, { passive: true });
      }
      
      // Add haptic feedback to attach button
      const attachBtn = document.querySelector('.attach-btn');
      if (attachBtn) {
        attachBtn.addEventListener('touchstart', function() {
          vibrateOnTouch(15);
          this.classList.add('touch-active');
        }, { passive: true });
        
        attachBtn.addEventListener('touchend', function() {
          this.classList.remove('touch-active');
        }, { passive: true });
      }
      
      // Improve message input focus handling
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        // Auto focus input when chat loads on mobile
        // but only if a chat is already selected
        if (window.innerWidth <= 992 && currentChatId) {
          setTimeout(() => {
            // Scroll to ensure input is visible without forcing focus
            const chatSection = document.querySelector('.chat-section');
            if (chatSection) {
              chatSection.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
          }, 300);
        }
        
        // Add haptic feedback when typing
        messageInput.addEventListener('keydown', function() {
          if (window.innerWidth <= 992) {
            vibrateOnTouch(5); // Very subtle vibration
          }
        }, { passive: true });
      }
    });
  </script>
  <style>
    /* Enhanced thinking animation with expandable details */
    .thinking-expandable {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      margin: 10px 0;
      background-color: var(--light-bg);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .dark-mode .thinking-expandable {
      background-color: var(--dark-surface);
      border-color: #444;
    }
    
    .thinking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }
    
    .thinking-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }
    
    .model-badge {
      background-color: var(--primary-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      margin-left: 5px;
    }
    
    .thinking-toggle {
      background: none;
      border: none;
      color: var(--primary-color);
      cursor: pointer;
      font-size: 0.9rem;
      padding: 2px 8px;
      border-radius: 12px;
      border: 1px solid var(--primary-color);
      transition: all 0.2s ease;
    }
    
    .thinking-toggle:hover {
      background-color: var(--primary-color);
      color: white;
    }
    
    .thinking-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
      margin-top: 0;
      opacity: 0;
    }
    
    .thinking-expandable.expanded .thinking-content {
      max-height: 500px;
      opacity: 1;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border-color);
    }
    
    .thinking-prompts {
      font-family: monospace;
      font-size: 0.85rem;
      white-space: pre-wrap;
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .dark-mode .thinking-prompts {
      background-color: rgba(255, 255, 255, 0.05);
    }
    
    .thinking-stage {
      display: block;
      margin-bottom: 5px;
      color: var(--primary-color);
      font-weight: 500;
    }
    
    /* Thinking indicators animation */
    .thinking-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .thinking-indicator span {
      width: 5px;
      height: 5px;
      background-color: var(--primary-color);
      border-radius: 50%;
      display: inline-block;
      animation: thinking 1.4s infinite ease-in-out both;
    }
    
    .thinking-indicator span:nth-child(1) {
      animation-delay: -0.32s;
    }
    
    .thinking-indicator span:nth-child(2) {
      animation-delay: -0.16s;
    }
    
    @keyframes thinking {
      0%, 80%, 100% {
        transform: scale(0);
        opacity: 0;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    /* Enhanced Message Formatting Styles */
    .message.bot {
        line-height: 1.6;
    }
    
    .message.bot h3.section-header {
        margin: 16px 0 8px;
        font-weight: 600;
        color: var(--primary-color);
        border-bottom: 1px solid rgba(0,0,0,0.1);
        padding-bottom: 4px;
    }
    
    .dark-mode .message.bot h3.section-header {
        border-bottom-color: rgba(255,255,255,0.1);
    }
    
    .message.bot .list-item {
        margin: 8px 0;
        display: flex;
    }
    
    .message.bot .list-number {
        min-width: 24px;
        font-weight: 600;
        color: var(--primary-color);
    }
    
    .message.bot p {
        margin: 12px 0;
    }
    
    .message.bot code.inline-code {
        background-color: rgba(0,0,0,0.05);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.9em;
    }
    
    .dark-mode .message.bot code.inline-code {
        background-color: rgba(255,255,255,0.1);
    }
    
    .message.bot pre.code-block {
        background-color: rgba(0,0,0,0.05);
        padding: 12px;
        border-radius: 5px;
        overflow-x: auto;
        margin: 12px 0;
    }
    
    .dark-mode .message.bot pre.code-block {
        background-color: rgba(255,255,255,0.05);
    }
    
    .message.bot .math-inline {
        font-family: monospace;
        font-style: italic;
        background-color: rgba(0,0,0,0.02);
        padding: 0 4px;
        border-radius: 3px;
    }
    
    .dark-mode .message.bot .math-inline {
        background-color: rgba(255,255,255,0.05);
    }
  </style>
  <!-- Remove authentication overlay -->
  
  <style>
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Remove authentication blocking styles */
  </style>
  
  <!-- Remove second authentication overlay -->
</head>
<body>
  <div class="dashboard">
    <!-- Left Sidebar -->
    <div class="sidebar">
      <div class="chat-header">
        <h1><i class="fas fa-scale-balanced"></i> LegalMind</h1>
      </div>
     
      <div id="currentChat" style="margin-bottom: var(--spacing-md); font-weight: 500; font-size: 0.9rem; color: #6c757d;">
        <span>Current Chat:</span> <span id="currentChatName">None</span>
      </div>
      
      <button class="new-chat" onclick="addNewChat()">
        <i class="fas fa-plus"></i> New Chat
      </button>
      
      <ul class="chat-list" id="chatList"></ul>
      
      <div class="documents-preview">
        <h3><i class="fas fa-file-alt"></i> Documents</h3>
        <div id="documentPreviews"></div>
        <button class="documents-toggle" id="documentsToggle">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
    </div>

    <!-- Chat Section -->
    <div class="chat-section">
      <!-- Navigation Bar -->
      <div class="chat-nav">
        <div class="nav-left">
          <button class="menu-toggle" id="mobileMenuToggle" aria-label="Open menu">
            <i class="fas fa-bars"></i>
          </button>
          <div class="model-dropdown">
            <span class="nav-brand">LegalMind</span>
            <i class="fas fa-chevron-down" style="font-size: 0.8rem; margin-left: 5px;"></i>
        </div>
        </div>
        
        <div class="nav-right">
          <div class="nav-links">
            <div class="dropdown">
              <a href="#" onclick="togglePlansDropdown(event)">
                <i class="fas fa-crown"></i> Plans
              </a>
              <div class="dropdown-content" id="plansDropdown">
                <a href="#"><i class="fas fa-calendar-alt"></i> 1 Month  100</a>
                <a href="#"><i class="fas fa-calendar-alt"></i> 3 Months  250</a>
                <a href="#"><i class="fas fa-calendar-alt"></i> 1 Year  800</a>
              </div>
            </div>
            
            <div class="dropdown">
              <a href="#" onclick="toggleModelsDropdown(event)">
                <i class="fas fa-microchip"></i> <span id="currentModelDisplay">LegalMind</span>
              </a>
              <div class="dropdown-content" id="modelsDropdown">
                <a href="#" data-model="legalMind" onclick="setActiveModel('legalMind'); return false;" class="active-model"><i class="fas fa-brain"></i> LegalMind (Abbasgamer1)</a>
                <a href="#" data-model="gemma" onclick="setActiveModel('gemma'); return false;"><i class="fas fa-brain"></i> Gemma 3 (12B)</a>
                <a href="#" data-model="distilBert" onclick="setActiveModel('distilBert'); return false;"><i class="fas fa-brain"></i> Distl-BERT Model</a>
              </div>
            </div>
            
            <a href="contact.html"><i class="fas fa-envelope"></i> Contact Us</a>
          </div>
          
          <div class="nav-profile">
            <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile" id="profilePicNav" />
            <div class="profile-menu" id="profileMenu">
              <div class="profile-menu-header">
                <span class="user-name" id="profileUserName">User Name</span>
                <span class="user-plan">Subscription: Basic</span>
              </div>
              
              <div class="profile-menu-actions" id="profileMainMenu">
                <button class="profile-menu-btn" id="settingsButton">
                  <i class="fas fa-cog"></i> Settings
                </button>
                <button class="profile-menu-btn logout" id="logoutButton">
                  <i class="fas fa-sign-out-alt"></i> Logout
                </button>
              </div>
              
              <div class="settings-panel" id="settingsPanel">
                <button class="back-to-menu" id="backToMenu">
                  <i class="fas fa-arrow-left"></i> Back
                </button>
                
                <div class="settings-section">
                  <div class="settings-section-header">
                    <i class="fas fa-moon"></i> Appearance
                  </div>
              <label class="switch">
                <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
                    <span>Dark Mode</span>
              </label>
            </div>
                
                <div class="settings-section">
                  <div class="settings-section-header">
                    <i class="fas fa-user"></i> Profile Picture
          </div>
                  <div class="profile-pic-upload">
                    <div class="profile-preview">
                      <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile Preview" id="profilePreview">
                    </div>
                    <label for="uploadProfile" class="upload-btn">
                      <i class="fas fa-upload"></i> Choose File
                    </label>
                    <input type="file" id="uploadProfile" onchange="uploadProfilePicture(event)" accept="image/*" style="display: none;">
                    <p id="uploadedFileName" class="file-name"></p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Mobile Menu -->
      <div class="mobile-menu-overlay" id="mobileMenuOverlay"></div>
      <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
          <img src="https://ui-avatars.com/api/?name=Legal&background=0D8ABC&color=fff" width="30" height="30" alt="Logo" style="border-radius: 50%;">
          <h1>LegalMind</h1>
        </div>
        <div class="mobile-menu-content">
          <button class="mobile-menu-btn new-chat-btn" onclick="addNewChat(); closeMobileMenu();">
            <i class="fas fa-plus"></i>
            <span>New chat</span>
          </button>
          
          <div class="mobile-section-header">Today</div>
          <div id="mobileTodayChats">
            <!-- Today's chats will be populated here -->
          </div>
          
          <div class="mobile-section-header">Previous days</div>
          <div id="mobilePreviousChats">
            <!-- Previous chats will be populated here -->
          </div>
          
          <div class="mobile-section-header">Features</div>
          <button class="mobile-menu-btn" onclick="toggleDocumentPreview(); closeMobileMenu();">
            <i class="fas fa-file-alt"></i>
            <span>Document Preview</span>
          </button>
          <button class="mobile-menu-btn" onclick="window.location.href='contact.html'">
            <i class="fas fa-envelope"></i>
            <span>Contact Us</span>
          </button>
        </div>
      </div>

      <div class="chat-box" id="chatBox">
      <div class="welcome-message">
        <h2>Hi, I'm LegalMind.</h2>
          <p>Ask me anything about legal documents and concepts.</p>
          <p><i class="fas fa-file-upload"></i> Upload documents using the paperclip icon or <i class="fas fa-camera"></i> upload images with text using the camera icon.</p>
          <div class="model-info">
            <i class="fas fa-plug"></i> Connected to <span id="welcomeModelName">LegalMind</span> model 
            <span class="model-id">(revision: 81f0038)</span>
          </div>
        </div>
        <button class="scroll-bottom-btn" id="scrollBottomBtn" aria-label="Scroll to bottom">
          <i class="fas fa-chevron-down"></i>
        </button>
      </div>

      <div class="chat-input">
        <div class="input-container">
          <input 
            type="text" 
            id="messageInput" 
            placeholder="Type your message..." 
            aria-label="Type your message"
            onkeypress="if(event.key === 'Enter') sendMessage()"
          >
          
          <span class="image-btn" onclick="document.getElementById('imageInput').click()">
            <i class="fas fa-camera"></i>
          </span>
          <input type="file" id="imageInput" accept="image/png,image/jpeg,image/jpg" style="display:none;" onchange="processImage(event)">
          
          <span class="attach-btn" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-paperclip"></i>
          </span>
          <input type="file" id="fileInput" accept=".pdf,.txt,.docx" style="display:none;" onchange="previewFile(event)">
          
          <button id="sendBtn" onclick="sendMessage()" aria-label="Send message">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="auth.js" type="module"></script>
  <script>
    // Global storage for chat conversations and documents
    let chats = {};
    let currentChatId = null;
    let uploadedDocuments = {}; // Store document content by filename
    
    // Model configuration
    const modelConfig = {
      legalMind: {
        name: "LegalMind",

        endpoints: [
          "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2",
          "https://api-inference.huggingface.co/models/google/gemma-3-12b-it",
          "https://evktndrzhfjk0kzf.us-east-1.aws.endpoints.huggingface.cloud",
          "https://api-inference.huggingface.co/models/Abbasgamer1/legalMind"
          // Hidden fallback
        ],
        // Multiple API tokens to try as alternatives
        authTokens: [
          "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",  // legalmindapi - WRITE
          "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"   // Current token
        ],
        // Track which endpoint and token is currently being used
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        // Flag to indicate we're using the fallback model
        usingFallbackModel: false
      },
      gemma: {
        name: "Gemma 3 (12B)",
        endpoints: [
          "https://api-inference.huggingface.co/models/google/gemma-3-12b-it"
        ],
        authTokens: [
          "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",  // legalmindapi - WRITE
          "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"   // Current token
        ],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        usingFallbackModel: false
      },
      // Add more models here if needed
    };
    
    // Current active model
    let activeModel = "legalMind";
    
    // Function to determine if a query is legal-related
    function isLegalQuery(query) {
      const legalKeywords = [
        'legal', 'law', 'lawyer', 'attorney', 'court', 'judge', 'lawsuit', 'sue', 'plaintiff', 'defendant',
        'contract', 'agreement', 'clause', 'provision', 'statute', 'regulation', 'compliance', 'liability',
        'tort', 'negligence', 'damages', 'compensation', 'party', 'parties', 'breach', 'obligation',
        'jurisdiction', 'rights', 'duties', 'legal document', 'legal advice', 'license', 'patent',
        'copyright', 'trademark', 'intellectual property', 'legislation', 'bylaws', 'crime', 'criminal',
        'civil', 'case law', 'precedent', 'arbitration', 'mediation', 'settlement', 'legal claim', 'petition',
        'probate', 'estate', 'will', 'property', 'divorce', 'custody', 'immigration', 'visa', 'asylum'
      ];
      
      const query_lower = query.toLowerCase();
      
      // Check if the query contains any legal keywords
      return legalKeywords.some(keyword => query_lower.includes(keyword.toLowerCase())) ||
             // Also consider document analysis as legal queries
             Object.keys(uploadedDocuments).length > 0;
    }
    
    // Function to show a notification
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      
      // Add to body
      document.body.appendChild(notification);
      
      // Show with animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }
    
    // Function to set the active model
    function setActiveModel(modelKey) {
      if (modelConfig[modelKey]) {
        const previousModel = activeModel;
        activeModel = modelKey;
        
        // Update UI to indicate the active model
        const modelDropdown = document.getElementById("modelsDropdown");
        if (modelDropdown) {
          const menuItems = modelDropdown.querySelectorAll('a');
          menuItems.forEach(item => {
            if (item.getAttribute('data-model') === modelKey) {
              item.classList.add('active-model');
            } else {
              item.classList.remove('active-model');
            }
          });
        }
        
        // Update the model name in the dropdown header
        const currentModelDisplay = document.getElementById("currentModelDisplay");
        if (currentModelDisplay) {
          currentModelDisplay.textContent = modelConfig[modelKey].name;
        }
        
        // Update the welcome message model name
        const welcomeModelName = document.getElementById("welcomeModelName");
        if (welcomeModelName) {
          welcomeModelName.textContent = modelConfig[modelKey].name;
        }
        
        // Show notification if the model actually changed
        if (previousModel !== modelKey) {
          showNotification(`Model changed to ${modelConfig[modelKey].name}`, 'success');
        }
        
        return true;
      }
      return false;
    }

    // Initialize dark mode from preferences
    document.addEventListener('DOMContentLoaded', function() {
      // Remove authentication checks and initialize directly
      console.log("DOM loaded - initializing app directly without auth check");
      
      // Initialize the app immediately without checking authentication
              initializeApp();
    });
    
    // Function that initializes the app after authentication
    function initializeApp() {
      console.log("Initializing app");
      
      // Check for saved dark mode preference
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').checked = true;
        if (document.getElementById('darkModeIcon')) {
          document.getElementById('darkModeIcon').classList.remove('fa-moon');
          document.getElementById('darkModeIcon').classList.add('fa-sun');
          document.getElementById('darkModeText').textContent = 'Light Mode';
        }
      }
      
      // Mobile menu handlers
      document.getElementById('mobileMenuToggle').addEventListener('click', function() {
        document.getElementById('mobileMenu').classList.add('active');
        document.getElementById('mobileMenuOverlay').classList.add('active');
        updateMobileChats();
      });
      
      document.getElementById('mobileMenuOverlay').addEventListener('click', closeMobileMenu);
      
      // Check screen width and adapt layout
      function checkScreenWidth() {
        const sidebar = document.querySelector('.sidebar');
        if (window.innerWidth <= 992 && sidebar) {
          if (!sidebar.classList.contains('collapsed')) {
            sidebar.classList.add('collapsed');
          }
        }
      }
      
      // Initial check
      checkScreenWidth();
      
      // Listen for window resize
      window.addEventListener('resize', checkScreenWidth);
      
      // Fix mobile scrolling issues for chat box
      const chatBox = document.getElementById('chatBox');
      if (chatBox) {
        window.addEventListener('resize', function() {
          if (window.innerWidth <= 992) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
        });
        
        // Handle welcome message visibility on scroll
        const welcomeMessage = document.querySelector('.welcome-message');
        
        if (welcomeMessage) {
          // Show welcome message initially
          welcomeMessage.classList.remove('hidden');
          
          // Check on scroll
          chatBox.addEventListener('scroll', function() {
            if (chatBox.scrollTop > 10) {
              welcomeMessage.classList.add('hidden');
            } else {
              welcomeMessage.classList.remove('hidden');
            }
          });
        }
      }
      
      // Make document preview fully visible on page load with enhanced visibility
      const previewSection = document.querySelector('.documents-preview');
      if (previewSection) {
        previewSection.style.display = 'block';
        previewSection.style.visibility = 'visible';
        previewSection.style.opacity = '1';
        previewSection.style.zIndex = '5';
        
        // Initialize preview area
        const documentPreviews = document.getElementById('documentPreviews');
        if (documentPreviews && documentPreviews.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          documentPreviews.appendChild(welcomeText);
        }
      }
      
      // Simplified documents toggle functionality with forced visibility
      const documentsToggle = document.getElementById('documentsToggle');
      const documentPreviews = document.getElementById('documentPreviews');
      
      if (documentsToggle && documentPreviews) {
        // Make sure it starts visible
        documentPreviews.style.display = 'block';
        
        documentsToggle.addEventListener('click', function() {
          if (documentPreviews.style.display === 'none') {
            documentPreviews.style.display = 'block';
            this.querySelector('i').classList.remove('fa-chevron-down');
            this.querySelector('i').classList.add('fa-chevron-up');
          } else {
            documentPreviews.style.display = 'none';
            this.querySelector('i').classList.remove('fa-chevron-up');
            this.querySelector('i').classList.add('fa-chevron-down');
          }
        });
      }
      
      // Add mobile menu button to toggle document visibility
      const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
      if (toggleSidebarBtn) {
        toggleSidebarBtn.addEventListener('click', function() {
        toggleSidebar();
        document.getElementById('mobileMenu').classList.remove('active');
      });
      }
      
      // Automatically create a new chat and show welcome message
      // Check if there are no existing chats first
      const chatList = document.getElementById("chatList");
      if (chatList && chatList.children.length === 0) {
        // Create a new chat
        addNewChat();
        
        // Add a welcome message from the bot
        setTimeout(() => {
          // Get the username
          const userName = getUserName();
          
          const welcomeMessageText = ` Welcome to LegalMind! Hi ${userName}, I'm your AI legal assistant.

I can help you with:
 Analyzing and summarizing legal documents
 Answering questions about legal concepts and terminology
 Suggesting improvements to contracts and agreements
 Providing general legal information

Upload a document using the paperclip icon  or simply ask me a question to get started!

Note: For non-legal questions, I'll automatically switch to a general knowledge mode to better assist you.`;
          
          appendMessage("bot", welcomeMessageText);
        }, 300);
      }
      
      // Initialize file upload handling
      initializeFileHandling();
    }
    
    // Function to initialize file handling
    function initializeFileHandling() {
      // Reset file inputs to ensure they're clear
      const fileInput = document.getElementById('fileInput');
      const imageInput = document.getElementById('imageInput');
      
      if (fileInput) {
        fileInput.value = '';
        console.log("File input initialized");
      }
      
      if (imageInput) {
        imageInput.value = '';
        console.log("Image input initialized");
      }
      
      // Make sure we have a chat ready for document uploads
      if (!currentChatId) {
        // We'll create the chat when needed, but we log this state
        console.log("No chat active yet, will create one when documents are uploaded");
      }
    }

    function addNewChat() {
      const chatList = document.getElementById("chatList");
      const chatId = "chat_" + Date.now();
      const chatName = "Chat " + (chatList.children.length + 1);

      const chatItem = document.createElement("li");
      chatItem.setAttribute("data-chat-id", chatId);
      chatItem.innerHTML = `
        <span>${chatName}</span>
        <button class="delete-chat" onclick="deleteChat(event, this)" aria-label="Delete chat">
          <i class="fas fa-times"></i>
        </button>
      `;
      
      chatItem.addEventListener("click", function(e) {
        if (e.target.classList.contains("delete-chat") || e.target.closest('.delete-chat')) return;
        
        document.querySelectorAll('#chatList li').forEach(item => {
          item.classList.remove('active');
        });
        
        this.classList.add('active');
        loadChat(chatId, chatName);
        
        // On mobile, collapse sidebar after selecting chat
        if (window.innerWidth <= 992) {
          document.querySelector('.sidebar').classList.add('collapsed');
        }
      });
      
      chatList.appendChild(chatItem);
      chats[chatId] = [];
      loadChat(chatId, chatName);
      
      // Show the chat list after creating new chat
      const sidebar = document.querySelector('.sidebar');
      if (sidebar.classList.contains('collapsed')) {
        sidebar.classList.remove('collapsed');
      }
      
      // Update mobile menu after adding new chat
      setTimeout(updateMobileChats, 100);
    }

    function loadChat(chatId) {
        // Set current chat
      currentChatId = chatId;
        
        // Clear chat box
      const chatBox = document.getElementById("chatBox");
        chatBox.innerHTML = '';
        
        // Always add welcome message
        const welcomeMessage = document.createElement("div");
        welcomeMessage.classList.add("welcome-message");
        welcomeMessage.innerHTML = `
            <h2>Hi, I'm LegalMind.</h2>
            <p>Ask me anything about legal documents and concepts.</p>
            <p><i class="fas fa-file-upload"></i> Upload documents using the paperclip icon and I can analyze them for you.</p>
        `;
        chatBox.appendChild(welcomeMessage);
        
        // Add scroll button
        const scrollBtn = document.createElement("button");
        scrollBtn.className = "scroll-bottom-btn";
        scrollBtn.id = "scrollBottomBtn";
        scrollBtn.setAttribute("aria-label", "Scroll to bottom");
        scrollBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
        chatBox.appendChild(scrollBtn);
        
        // Update current chat name
        document.getElementById("currentChatName").textContent = chats[chatId]?.name || "New Chat";
        
        // Load messages for this chat and append them
        if (chats[chatId] && chats[chatId].messages) {
            chats[chatId].messages.forEach(msg => {
                if (msg.type === "text") {
                    // Use a special version that doesn't auto-scroll during loading
          const msgDiv = document.createElement("div");
                    msgDiv.textContent = msg.content;
                    msgDiv.classList.add("message", msg.sender);
          chatBox.appendChild(msgDiv);
                } else if (msg.type === "html") {
                    // Use a special version that doesn't auto-scroll during loading
                    const msgDiv = document.createElement("div");
                    msgDiv.innerHTML = msg.content;
                    msgDiv.classList.add("message", msg.sender);
                    chatBox.appendChild(msgDiv);
                }
            });
        }
        
        // Set active class for chat items
        const chatItems = document.querySelectorAll(".chat-item, .mobile-chat-item");
        chatItems.forEach(item => {
            item.classList.remove("active");
            if (item.getAttribute("data-chat-id") === chatId) {
                item.classList.add("active");
            }
        });
        
        // Focus input field to make keyboard appear on mobile
        setTimeout(() => {
            const messageInput = document.getElementById("messageInput");
            if (messageInput && window.innerWidth <= 992) {
                // On mobile, scroll to make input visible and focus it
                const chatSection = document.querySelector(".chat-section");
                if (chatSection) {
                    chatSection.scrollTop = chatSection.scrollHeight;
                }
                
                // Gently scroll to show input without forcefully focusing
                // (which would bring up keyboard automatically)
                chatBox.scrollTo({
                    top: chatBox.scrollHeight,
                    behavior: 'auto'
                });
            }
            
            // Initialize the scroll button (check visibility)
            const scrollBottomBtn = document.getElementById('scrollBottomBtn');
            if (scrollBottomBtn) {
                const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
                if (isAtBottom) {
                    scrollBottomBtn.classList.remove('visible');
                } else {
                    scrollBottomBtn.classList.add('visible');
                }
            }
        }, 100);
    }

    function deleteChat(event, button) {
      event.stopPropagation();
      const chatItem = button.closest('li');
      const chatId = chatItem.getAttribute("data-chat-id");

      if (chats[chatId]) {
        delete chats[chatId];
      }
      chatItem.remove();

      if (currentChatId === chatId) {
        currentChatId = null;
        const chatBox = document.getElementById("chatBox");
        const welcomeMessage = document.querySelector('.welcome-message');
        
        // Clear chat and ensure welcome message is preserved
        if (welcomeMessage) {
          chatBox.innerHTML = '';
          welcomeMessage.classList.remove('hidden');
          chatBox.appendChild(welcomeMessage);
        } else {
          chatBox.innerHTML = '';
        }
        
        document.getElementById("currentChatName").textContent = "None";
      }
      
      // Update mobile menu after deleting chat
      setTimeout(updateMobileChats, 100);
    }

    // Improved appendMessage function with less intrusive scrolling
    window.appendMessage = function(sender, text) {
        const chatBox = document.getElementById('chatBox');
        if (!chatBox) return;
        
        const msgDiv = document.createElement("div");
        
        // Format the text if it's coming from the bot
        if (sender === "bot") {
            // Process the text for better formatting
            const formattedText = formatBotMessage(text);
            msgDiv.innerHTML = formattedText;
        } else {
            // For user messages, just use regular text
        msgDiv.textContent = text;
        }
        
        msgDiv.classList.add("message", sender);
        
        // Check if we're at the bottom before adding the message
        const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
        
        // Append the message
        chatBox.appendChild(msgDiv);
        
        // Only auto-scroll if we were already at the bottom
        if (wasAtBottom) {
            chatBox.scrollTo({
                top: chatBox.scrollHeight,
                behavior: 'smooth'
            });
        }
        
        // Store in current chat if available
        if (currentChatId && chats[currentChatId]) {
            if (!chats[currentChatId].messages) {
                chats[currentChatId].messages = [];
            }
            chats[currentChatId].messages.push({
                type: sender === "bot" ? 'html' : 'text',
                sender: sender,
                content: text
            });
        }
    };
    
    // Function to format bot messages with improved styling
    function formatBotMessage(text) {
        if (!text) return "";
        
        // Process LaTeX-style math expressions
        // Inline math: $formula$
        let formattedText = text.replace(/\$([^$\n]+?)\$/g, '<span class="math-inline">$1</span>');
        
        // Process code blocks
        formattedText = formattedText.replace(/```([^`]*?)```/gs, '<pre class="code-block"><code>$1</code></pre>');
        
        // Process inline code
        formattedText = formattedText.replace(/`([^`]+?)`/g, '<code class="inline-code">$1</code>');
        
        // Format section headers (e.g., "Document Summary:")
        formattedText = formattedText.replace(/^([A-Z][A-Za-z\s]+):(?=\s+)/gm, '<h3 class="section-header">$1:</h3>');
        
        // Format numbered steps and lists (1. 2. 3. etc)
        formattedText = formattedText.replace(/^(\d+\.\s+)(.+)$/gm, '<div class="list-item"><span class="list-number">$1</span>$2</div>');
        
        // Add proper paragraph spacing
        formattedText = formattedText
            .split(/\n\s*\n/)
            .map(para => para.trim())
            .filter(para => para.length > 0)
            .map(para => {
                // Don't wrap already formatted elements in paragraphs
                if (para.startsWith('<h3') || 
                    para.startsWith('<div class="list-item">') || 
                    para.startsWith('<pre') ||
                    para.startsWith('<ul') ||
                    para.startsWith('<ol')) {
                    return para;
                }
                return `<p>${para}</p>`;
            })
            .join('');
            
        return formattedText;
    }

    // Function to check if the message is asking about chatbot identity
    function isIdentityQuestion(text) {
      const lowerText = text.toLowerCase().trim();
      
      // Check for common identity questions
      const identityPatterns = [
        /^who are you/,
        /^what are you/,
        /tell me about yourself/,
        /^who is legal ?mind/,
        /^what is legal ?mind/,
        /introduce yourself/,
        /your name/,
        /^who created you/,
        /^who made you/,
        /^who is your owner/,
        /^what do you do/,
        /^what can you do/
      ];
      
      return identityPatterns.some(pattern => pattern.test(lowerText));
    }
    
    // Function to handle identity questions
    function getIdentityResponse(text) {
      const lowerText = text.toLowerCase().trim();
      
      // Check if asking about creator/owner
      if (lowerText.includes("who made you") || 
          lowerText.includes("who created you") || 
          lowerText.includes("who is your owner") ||
          lowerText.includes("who developed you")) {
        return "I was created by Mohammad Suheb Abbas. You can find the project repository at https://github.com/SM-Abbas/Final-Year-Project-54";
      }
      
      // Default identity response
      return "I am LegalMind, an AI legal assistant that specializes in analyzing legal documents. I can help review contracts, legal agreements, and other documents, providing insights and suggestions for improvements. If you have a document you'd like me to analyze, please upload it using the paperclip icon in the chat input.";
    }

    // Function to check if the user is asking about which model is being used
    function isModelQuestion(text) {
      const lowerText = text.toLowerCase().trim();
      
      // Check for common model-related questions
      const modelPatterns = [
        /which model/i,
        /what model/i,
        /model (?:is )?(?:being )?used/i,
        /using which model/i,
        /model (?:are|is) you/i,
        /current model/i,
        /active model/i,
        /(?:you|it) (?:running|using) (?:on|as) (?:a|the) model/i,
        /model (?:version|type|name)/i,
        /(?:powered|run) by/i,
        /backend model/i,
        /based on (?:what|which) model/i
      ];
      
      return modelPatterns.some(pattern => pattern.test(lowerText));
    }
    
    // Function to get model information response
    function getModelResponse() {
      return "I'm running on LegalMind (Abbasgamer1), which is specially designed for legal document analysis and support. This model has been fine-tuned to understand legal terminology and concepts.";
    }

    // Function to determine if a question is a continuation of previous conversation
    function isContinuationQuestion(text, messages) {
      if (!text || !messages || messages.length < 2) return false;
      
      const lowerText = text.toLowerCase().trim();
      
      // Very short questions are often continuations
      if (lowerText.split(' ').length <= 5) {
        return true;
      }
      
      // Check for pronouns and continuation phrases
      const continuationPatterns = [
        // Pronouns that could reference previous content
        /\b(it|this|that|they|them|these|those)\b/i,
        /\b(its|their|theirs)\b/i,
        
        // Question words that might reference previous context
        /\b(why|how|what|when|where|who)\b.*\?$/i,
        
        // Conjunctions at the start suggest continuity
        /^(and|but|so|also|besides|additionally|however|moreover|furthermore)\b/i,
        
        // References seeking more details
        /\b(more|elaboration|clarify|explain|details|elaborate|continue|tell me more)\b/i,
        
        // Direct references to previous interactions
        /\bcan you\b/i,
        /\b(the|your|previous|last|earlier) (answer|response|explanation|message|point|summary|analysis)\b/i,
        
        // References to understanding or agreement
        /\b(i understand|i see|i get it|makes sense|got it)\b.*\?/i,
        
        // Questions about previous statements
        /\b(you said|you mentioned|you noted|you stated|you indicated|you suggested)\b/i,
        
        // Referencing something without clarifying what "that" is
        /\b(what about|how about)\b/i,
        
        // Asking for completion
        /\b(finish|continue|go on|proceed|what else|anything else)\b/i,
        
        // Follow-up indicators
        /\b(follow(ing)? up|related to|regarding|concerning|about that|on that note)\b/i,
        
        // Asking for examples
        /\b(example|instance|case|scenario)\b/i,
        
        // Requesting alternatives
        /\b(alternative|instead|other options|different way|another approach)\b/i,
        
        // Comparison questions 
        /\b(better|worse|difference between|compare)\b/i
      ];
      
      // Check if any pattern matches
      const isPatternMatch = continuationPatterns.some(pattern => pattern.test(lowerText));
      if (isPatternMatch) return true;
      
      // Check for references to specific entities from the last few messages
      const recentBotMessages = messages
        .filter(msg => msg.sender === "bot")
        .slice(-3)
        .map(msg => msg.content);
      
      // Extract potential key entities (nouns, named entities, etc.) from recent messages
      // Simplified approach: look for capitalized words and phrases in recent responses
      let keyEntities = [];
      recentBotMessages.forEach(message => {
        // Find capitalized words/phrases (potential entities)
        const capitalizedMatches = message.match(/\b[A-Z][a-zA-Z]*\b/g) || [];
        // Find quoted text
        const quotedMatches = message.match(/"([^"]*)"/g) || [];
        
        // Extract term from quotes (remove the quotes)
        const quotedTerms = quotedMatches.map(match => 
          match.replace(/^"|"$/g, '').toLowerCase()
        );
        
        // Add all found entities
        keyEntities = [...keyEntities, 
          ...capitalizedMatches.map(m => m.toLowerCase()),
          ...quotedTerms
        ];
      });
      
      // Remove duplicates and common words
      const commonWords = ["i", "me", "you", "we", "us", "they", "them", "it", "the", "a", "an", "this", "that", "these", "those"];
      keyEntities = [...new Set(keyEntities)].filter(e => e.length > 2 && !commonWords.includes(e));
      
      // Check if question mentions any key entity
      if (keyEntities.length > 0) {
        const mentionsEntity = keyEntities.some(entity => 
          lowerText.includes(entity)
        );
        
        if (mentionsEntity) return true;
      }
      
      return false;
    }
    
    // Function to detect and filter inappropriate content related to intimacy
    function containsInappropriateContent(text) {
      if (!text) return false;
      
      const lowerText = text.toLowerCase().trim();
      
      // Define patterns for inappropriate content related to intimacy
      const inappropriatePatterns = [
        /\b(sex|sexual|sexuality|nude|naked|porn|explicit|adult content)\b/i,
        /\b(intercourse|foreplay|orgasm|climax|ejacul|penetrat)\w*\b/i,
        /\b(masturbat|genital|privates|private parts)\w*\b/i,
        /\b(erotic|erotica|69|bdsm|fetish|kink)\b/i,
        /\b(nsfw|xxx|x-rated|arousal|aroused)\b/i,
        /\b(boob|breast|tit|ass|butt|penis|vagina|dick|cock|pussy)\w*\b/i,
        /\b(fuck|fucking|fucked|anal|oral sex|blow job|hand job)\b/i,
        /\b(intimate|intimacy)\b.*\b(physical|detail|guide|how|instruct)/i,
        /\b(dirty talk|obscen|lewd|lust|horny|sensual pleasure)\b/i
      ];
      
      return inappropriatePatterns.some(pattern => pattern.test(lowerText));
    }

    // Send message function
    function sendMessage() {
      // Get message text
      const messageInput = document.getElementById("messageInput");
      const userMessageText = messageInput.value.trim();
      
      // Check if it's not a legal query, route to Gemma
      const originalActiveModel = activeModel;
      const isLegal = isLegalQuery(userMessageText);
      
      // Create a variable to track if we need to add a disclaimer
      let needsDisclaimer = false;
      
      if (!isLegal) {
        // Find the Gemma model endpoint in the legalMind config
        const gemmaIndex = modelConfig.legalMind.endpoints.findIndex(endpoint =>
          endpoint.toLowerCase().includes('gemma')
        );
        
        if (gemmaIndex !== -1) {
          console.log("Non-legal query detected. Using Gemma model but continuing to respond.");
          // Temporarily set the endpoint to Gemma
          modelConfig.legalMind.currentEndpointIndex = gemmaIndex;
          
          // Add document context to query if documents are uploaded
          if (Object.keys(uploadedDocuments).length > 0) {
            userMessageText = addDocumentContext(userMessageText);
          }
          
          // Set flag to add disclaimer
          needsDisclaimer = true;
          
          // Show a subtle notification that this is a non-legal query
          showNotification("Answering non-legal query with disclaimer", "info");
        }
      } else {
        // Check which model endpoint we're using currently
        const currentEndpointInfo = getCurrentEndpointInfo(activeModel);
        
        // Format the full prompt based on the model
        let fullPrompt = "";
        
        // If we're using the Gemma model, use its recommended format
        if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma")) {
          // Gemma format 
          fullPrompt = `<start_of_turn>user\n${userMessageText}<end_of_turn>\n<start_of_turn>model`;
          
          console.log("Using Gemma 3 model format");
        } else if (chatMessages && chatMessages.length > 0) {
          // ... existing code ...
        }
      }
      
      // Don't send empty messages
      if (userMessageText === "") {
        return;
      }
      
      // Clear the input field
      messageInput.value = "";
      
      if (currentChatId) {
        // Check for inappropriate content before proceeding
        if (containsInappropriateContent(userMessageText)) {
          // Display user message but mark it as flagged
          appendMessage("user", userMessageText);
          
          // Send censored response
          setTimeout(() => {
            const moderationResponse = "I'm designed to provide legal and professional assistance only. I cannot discuss topics related to intimate or adult content. Please keep our conversation professional and focused on legal document analysis and advice. How else can I assist you today?";
            appendMessage("bot", moderationResponse);
            
            // Add to chat history
            if (!chats[currentChatId].messages) {
              chats[currentChatId].messages = [];
            }
            chats[currentChatId].messages.push({
              sender: "user",
              content: userMessageText
            });
            chats[currentChatId].messages.push({
              sender: "bot",
              content: moderationResponse
            });
          }, 300);
          return;
        }
        
        // Append user message to chat
        appendMessage("user", userMessageText);
        
        // Add message to chat history
        if (!chats[currentChatId].messages) {
          chats[currentChatId].messages = [];
        }
        chats[currentChatId].messages.push({
          sender: "user",
          content: userMessageText
        });
        
        // Check for identity questions and provide canned response
        if (isIdentityQuestion(userMessageText)) {
          // Provide standard identity response
          const identityResponse = getIdentityResponse(userMessageText);
          setTimeout(() => {
            console.log("Responding with identity response:", identityResponse);
            appendMessage("bot", identityResponse);
          }, 300);
          return;
        }
        
        // Check if asking about which model is being used
        if (isModelQuestion(userMessageText)) {
          // Provide model information response
          const modelResponse = getModelResponse();
          setTimeout(() => {
            console.log("Responding with model information:", modelResponse);
            appendMessage("bot", modelResponse);
            
            // Add to chat history
            if (!chats[currentChatId].messages) {
              chats[currentChatId].messages = [];
            }
            chats[currentChatId].messages.push({
              sender: "user",
              content: userMessageText
            });
            chats[currentChatId].messages.push({
              sender: "bot",
              content: modelResponse
            });
          }, 300);
          return;
        }
        
        // Check for greeting messages
        if (isGreeting(userMessageText)) {
          // Provide greeting response
          const greetingResponse = getGreetingResponse();
          setTimeout(() => {
            console.log("Responding with greeting response:", greetingResponse);
            appendMessage("bot", greetingResponse);
          }, 300);
          return;
        }
        
        // Initialize variables before using them
          let conversationContext = "";
        let isContinuation = false;
        const hasDocuments = Object.keys(uploadedDocuments).length > 0;
        
        // Prepare conversation history for context if we have messages
          if (chats[currentChatId] && chats[currentChatId].messages) {
            // Check if this appears to be a continuation question
          isContinuation = isContinuationQuestion(userMessageText, chats[currentChatId].messages);
            
            // Get more context for continuations, otherwise use standard context length
          const contextLength = isContinuation ? 25 : 10;
            
            // Get recent messages for context, more if it's a continuation
            const recentMessages = chats[currentChatId].messages.slice(-contextLength);
            
            for (const msg of recentMessages) {
              if (msg.sender === "user") {
                conversationContext += "User: " + msg.content + "\n";
              } else if (msg.sender === "bot") {
                conversationContext += "Assistant: " + msg.content + "\n";
              }
            }
            
            console.log("Is continuation question:", isContinuation);
          }
        
        // Show typing indicator with a slight delay
        const typingIndicator = setTimeout(() => {
          // Get current model name
          const currentModel = modelConfig[activeModel].name;
          const currentEndpoint = modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex];
          let modelName = "legalmind(abbasgamer1)";
          
          // Create thinking message with model info and data attribute for animation
          const thinkingMessage = `
            <div class="thinking-expandable" data-thinking="true">
              <div class="thinking-header" onclick="toggleThinkingDetails(this)">
                <div class="thinking-title">
                  <i class="fas fa-brain thinking-brain"></i>
                  <span>${modelName} is thinking</span>
                  <div class="thinking-indicator"><span></span><span></span><span></span></div>
                </div>
                <button class="thinking-toggle" onclick="event.stopPropagation(); toggleThinkingDetails(this.parentNode)">
                  <i class="fas fa-chevron-down"></i>
                </button>
              </div>
              <div class="thinking-content">
                <span class="thinking-stage">Processing prompt...</span>
                <div class="thinking-prompts">
                  <strong>User Query:</strong> ${userMessageText}
                  
                  <strong>Model:</strong> ${modelName}
                  ${hasDocuments ? '<div style="margin-top: 8px;"><i class="fas fa-file-alt"></i> <strong>Documents:</strong> ' + Object.keys(uploadedDocuments).join(', ') + '</div>' : ''}
                  ${isContinuation ? '<div style="margin-top: 8px; color: #ff8c00;"><i class="fas fa-link"></i> <strong>Continuation detected:</strong> Maintaining conversation context</div>' : ''}
                </div>
              </div>
            </div>
          `;
          appendHtmlMessage("bot", thinkingMessage);
          
          // Reference to the thinking message to remove it later
          const thinkingMsg = document.querySelector(".message.bot:last-child");
          
          // Add the current query
          let continuityInstructions = isContinuation ? 
            "The user's current message appears to reference previous parts of the conversation. Be sure to maintain continuity and address any references to earlier messages or topics. " :
            "";
          
          let conciseInstructions = "Be concise in your responses. If the user asks for a detailed explanation or extensive answer, provide it. Otherwise, give brief, direct answers focusing on the key points or steps.";
          
          let fullPrompt = "You are LegalMind, a helpful assistant specializing in legal document analysis. " + 
                          continuityInstructions +
                          conciseInstructions + " " +
                          "Please respond to this query based on the conversation history:\n" + 
                          conversationContext + 
                          "User: " + userMessageText + "\nAssistant:";
          
          // If we're using the Gemma model, use its recommended format
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma")) {
            // Gemma format 
            fullPrompt = `<start_of_turn>user\n${userMessageText}<end_of_turn>\n<start_of_turn>model`;
            
            console.log("Using Gemma 3 model format");
          } else if (chatMessages && chatMessages.length > 0) {
            // ... existing code ...
          }
          
          console.log("Sending prompt:", fullPrompt);
          
          // Get document context if applicable
          const documentContext = getDocumentContext(userMessageText);
          let finalPrompt = fullPrompt;
          
          // Always include document context if available, regardless of the query
          if (hasDocuments) {
            if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma")) {
              // Gemma format 
              finalPrompt = `<start_of_turn>user\n${userMessageText}<end_of_turn>\n<start_of_turn>model`;
              
              console.log("Using Gemma 3 model format");
            } else {
              finalPrompt = 
                "You are LegalMind, a legal assistant that specializes in document analysis.\n\n" +
                conciseInstructions + "\n\n" +
                "User has uploaded the following document(s):" + 
                documentContext + 
                "\n\n" + conversationContext + 
                "User: " + userMessageText + "\n" +
                (isContinuation ? 
                  "This appears to be a follow-up question that may reference previous parts of the conversation. Maintain continuity and be sure to address references to earlier topics. " : "") +
                "Always analyze the document(s) in your response. Include a short section titled 'Document Summary' with key points, and a section titled 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness.\n" +
                "Assistant:";
            }
            
            console.log("Sending prompt with document context (length: " + finalPrompt.length + " chars)");
          }
          
          // Connect to the Hugging Face endpoint
          console.log("Making API request to:", modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex]);
          
          // Prepare API request parameters
          let requestParams = {
            max_new_tokens: 1024,
            temperature: 0.7,
            top_p: 0.95,
            do_sample: true,
            return_full_text: false
          };
          
          // Use DeepSeek's recommended parameters if using the DeepSeek model
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma")) {
            requestParams = {
              max_new_tokens: 1024,
              temperature: 0.3,  // Gemma recommends 0.3
              top_p: 0.8,
              do_sample: true
            };
          }
          
          // Create a timeout promise that will reject after 45 seconds
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error('API request timed out after 45 seconds'));
            }, 45000); // 45 seconds timeout
          });
          
          // Race between the fetch request and the timeout
          Promise.race([
            fetch(modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex], {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${modelConfig[activeModel].authTokens[modelConfig[activeModel].currentTokenIndex]}`
              },
              body: JSON.stringify({
                inputs: finalPrompt,
                parameters: requestParams
              })
            }),
            timeoutPromise
          ])
          .then(response => {
            console.log("API Response Status:", response.status);
            console.log("API Response Headers:", [...response.headers.entries()]);
            
            // Add a verification message to the console
            console.log("API REQUEST SENT SUCCESSFULLY - Waiting for response from: " + modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex]);
            
            if (!response.ok) {
              console.error("API Error:", response.status, response.statusText);
              // Try to get more error details
              return response.text().then(text => {
                console.error("API Error Details:", text);
                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
              });
            }
            return response.json();
          })
          .then(data => {
            // Remove the thinking message if it exists
            if (thinkingMsg && thinkingMsg.parentNode) {
              thinkingMsg.parentNode.removeChild(thinkingMsg);
            }
            
            // Log complete response data for debugging
            console.log("Complete API Response:", JSON.stringify(data));
            
            // Add bot response from the API
            let botResponse = ""; // Empty default
            
            // Specific handling for different response formats
            if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
              botResponse = data[0].generated_text.trim();
              console.log("Using array[0].generated_text format");
            } else if (data && data.generated_text) {
              botResponse = data.generated_text.trim();
              console.log("Using data.generated_text format");
            } else if (typeof data === 'string') {
              botResponse = data.trim();
              console.log("Using string format");
            } else if (data && data.choices && data.choices.length > 0) {
              // Handle OpenAI-like format
              botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
              console.log("Using OpenAI-like format");
            } else {
              console.warn("Unexpected API response format:", data);
              botResponse = "I apologize, but I received an unexpected response format. Please try again with your question.";
            }
            
            // If we are using the Gemma model, check response for any non-English part and format
            if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma") && botResponse) {
              // Remove any "Assistant:" prefix that might be in the response
              botResponse = botResponse.replace(/^Assistant:\s*/i, '');
              
              // If response starts with Chinese characters, try to find the first English part
              if (/^[\u4e00-\u9fa5]/.test(botResponse)) {
                const englishPart = botResponse.match(/[a-zA-Z]/);
                if (englishPart && englishPart.index > 0) {
                  botResponse = botResponse.substring(englishPart.index);
                }
              }
            }
            
            // Safety check for empty responses
            if (!botResponse) {
              botResponse = "I apologize, but I received an empty response. Please try asking your question again.";
            }
            
            // Add disclaimer for non-legal queries
            if (needsDisclaimer) {
              botResponse = "Note: I am not a professional in this field. This response is provided for informational purposes only.\n\n" + botResponse;
            }
            
            // Format the bot response to ensure proper line spacing for step-by-step explanations
            botResponse = botResponse
              // Add double line breaks after numbered steps (1., 2., etc.)
              .replace(/(\d+\..*?)(?=\s+\d+\.|\s*$)/g, '$1\n\n')
              // Add line breaks after "Step X:" format
              .replace(/(Step \d+:.*?)(?=\s+Step \d+:|\s*$)/g, '$1\n\n')
              // Ensure proper spacing between sections with headers
              .replace(/([A-Z][A-Za-z\s]+:)(?=\s+)/g, '\n\n$1\n')
              // Improve spacing for document sections
              .replace(/(Document Summary:|Document Improvement Suggestions:|Next Steps:)/g, '\n\n$1\n')
              // Replace single line breaks in paragraphs with double line breaks for better readability
              .replace(/(\.)(\s+)([A-Z])/g, '$1\n\n$3');
            
            // Check if it's a document analysis
            const isDocumentAnalysis = hasDocuments && 
                                      (userMessageText.toLowerCase().includes("analyze") || 
                                       userMessageText.toLowerCase().includes("review") ||
                                       userMessageText.toLowerCase().includes("summarize") ||
                                       userMessageText.toLowerCase().includes("improve") ||
                                       userMessageText.toLowerCase().includes("check") ||
                                       userMessageText.toLowerCase().includes("assess"));
            
            // Add document action buttons only if this is a document analysis
            if (botResponse && !botResponse.includes("I apologize") && hasDocuments && isDocumentAnalysis) {
              // Get the filename
              const filename = Object.keys(uploadedDocuments)[0]; // Use first document if multiple uploaded
              
              // Store the improvement suggestions for later use
              if (!window.documentImprovements) {
                window.documentImprovements = {};
              }
              window.documentImprovements[filename] = {
                original: uploadedDocuments[filename],
                suggestions: botResponse
              };
              
              // Append the main response
            appendMessage("bot", botResponse);
              
              // Add action buttons for document improvements
              const actionButtonsHtml = `
                <div class="document-action-buttons" style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                  <button onclick="implementImprovements('${filename}')" class="action-button primary-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--primary-color); color: white; border: none; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-magic"></i> Implement Suggestions
                  </button>
                  <button onclick="downloadOriginalDocument('${filename}')" class="action-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--light-bg); color: var(--text-color); border: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-download"></i> Download Original
                  </button>
                </div>
              `;
              
              // Create and append HTML content directly since appendHtmlMessage might not be defined
              const chatBox = document.getElementById('chatBox');
              if (chatBox) {
                const msgDiv = document.createElement("div");
                msgDiv.innerHTML = actionButtonsHtml;
                msgDiv.classList.add("message", "bot");
                
                // Check if we're at the bottom before adding the message
                const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
                
                // Append the message
                chatBox.appendChild(msgDiv);
                
                // Only auto-scroll if we were already at the bottom
                if (wasAtBottom) {
                    chatBox.scrollTo({
                        top: chatBox.scrollHeight,
                        behavior: 'smooth'
                    });
                }
                
                // Store in current chat if available
                if (currentChatId && chats[currentChatId]) {
                    if (!chats[currentChatId].messages) {
                        chats[currentChatId].messages = [];
                    }
                    chats[currentChatId].messages.push({
                        type: 'html',
                        sender: 'bot',
                        content: actionButtonsHtml
                    });
                }
              }
            } else {
              // For regular responses
              appendMessage("bot", botResponse);
            }
            
            // Add message to chat history
            if (chats[currentChatId] && chats[currentChatId].messages) {
              chats[currentChatId].messages.push({
                sender: "bot",
                content: botResponse
              });
              
              // Save chats to localStorage
              saveChatsToLocalStorage();
            }
          })
          .catch(error => {
            console.error("Error connecting to LegalMind API:", error);
            console.error("Full error details:", {
              message: error.message,
              stack: error.stack,
              endpoint: modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex]
            });
            
            // Specific handling for timeout errors
            if (error.message.includes('timed out')) {
              console.log("API request timed out - automatically trying next endpoint");
              showNotification("Model response timed out after 45 seconds. Trying next model...", "warning");
              
              // Automatically try the next endpoint or token
              if (tryNextEndpointOrToken(activeModel)) {
                const endpointInfo = getCurrentEndpointInfo(activeModel);
                console.log(`Switching to endpoint ${endpointInfo.endpointIndex} (${endpointInfo.endpoint}) after timeout`);
                
                // Remove the thinking message if it exists
                if (thinkingMsg && thinkingMsg.parentNode) {
                  thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                // Retry with new endpoint/token (after a short delay)
                setTimeout(() => {
                  // Reuse the same user message that's already been displayed
                  const messageInput = document.getElementById("messageInput");
                  messageInput.value = userMessageText;
                  sendMessage();
                }, 1000);
                return;
              }
            }
            
            // Try alternative endpoint or token for other errors
            if (tryNextEndpointOrToken(activeModel)) {
              const endpointInfo = getCurrentEndpointInfo(activeModel);
              console.log(`Switching to endpoint ${endpointInfo.endpointIndex} (${endpointInfo.endpoint}) after error`);
              
              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }
              
              // Retry with new endpoint/token (after a short delay)
              setTimeout(() => {
                // Reuse the same user message that's already been displayed
                const messageInput = document.getElementById("messageInput");
                messageInput.value = userMessageText;
                sendMessage();
              }, 1000);
              return;
            }
            
            // Remove the thinking message if it exists
            if (thinkingMsg && thinkingMsg.parentNode) {
              thinkingMsg.parentNode.removeChild(thinkingMsg);
            }
            
            // Check if it's an authorization error
            let errorMessage;
            if (error.message.includes("401") || error.message.includes("unauthorized")) {
              errorMessage = "Authentication error: Please check your API token.";
              showNotification("API Token error. Please update your authentication token.", "error");
            } else if (error.message.includes("429")) {
              errorMessage = "Rate limit exceeded. Please try again later.";
              showNotification("Too many requests. Please wait a moment.", "warning");
            } else if (error.message.includes("CORS") || error.message.includes("Failed to fetch")) {
              errorMessage = "Network error: CORS or connectivity issue. Please check your network settings or try the Test API Connection button.";
              showNotification("Network connectivity issue. Try the Test API Connection button.", "error");
            } else if (error.message.includes('timed out')) {
              errorMessage = "The model took too long to respond. I've tried all available models but none responded in time.";
              showNotification("All models timed out. Please try again later.", "error");
            } else {
              errorMessage = "I'm having trouble connecting to my knowledge base right now. Please try again later.";
              showNotification("Connection error to LegalMind API", "error");
            }
            
            // Fallback response in case of error
            appendMessage("bot", errorMessage);
            
            // Add error message to chat history
            if (chats[currentChatId] && chats[currentChatId].messages) {
              chats[currentChatId].messages.push({
                sender: "bot",
                content: errorMessage
              });
              
              // Save chats to localStorage
              saveChatsToLocalStorage();
            }
          });
          
        }, 300);
      } else if (!currentChatId) {
        // If no chat is active, create one and then send
        addNewChat();
        // Delay sending to ensure chat is created
        setTimeout(() => sendMessage(), 100);
      }
    }
    
    // Add bot message
    function addBotMessage(text) {
      const botMsg = { sender: "bot", text: text };
      chats[currentChatId].push(botMsg);
      appendMessage("bot", text);
    }
    
    // Save chats to localStorage
    function saveChatsToLocalStorage() {
      try {
        localStorage.setItem('legalMindChats', JSON.stringify(chats));
        localStorage.setItem('legalMindCurrentChat', currentChatId);
        console.log("Chats saved to localStorage");
      } catch (e) {
        console.error("Error saving chats to localStorage:", e);
      }
    }
    
    // Toggle dark mode
    function toggleDarkMode() {
      const isDarkMode = document.body.classList.toggle("dark-mode");
      const darkModeIcon = document.getElementById('darkModeIcon');
      const darkModeText = document.getElementById('darkModeText');
      
      if (isDarkMode) {
        localStorage.setItem('darkMode', 'enabled');
        if (darkModeIcon) {
          darkModeIcon.classList.remove('fa-moon');
          darkModeIcon.classList.add('fa-sun');
          darkModeText.textContent = 'Light Mode';
        }
      } else {
        localStorage.setItem('darkMode', 'disabled');
        if (darkModeIcon) {
          darkModeIcon.classList.remove('fa-sun');
          darkModeIcon.classList.add('fa-moon');
          darkModeText.textContent = 'Dark Mode';
        }
      }
    }

    function togglePlansDropdown(event) {
      event.preventDefault();
      const dropdown = document.getElementById("plansDropdown");
      dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";
      
      // Close other dropdowns
      document.getElementById("modelsDropdown").style.display = "none";
    }

    function toggleModelsDropdown(event) {
      event.preventDefault();
      const dropdown = document.getElementById("modelsDropdown");
      dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";
      
      // Close other dropdowns
      document.getElementById("plansDropdown").style.display = "none";
    }

    // Profile menu toggle and settings functionality
    document.addEventListener('DOMContentLoaded', function() {
      // Check for saved dark mode preference
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').checked = true;
      }
      
      // Profile menu toggle - fix for both mobile and desktop
      const profilePic = document.getElementById('profilePicNav');
      const profileMenu = document.getElementById('profileMenu');
      
      if (profilePic && profileMenu) {
        profilePic.addEventListener('click', function(e) {
          e.stopPropagation();
          profileMenu.classList.toggle('active');
        });
      }
      
      // Settings button
      const settingsButton = document.getElementById('settingsButton');
      const profileMainMenu = document.getElementById('profileMainMenu');
      const settingsPanel = document.getElementById('settingsPanel');
      
      if (settingsButton && profileMainMenu && settingsPanel) {
        settingsButton.addEventListener('click', function() {
          profileMainMenu.style.display = 'none';
          settingsPanel.classList.add('active');
        });
      }
      
      // Back to menu button
      const backToMenu = document.getElementById('backToMenu');
      if (backToMenu && profileMainMenu && settingsPanel) {
        backToMenu.addEventListener('click', function() {
          profileMainMenu.style.display = 'flex';
          settingsPanel.classList.remove('active');
        });
      }
      
      // Close profile menu when clicking outside
      document.addEventListener('click', function(event) {
        if (profileMenu && profileMenu.classList.contains('active')) {
          if (!event.target.closest('.nav-profile') && !event.target.closest('.profile-menu')) {
            profileMenu.classList.remove('active');
            // Reset to main menu view when closing
            if (profileMainMenu && settingsPanel) {
              profileMainMenu.style.display = 'flex';
              settingsPanel.classList.remove('active');
            }
          }
        }
      });
    });

    // Update the toggleSidebar function to properly handle document preview visibility
    function toggleSidebar() {
      const sidebar = document.querySelector('.sidebar');
      const documentsPreview = document.querySelector('.documents-preview');
      
      if (sidebar) {
        sidebar.classList.toggle('collapsed');
        
        if (sidebar.classList.contains('collapsed')) {
          if (documentsPreview) {
            documentsPreview.style.display = 'none';
          }
        } else {
          if (documentsPreview) {
            documentsPreview.style.display = 'flex';
            const documentPreviews = document.getElementById('documentPreviews');
            if (documentPreviews) {
              documentPreviews.style.display = 'block';
            }
          }
        }
      }
    }
    
    // Function to get or set username
    function getUserName() {
      // Check if we have a Firebase auth user
      const auth = firebase.auth();
      const user = auth.currentUser;
      
      if (user && user.displayName) {
        // Use Firebase display name
        const userName = user.displayName;
        console.log("Using Firebase displayName:", userName);
        
        // Update the profile display
        const profileUserName = document.getElementById('profileUserName');
        if (profileUserName) {
          profileUserName.textContent = userName;
        }
        
        return userName;
      } else if (user && user.email) {
        // If no display name, use email (without the domain part)
        const emailName = user.email.split('@')[0];
        console.log("Using email as name:", emailName);
        
        // Update the profile display
        const profileUserName = document.getElementById('profileUserName');
        if (profileUserName) {
          profileUserName.textContent = emailName;
        }
        
        return emailName;
      } else {
        // Fallback - this shouldn't happen with auth protection
        console.warn("No user found in Firebase auth, but page is loaded");
        return "there";
      }
    }

    function closeMobileMenu() {
      document.getElementById('mobileMenu').classList.remove('active');
      document.getElementById('mobileMenuOverlay').classList.remove('active');
    }

    function toggleDocumentPreview() {
      // For simplicity in mobile version, just toggle sidebar visibility
      const sidebar = document.querySelector('.sidebar');
      
      if (window.innerWidth <= 992) {
        // On mobile, show the sidebar which contains document preview
        if (sidebar.style.display === 'none' || sidebar.style.display === '') {
          sidebar.style.display = 'flex';
          sidebar.classList.remove('collapsed');
          
          // Make sure documents preview is visible
          const documentsPreview = document.querySelector('.documents-preview');
          if (documentsPreview) {
            documentsPreview.style.display = 'flex';
            const documentPreviews = document.getElementById('documentPreviews');
            if (documentPreviews) {
              documentPreviews.style.display = 'block';
            }
          }
        } else {
          sidebar.style.display = 'none';
        }
      } else {
        // On desktop, toggle collapsed state
        sidebar.classList.toggle('collapsed');
        
        if (sidebar.classList.contains('collapsed')) {
          const documentsPreview = document.querySelector('.documents-preview');
          if (documentsPreview) {
            documentsPreview.style.display = 'none';
          }
        } else {
          const documentsPreview = document.querySelector('.documents-preview');
          if (documentsPreview) {
            documentsPreview.style.display = 'flex';
            const documentPreviews = document.getElementById('documentPreviews');
            if (documentPreviews) {
              documentPreviews.style.display = 'block';
            }
          }
        }
      }
      
      closeMobileMenu();
    }

    // Function to update mobile chats list
    function updateMobileChats() {
      const todayContainer = document.getElementById('mobileTodayChats');
      const previousContainer = document.getElementById('mobilePreviousChats');
      
      // Clear containers
      todayContainer.innerHTML = '';
      previousContainer.innerHTML = '';
      
      // Get all chats from the sidebar chat list
      const chatList = document.getElementById('chatList');
      const chatItems = chatList.querySelectorAll('li');
      
      if (chatItems.length === 0) {
        // Add empty state message
        todayContainer.innerHTML = '<div class="mobile-chat-item">No recent chats</div>';
        return;
      }
      
      // For demo, we'll add all chats to "Today" section
      // In a real app, you would separate by date
      chatItems.forEach((item, index) => {
        const chatId = item.getAttribute('data-chat-id');
        const chatName = item.querySelector('span').textContent;
        const isActive = item.classList.contains('active');
        
        const mobileItem = document.createElement('div');
        mobileItem.className = 'mobile-chat-item' + (isActive ? ' active' : '');
        mobileItem.setAttribute('data-chat-id', chatId);
        
        // Create chat info and delete button
        mobileItem.innerHTML = `
          <div class="chat-info">
            <i class="fas fa-message"></i>
            <span>${chatName}</span>
          </div>
          <button class="delete-chat" aria-label="Delete chat">
            <i class="fas fa-times"></i>
          </button>
        `;
        
        // Add click event handler for the chat item
        const chatInfo = mobileItem.querySelector('.chat-info');
        chatInfo.addEventListener('click', function() {
          // Remove active class from all mobile chat items
          document.querySelectorAll('.mobile-chat-item').forEach(item => {
            item.classList.remove('active');
          });
          
          // Add active class to clicked item
          mobileItem.classList.add('active');
          
          // Update main chat list
          const chatItem = document.querySelector(`#chatList li[data-chat-id="${chatId}"]`);
          if (chatItem) {
            document.querySelectorAll('#chatList li').forEach(item => {
              item.classList.remove('active');
            });
            chatItem.classList.add('active');
          }
          
          // Load the chat
          loadChat(chatId, chatName);
          
          // Close mobile menu
          closeMobileMenu();
        });
        
        // Add delete button functionality
        const deleteBtn = mobileItem.querySelector('.delete-chat');
        deleteBtn.addEventListener('click', function(event) {
          event.stopPropagation();
          
          // Delete from main chat list
          const chatItem = document.querySelector(`#chatList li[data-chat-id="${chatId}"]`);
          if (chatItem) {
            const deleteEvent = new MouseEvent('click', {
              bubbles: true,
              cancelable: true,
              view: window
            });
            
            const mainDeleteButton = chatItem.querySelector('.delete-chat');
            if (mainDeleteButton) {
              mainDeleteButton.dispatchEvent(deleteEvent);
            }
          }
        });
        
        // Add to appropriate container based on index (just for demo)
        if (index < 2) {
          todayContainer.appendChild(mobileItem);
        } else {
          previousContainer.appendChild(mobileItem);
        }
      });
      
      // If no previous chats, add empty state
      if (previousContainer.children.length === 0) {
        previousContainer.innerHTML = '<div class="mobile-chat-item" style="opacity:0.6">No previous chats</div>';
      }
    }

    // Add event listener to close sidebar
    document.addEventListener('DOMContentLoaded', function() {
      const sidebarHeader = document.querySelector('.sidebar .chat-header');
      
      if (sidebarHeader) {
        sidebarHeader.addEventListener('click', function(e) {
          // Check if clicked on the X icon (after pseudo-element)
          const rect = sidebarHeader.getBoundingClientRect();
          const isClickAfter = e.clientX > rect.x + rect.width - 30;
          
          if (isClickAfter && window.innerWidth <= 992) {
            const sidebar = document.querySelector('.sidebar');
            sidebar.style.display = 'none';
          }
        });
      }
    });

    // Mobile menu interaction improvements
    document.addEventListener('DOMContentLoaded', function() {
      const menuToggle = document.getElementById('mobileMenuToggle');
      const mobileMenu = document.getElementById('mobileMenu');
      const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
      
      // Improved touch handling for mobile menu
      if (menuToggle && mobileMenu && mobileMenuOverlay) {
        // Add touch ripple effect
        menuToggle.addEventListener('touchstart', function() {
          this.classList.add('touch-active');
        });
        
        menuToggle.addEventListener('touchend', function() {
          this.classList.remove('touch-active');
          setTimeout(() => {
            mobileMenu.classList.add('active');
            mobileMenuOverlay.classList.add('active');
            updateMobileChats();
          }, 50);
        });
        
        // Add swipe to close functionality
        let startX = 0;
        mobileMenu.addEventListener('touchstart', function(e) {
          startX = e.touches[0].clientX;
        }, {passive: true});
        
        mobileMenu.addEventListener('touchmove', function(e) {
          if (startX > 20) { // Only if started from left edge area
            let diffX = e.touches[0].clientX - startX;
            if (diffX < 0) {
              mobileMenu.style.transform = `translateX(${diffX}px)`;
            }
          }
        }, {passive: true});
        
        mobileMenu.addEventListener('touchend', function(e) {
          let diffX = e.changedTouches[0].clientX - startX;
          if (diffX < -50) { // Swipe threshold
            closeMobileMenu();
          }
          mobileMenu.style.transform = '';
        }, {passive: true});
        
        // Add vibration feedback on menu interactions
        function vibrateIfAvailable(duration) {
          if ('vibrate' in navigator) {
            navigator.vibrate(duration);
          }
        }
        
        const allButtons = mobileMenu.querySelectorAll('.mobile-menu-btn, .mobile-chat-item');
        allButtons.forEach(btn => {
          btn.addEventListener('touchstart', () => vibrateIfAvailable(20), {passive: true});
        });
      }
    });

    // Updated previewFile function to auto-analyze uploaded documents
    function previewFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Reset the file input to allow reupload of the same file later
      const fileInput = document.getElementById('fileInput');
      if (fileInput) {
        // Use setTimeout to reset it after processing is complete
        setTimeout(() => {
          fileInput.value = '';
        }, 100);
      }
      
      // Ensure we have a chat to work with
      if (!currentChatId) {
        console.log("No active chat found, creating one...");
        addNewChat();
        // Wait a little for the chat to be created
        setTimeout(() => {
          processUpload(file);
        }, 300);
        return;
      }
      
      // Process the upload directly if we already have a chat
      processUpload(file);
    }
    
    // Separate function to process uploads to improve organization
    function processUpload(file) {
      // Process document content for analysis
      processDocumentContent(file);
      
      // For mobile devices, just show the file in the chat as a message
      if (window.innerWidth <= 992) {
        if (currentChatId) {
          // Add a file upload message with icon based on file type
          let fileIcon = 'fa-file';
          if (file.name.endsWith('.pdf')) fileIcon = 'fa-file-pdf';
          else if (file.name.endsWith('.txt')) fileIcon = 'fa-file-alt';
          else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) fileIcon = 'fa-file-word';
          else if (file.type.startsWith('image/')) fileIcon = 'fa-file-image';
          
          const fileMessage = `
            <div class="file-upload">
              <i class="fas ${fileIcon}"></i>
              <span>${file.name}</span>
            </div>
          `;
          
          // Create and append the HTML message
          appendHtmlMessage("user", fileMessage);
          
          // Add a notification message about the automatic analysis
          const analysisNotification = `
            <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
              <strong> Document uploaded:</strong> ${file.name}
              <div style="margin-top: 5px;">Automatically analyzing content to provide a summary...</div>
              <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
            </div>
          `;
          appendHtmlMessage("bot", analysisNotification);
          
          // Auto-analyze the document after a short delay
          setTimeout(() => {
            autoAnalyzeDocument(file.name);
          }, 1500);
        }
        return;
      }
      
      // Original desktop behavior below...
      const filePreview = document.getElementById("documentPreviews");
      
      // Clear welcome message if it exists
      const welcomeMessage = filePreview.querySelector('.empty-preview-message');
      if (welcomeMessage) {
        filePreview.removeChild(welcomeMessage);
      }
      
      // Make sure the document previews container is visible
      filePreview.style.display = 'block';
      
      // Update toggle button icon if needed
      const toggleBtn = document.getElementById('documentsToggle');
      if (toggleBtn && toggleBtn.querySelector('i').classList.contains('fa-chevron-down')) {
        toggleBtn.querySelector('i').classList.remove('fa-chevron-down');
        toggleBtn.querySelector('i').classList.add('fa-chevron-up');
      }
      
      // Create file item element
      const fileItem = document.createElement('div');
      fileItem.classList.add('file-item');
      fileItem.setAttribute('data-filename', file.name);
      
      // Create file header
      const fileHeader = document.createElement('div');
      fileHeader.className = 'file-header';
      
      // Create file name container
      const fileNameContainer = document.createElement('div');
      fileNameContainer.className = 'file-name';
      
      // Create file icon
      const fileIcon = document.createElement('i');
      fileIcon.classList.add('fas');
      
      // Set appropriate icon based on file type
      if (file.name.endsWith('.pdf')) {
        fileIcon.classList.add('fa-file-pdf');
        fileIcon.classList.add('pdf-icon');
      } else if (file.name.endsWith('.txt')) {
        fileIcon.classList.add('fa-file-alt');
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        fileIcon.classList.add('fa-file-word');
      } else {
        fileIcon.classList.add('fa-file');
      }
      
      // Create filename span
      const fileName = document.createElement('span');
      fileName.textContent = file.name;
      
      // Add icon and filename to the name container
      fileNameContainer.appendChild(fileIcon);
      fileNameContainer.appendChild(fileName);
      
      // Create delete button
      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = '<i class="fas fa-times"></i>';
      closeBtn.classList.add("delete-file");
      closeBtn.setAttribute('aria-label', 'Remove file');
      
      closeBtn.addEventListener("click", function(e) {
        e.stopPropagation();
        filePreview.removeChild(fileItem);
        
        // Delete from the uploadedDocuments object
        delete uploadedDocuments[file.name];
        console.log(`Deleted document: ${file.name}`);
        
        // Reset the file input to allow reupload
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
          fileInput.value = '';
        }
        
        // If no more files, show welcome message
        if (filePreview.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          filePreview.appendChild(welcomeText);
        }
      });
      
      // Add name container and delete button to header
      fileHeader.appendChild(fileNameContainer);
      fileHeader.appendChild(closeBtn);
      
      // Add header to file item
      fileItem.appendChild(fileHeader);
      
      // Add file preview for images and PDFs
      const fileType = file.type.split('/')[0];
      
      if (fileType === 'image' || file.name.endsWith('.pdf')) {
        const reader = new FileReader();
        reader.onload = function() {
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container';
          
          if (fileType === 'image') {
            const img = document.createElement('img');
            img.src = reader.result;
            img.alt = file.name;
            previewContainer.appendChild(img);
          } else if (file.name.endsWith('.pdf')) {
            previewContainer.classList.add('pdf-preview');
            const obj = document.createElement('object');
            obj.data = reader.result;
            obj.type = 'application/pdf';
            obj.width = '100%';
            obj.height = '200px';
            previewContainer.appendChild(obj);
          }
          
          fileItem.appendChild(previewContainer);
        };
        reader.readAsDataURL(file);
      }
      
      filePreview.appendChild(fileItem);
      
      // Force document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      previewSection.style.display = 'block';
      previewSection.style.visibility = 'visible';
      previewSection.style.opacity = '1';
      
      // If it's a chat context, add a message about the upload
      if (currentChatId) {
        // Add a file upload message with icon based on file type
        let fileIcon = 'fa-file';
        if (file.name.endsWith('.pdf')) fileIcon = 'fa-file-pdf';
        else if (file.name.endsWith('.txt')) fileIcon = 'fa-file-alt';
        else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) fileIcon = 'fa-file-word';
        else if (file.type.startsWith('image/')) fileIcon = 'fa-file-image';
        
        const fileMessage = `
          <div class="file-upload">
            <i class="fas ${fileIcon}"></i>
            <span>${file.name}</span>
          </div>
        `;
        
        appendHtmlMessage("user", fileMessage);
        
        // Auto-analyze the document after a short delay
        setTimeout(() => {
          autoAnalyzeDocument(file.name);
        }, 1500);
      }
    }
    
    // Function to automatically analyze a document after upload
    function autoAnalyzeDocument(filename) {
      if (!currentChatId) return;
      
      // Wait until the document is processed and available
      function checkAndAnalyze() {
        if (uploadedDocuments[filename]) {
          // Determine document type for customized analysis
          const fileType = getFileType(filename);
          
          // Customize analysis message based on file type
          let analysisMessage = `Please analyze the document ${filename} I just uploaded. Provide a summary and suggestions for improvement.`;
          
          // Add the message to chat history
          if (!chats[currentChatId].messages) {
            chats[currentChatId].messages = [];
          }
          
          chats[currentChatId].messages.push({
            sender: "user",
            content: analysisMessage
          });
          
          // Append a message saying the document is being analyzed
          appendMessage("bot", `I'm analyzing ${filename}. Here's what I found:`);
          
          // Create a thinking message
          const thinkingMsg = document.querySelector(".message.bot:last-child");
          
          // Get document context - make sure it includes the full document content
          const documentText = uploadedDocuments[filename];
          const documentContext = `\n\n--- DOCUMENT: ${filename} ---\n${documentText}\n--- END OF DOCUMENT ---\n\n`;
          
          // Prepare the prompt based on which model is active and file type
          let analysisPrompt;
          const today = new Date();
          const formattedDate = today.toLocaleDateString('en-US', { 
            month: 'long', 
            day: 'numeric',
            weekday: 'long' 
          });
          
          // Customize prompt based on file type
          let fileTypePrompt = "";
          if (fileType === "pdf" || fileType === "docx" || fileType === "doc") {
            fileTypePrompt = "For this legal document: Evaluate its legal soundness, identify potential loopholes, suggest stronger legal language, and note any missing clauses that should be included.";
          } else if (fileType === "txt") {
            fileTypePrompt = "For this text document: Focus on organization, clarity, and structural improvements. Check for inconsistent terminology and logical flow.";
          } else if (fileType === "image") {
            fileTypePrompt = "For this OCR-extracted text: Note any potential errors in text recognition, evaluate the document structure, and suggest improvements to both content and formatting.";
          }
          
          // Get current model endpoint info
          const currentEndpointInfo = getCurrentEndpointInfo(activeModel);
          
          // Create appropriate prompt based on the model
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma")) {
            // Gemma format
            analysisPrompt = `<start_of_turn>user
I need you to analyze the following document:

${documentContext}

Please analyze this document in detail and provide feedback.
${fileTypePrompt}

Please include these sections in your response:
1. 'Document Summary' with key points
2. 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness
3. 'Next Steps' with 2-3 recommendations on what the user should do next with this document
<end_of_turn>
<start_of_turn>model`;
          } else {
            analysisPrompt = 
              "You are LegalMind, a legal assistant that specializes in document analysis.\n\n" +
              "User has uploaded the following document:" + 
              documentContext + 
              "\n\nUser: Please analyze this document in detail and provide feedback.\n" +
              `${fileTypePrompt}\n` +
              "Always include these sections in your response:\n" +
              "1. 'Document Summary' with key points\n" +
              "2. 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness\n" +
              "3. 'Next Steps' with 2-3 recommendations on what the user should do next with this document\n" +
              "Assistant:";
          }
          
          // Prepare API request parameters
          let requestParams = {
            max_new_tokens: 1024,
            temperature: 0.7,
            top_p: 0.95,
            do_sample: true,
            return_full_text: false
          };
          
          // Use model-specific parameters if needed
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma")) {
            requestParams = {
              max_new_tokens: 2048,  // Increased for Gemma 3 12B
              temperature: 0.2,  // Lower temperature for more focused responses
              top_p: 0.9,
              do_sample: true
            };
          }
          
          // Create a timeout promise that will reject after 45 seconds
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error('API request timed out after 45 seconds'));
            }, 45000); // 45 seconds timeout
          });
          
          console.log("Sending document analysis request to API...");
          console.log("Document length:", documentText.length);
          console.log("Using endpoint:", currentEndpointInfo.endpoint);
          
          // Race between the fetch request and the timeout
          Promise.race([
            fetch(modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex], {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${modelConfig[activeModel].authTokens[modelConfig[activeModel].currentTokenIndex]}`
              },
              body: JSON.stringify({
                inputs: analysisPrompt,
                parameters: requestParams
              })
            }),
            timeoutPromise
          ])
          .then(response => {
            if (!response.ok) {
              return response.text().then(text => {
                console.error(`API request failed with status ${response.status}: ${response.statusText}`, text);
                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
              });
            }
            return response.json();
          })
          .then(data => {
            console.log("Received API response:", data);
            
            // Remove the thinking message if it exists
            if (thinkingMsg && thinkingMsg.parentNode) {
              thinkingMsg.parentNode.removeChild(thinkingMsg);
            }
            
            // Add bot response from the API
            let botResponse = ""; // Empty default
            
            // Specific handling for different response formats
            if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
              botResponse = data[0].generated_text.trim();
            } else if (data && data.generated_text) {
              botResponse = data.generated_text.trim();
            } else if (typeof data === 'string') {
              botResponse = data.trim();
            } else if (data && data.choices && data.choices.length > 0) {
              // Handle OpenAI-like format
              botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
            } else {
              botResponse = "I apologize, but I received an unexpected response format. Please try asking directly about the document.";
              console.error("Unexpected API response format:", data);
            }
            
            // Format response from different model types
            if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("gemma") && botResponse) {
              // Remove any "Assistant:" prefix that might be in the response
              botResponse = botResponse.replace(/^Assistant:\s*/i, '');
              
              // If response starts with non-English characters, try to find the first English part
              if (/^[\u4e00-\u9fa5]/.test(botResponse)) {
                const englishPart = botResponse.match(/[a-zA-Z]/);
                if (englishPart && englishPart.index > 0) {
                  botResponse = botResponse.substring(englishPart.index);
                }
              }
            }
            
            // Safety check for empty responses
            if (!botResponse || botResponse.trim() === '') {
              botResponse = "I apologize, but I couldn't analyze the document properly. Please ask me specific questions about it.";
              console.error("Empty response from API");
            }
            
            // Add document download/update buttons if analysis is successful
            if (botResponse && !botResponse.includes("I apologize")) {
              // Store the improvement suggestions for later use
              if (!window.documentImprovements) {
                window.documentImprovements = {};
              }
              window.documentImprovements[filename] = {
                original: uploadedDocuments[filename],
                suggestions: botResponse
              };
              
              // Append the main response
            appendMessage("bot", botResponse);
              
              // Add action buttons for document improvements
              const actionButtonsHtml = `
                <div class="document-action-buttons" style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                  <button onclick="implementImprovements('${filename}')" class="action-button primary-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--primary-color); color: white; border: none; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-magic"></i> Implement Suggestions
                  </button>
                  <button onclick="downloadOriginalDocument('${filename}')" class="action-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--light-bg); color: var(--text-color); border: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-download"></i> Download Original
                  </button>
                </div>
              `;
              
              // Create and append HTML content directly since appendHtmlMessage might not be defined
              const chatBox = document.getElementById('chatBox');
              if (chatBox) {
                const msgDiv = document.createElement("div");
                msgDiv.innerHTML = actionButtonsHtml;
                msgDiv.classList.add("message", "bot");
                
                // Check if we're at the bottom before adding the message
                const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
                
                // Append the message
                chatBox.appendChild(msgDiv);
                
                // Only auto-scroll if we were already at the bottom
                if (wasAtBottom) {
                    chatBox.scrollTo({
                        top: chatBox.scrollHeight,
                        behavior: 'smooth'
                    });
                }
                
                // Store in current chat if available
                if (currentChatId && chats[currentChatId]) {
                    if (!chats[currentChatId].messages) {
                        chats[currentChatId].messages = [];
                    }
                    chats[currentChatId].messages.push({
                        type: 'html',
                        sender: 'bot',
                        content: actionButtonsHtml
                    });
                }
              }
            } else {
              appendMessage("bot", botResponse);
            }
          })
          .catch(error => {
            console.error("Error analyzing document:", error);
            
            // Remove the thinking message if it exists
            if (thinkingMsg && thinkingMsg.parentNode) {
              thinkingMsg.parentNode.removeChild(thinkingMsg);
            }
            
            // Try a fallback approach - simplify the prompt
            const fallbackPrompt = `Please provide a brief summary of this document: ${filename}\n\nContent: ${documentText.substring(0, 5000)}${documentText.length > 5000 ? '... (truncated)' : ''}`;
            
            console.log("Trying fallback document analysis with simpler prompt");
            
            // Fallback API request
            fetch(modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex], {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${modelConfig[activeModel].authTokens[modelConfig[activeModel].currentTokenIndex]}`
              },
              body: JSON.stringify({
                inputs: fallbackPrompt,
                parameters: {
                  max_new_tokens: 512,
                  temperature: 0.3,
                  top_p: 0.95,
                  do_sample: true,
                  return_full_text: false
                }
              })
            })
            .then(response => response.json())
            .then(data => {
              let fallbackResponse = "";
              
              if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                fallbackResponse = data[0].generated_text.trim();
              } else if (data && data.generated_text) {
                fallbackResponse = data.generated_text.trim();
              } else if (data && data.choices && data.choices.length > 0) {
                fallbackResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
              } else {
                throw new Error("Unexpected response format in fallback");
              }
              
              if (fallbackResponse) {
                appendMessage("bot", `Here's a brief summary of the document:\n\n${fallbackResponse}`);
              } else {
                appendMessage("bot", "I'm having trouble analyzing this document. Please ask me specific questions about its content.");
              }
            })
            .catch(fallbackError => {
              console.error("Fallback document analysis also failed:", fallbackError);
              appendMessage("bot", "I'm having trouble analyzing this document right now. You can try asking me specific questions about the content or try uploading it again later.");
            });
          });
        } else {
          // If document not yet available, wait and check again
          setTimeout(checkAndAnalyze, 500);
        }
      }
      
      // Start checking for document
      checkAndAnalyze();
    }
    
    // Helper function to determine file type for customized analysis
    function getFileType(filename) {
      if (filename.endsWith('.pdf')) return "pdf";
      if (filename.endsWith('.docx') || filename.endsWith('.doc')) return "doc";
      if (filename.endsWith('.txt')) return "txt";
      if (filename.match(/\.(jpg|jpeg|png|gif)$/i)) return "image";
      return "other";
    }

    // Simple scroll-to-bottom button handler
    document.addEventListener('DOMContentLoaded', function() {
      const chatBox = document.getElementById('chatBox');
      const scrollBottomBtn = document.getElementById('scrollBottomBtn');
      
      if (!chatBox || !scrollBottomBtn) return;
      
      // Simple scroll position check
      chatBox.addEventListener('scroll', function() {
        // Show button when not at bottom (with small threshold)
        const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
        
        if (isAtBottom) {
          scrollBottomBtn.classList.remove('visible');
        } else {
          scrollBottomBtn.classList.add('visible');
        }
      });
      
      // Simple click handler for scroll button
      scrollBottomBtn.addEventListener('click', function() {
        chatBox.scrollTo({
          top: chatBox.scrollHeight,
          behavior: 'smooth'
        });
      });
    });

    // Function to test API connection
    function testAPIConnection() {
      const model = modelConfig.legalMind;
      const endpoint = model.endpoints[model.currentEndpointIndex];
      const token = model.authTokens[model.currentTokenIndex];
      
      console.log("Testing API connection to:", endpoint);
      console.log("Using token index:", model.currentTokenIndex);
      
      // Show testing notification
      showNotification(`Testing API connection to endpoint ${model.currentEndpointIndex}...`, "info");
      
      // Check if token appears valid
      if (!token || !token.startsWith('hf_') || token.length < 10) {
        console.error("API Token appears invalid:", token);
        showNotification("API token appears invalid. Check console for details.", "error");
        return;
      }
      
        // Create a timeout promise that will reject after 45 seconds
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
                reject(new Error('API request timed out after 45 seconds'));
            }, 45000); // 45 seconds timeout
      });
      
      // Race between the fetch request and the timeout
      Promise.race([
        // Make a simple test request
        fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({
            inputs: "Hello, can you give me a very brief response to test the connection?",
            parameters: {
              max_new_tokens: 50,
              temperature: 0.7,
              top_p: 0.95,
              do_sample: true,
              return_full_text: false
            }
          })
        }),
        timeoutPromise
      ])
      .then(response => {
        console.log("Test API Status:", response.status);
        console.log("Test API Headers:", [...response.headers.entries()]);
        
        if (!response.ok) {
          return response.text().then(text => {
            console.error("Test API Error Details:", text);
            showNotification(`API connection failed (${response.status}): ${response.statusText}`, "error");
            
            // Try next endpoint or token
            if (tryNextEndpointOrToken("legalMind")) {
              setTimeout(testAPIConnection, 1000);
            }
            
            return null;
          });
        }
        return response.json();
      })
      .then(data => {
        if (data) {
          console.log("Test API Success:", data);
          
          // Display the actual response in the notification
          let responseText = "";
          if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
            responseText = data[0].generated_text.substring(0, 50); // First 50 chars
          } else if (data && data.generated_text) {
            responseText = data.generated_text.substring(0, 50);
          } else {
            responseText = JSON.stringify(data).substring(0, 50);
          }
          
          showNotification(`API connection successful! Response: "${responseText}..."`, "success");
          
          // Also append result to chat if a chat is active
          if (currentChatId) {
            let successMessage = `API Test Result: Connection successful! Using endpoint ${model.currentEndpointIndex} and token ${model.currentTokenIndex}.`;
            
                        // If we're using the Gemma model, indicate this in the message
                        if (model.currentEndpointIndex === model.endpoints.length - 1) {
                            successMessage = "API Test Result: Connection successful using fallback model. The original model endpoints are not available, but this alternative will work.";
            }
            
            appendMessage("bot", successMessage);
          }
        }
      })
      .catch(error => {
        console.error("Test API Error:", error);
        
        // Specific handling for timeout errors
        if (error.message.includes('timed out')) {
          console.log("Test API request timed out - trying next endpoint");
          showNotification("Test API connection timed out. Trying next model...", "warning");
          
          // Try next endpoint or token
          if (tryNextEndpointOrToken("legalMind")) {
            setTimeout(testAPIConnection, 1000);
          } else {
            showNotification("All models timed out during testing. Please try again later.", "error");
          }
          return;
        }
        
        showNotification("API connection error: " + error.message, "error");
        
        // Try next endpoint or token for other errors
        if (tryNextEndpointOrToken("legalMind")) {
          setTimeout(testAPIConnection, 1000);
        }
      });
    }

    // Add a button to test the connection - button removed per user request
    document.addEventListener('DOMContentLoaded', function() {
      // No buttons added to UI
    });

    // Add buttons to test the connection and wake up the endpoint - buttons removed per user request
    document.addEventListener('DOMContentLoaded', function() {
      // No buttons added to UI
    });

    // Function to process document content
    function processDocumentContent(file) {
      console.log("Processing document:", file.name);
      showNotification("Processing document: " + file.name, "info");
      
      if (file.name.endsWith('.pdf')) {
        extractTextFromPDF(file)
          .then(text => {
            console.log("Extracted PDF text length:", text.length);
            uploadedDocuments[file.name] = text;
            showNotification("PDF processed successfully", "success");
          })
          .catch(error => {
            console.error("Error extracting PDF text:", error);
            showNotification("Error processing PDF", "error");
          });
      } else if (file.name.endsWith('.txt')) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const text = e.target.result;
          uploadedDocuments[file.name] = text;
          console.log("Processed text file:", file.name);
          showNotification("Text file processed successfully", "success");
        };
        reader.onerror = function() {
          console.error("Error reading text file");
          showNotification("Error processing text file", "error");
        };
        reader.readAsText(file);
      } else if (file.type.startsWith('image/')) {
        // For images, just store a placeholder
        uploadedDocuments[file.name] = "[Image: " + file.name + "]";
        showNotification("Image added to conversation", "success");
      } else {
        // For other files, store a note that they can't be processed
        uploadedDocuments[file.name] = "[File type not supported for content extraction: " + file.name + "]";
        showNotification("File type not supported for content processing", "warning");
      }
    }
    
    // Function to extract text from PDF
    async function extractTextFromPDF(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = async function(e) {
          const typedArray = new Uint8Array(e.target.result);
          
          try {
            // Load the PDF document
            const loadingTask = pdfjsLib.getDocument(typedArray);
            const pdf = await loadingTask.promise;
            
            let fullText = "";
            
            // Loop through each page to extract text
            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              
              // Extract the text items
              const pageText = textContent.items.map(item => item.str).join(' ');
              fullText += pageText + "\n\n"; // Add page breaks
            }
            
            resolve(fullText);
          } catch (error) {
            console.error("PDF.js error:", error);
            reject(error);
          }
        };
        
        reader.onerror = function() {
          reject(new Error("Error reading the file"));
        };
        
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Function to get document summary for the prompt
    function getDocumentSummary() {
      let summary = "";
      
      // Add a list of available documents
      const documentList = Object.keys(uploadedDocuments);
      if (documentList.length > 0) {
        summary += "\n\nAvailable documents:\n";
        documentList.forEach(filename => {
          summary += `- ${filename}\n`;
        });
      }
      
      return summary;
    }

    // Function to get document context for the prompt
    function getDocumentContext(messageText) {
      // Look for document references in the message
      const documentList = Object.keys(uploadedDocuments);
      let context = "";
      
      if (documentList.length === 0) {
        return context; // No documents uploaded
      }
      
      // Always include document context by default
      // Check if we need to include all documents or specific ones
      const messageLower = messageText.toLowerCase();
      const mentionedDocuments = documentList.filter(filename => 
        messageLower.includes(filename.toLowerCase())
      );
      
      const documentsToInclude = mentionedDocuments.length > 0 ? 
        mentionedDocuments : documentList;
      
      // Add relevant document content with clear delimiters
      documentsToInclude.forEach(filename => {
        let docContent = uploadedDocuments[filename];
        
        // Truncate very large documents (limit to ~10,000 chars)
        if (docContent.length > 10000) {
          docContent = docContent.substring(0, 10000) + 
            "\n\n[Document content truncated due to length. This is only a portion of the full document.]";
        }
        
        context += `\n\n--- DOCUMENT: ${filename} ---\n`;
        context += docContent;
        context += "\n--- END OF DOCUMENT ---\n\n";
      });
      
      return context;
    }

    // Helper function to get current endpoint info
    function getCurrentEndpointInfo(modelKey) {
      if (!modelConfig[modelKey]) return null;
      
      const config = modelConfig[modelKey];
      return {
        endpoint: config.endpoints[config.currentEndpointIndex],
        endpointIndex: config.currentEndpointIndex,
        token: config.authTokens[config.currentTokenIndex],
        tokenIndex: config.currentTokenIndex
      };
    }
    
    // Function to try the next endpoint or token
    function tryNextEndpointOrToken(modelKey) {
      if (!modelConfig[modelKey]) return false;
      
      const config = modelConfig[modelKey];
      const currentEndpoint = config.endpoints[config.currentEndpointIndex];
      const currentToken = config.authTokens[config.currentTokenIndex];
      
      // Try next endpoint first
      config.currentEndpointIndex = (config.currentEndpointIndex + 1) % config.endpoints.length;
      const newEndpoint = config.endpoints[config.currentEndpointIndex];
      
      console.log(`Switching from endpoint ${currentEndpoint} to ${newEndpoint}`);
      
      // Show appropriate notification based on which endpoint we're switching to
      if (newEndpoint.includes("mistral")) {
        showNotification("Switching to Mistral 7B model for faster response", "info");
      } else if (newEndpoint.includes("legalmind") || newEndpoint.includes("Abbasgamer1")) {
        showNotification("Switching to LegalMind specialized model", "info");
      } else if (newEndpoint.includes("gemma")) {
        showNotification("Switching to Gemma model", "info");
      } else {
        showNotification("Trying alternative model endpoint...", "info");
      }
      
      // If we've cycled through all endpoints, try the next token
      if (config.currentEndpointIndex === 0) {
        const prevToken = config.authTokens[config.currentTokenIndex];
        config.currentTokenIndex = (config.currentTokenIndex + 1) % config.authTokens.length;
        console.log(`Switching from token ${prevToken} to ${config.authTokens[config.currentTokenIndex]}`);
        
        showNotification("Trying alternative API token...", "info");
        
        // If we've cycled through all tokens, return false to indicate we've tried everything
        if (config.currentTokenIndex === 0) {
          showNotification("All models and tokens attempted without success. Please try again later.", "error");
          return false;
        }
      }
      
      return true;
    }

    // Function to wake up a scaled-to-zero endpoint
    function wakeUpEndpoint() {
      const model = modelConfig.legalMind;
      // Force using the first endpoint (AWS endpoint) which is scaled to zero
      model.currentEndpointIndex = 0;
      model.currentTokenIndex = 0;
      
      const endpoint = model.endpoints[0];
      const token = model.authTokens[0];
      
      console.log("Attempting to wake up endpoint:", endpoint);
      showNotification("Attempting to wake up endpoint...", "info");
      
      // Create a timeout promise that will reject after 45 seconds
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Wake up request timed out after 45 seconds'));
        }, 45000); // 45 seconds timeout
      });
      
      // Race between the fetch request and the timeout
      Promise.race([
        // Make a simple test request to wake it up
        fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({
            inputs: "Wake up",
            parameters: {
              max_new_tokens: 10,
              temperature: 0.7,
              do_sample: true
            }
          })
        }),
        timeoutPromise
      ])
      .then(response => {
        console.log("Wake up status:", response.status);
        
        if (!response.ok) {
          return response.text().then(text => {
            console.error("Wake up details:", text);
            
            if (text.includes("scaled to zero") || response.status === 503) {
              showNotification("Endpoint is scaled to zero. It may take a few minutes to wake up.", "warning");
              if (currentChatId) {
                appendMessage("bot", "The endpoint is currently inactive (scaled to zero). I've sent a wake-up request. It may take 1-2 minutes to start. Please try again shortly.");
              }
            } else {
              showNotification(`Wake up request failed: ${response.status}`, "error");
            }
            return null;
          });
        }
        
        showNotification("Endpoint is waking up! Try your request again in a moment.", "success");
        if (currentChatId) {
          appendMessage("bot", "The endpoint is waking up! Please try your request again in about 30 seconds.");
        }
        return response.json();
          })
          .catch(error => {
        console.error("Wake up error:", error);
        
        // Specific handling for timeout errors
        if (error.message.includes('timed out')) {
          showNotification("Wake up request timed out. The endpoint may be unavailable.", "warning");
          if (currentChatId) {
            appendMessage("bot", "The wake up request timed out. The endpoint appears to be unavailable. I'll automatically try alternative models for your requests.");
          }
          return;
        }
        
        showNotification("Error sending wake up request: " + error.message, "error");
      });
    }

    // Function to check if message is a greeting
    function isGreeting(text) {
      const lowerText = text.toLowerCase().trim();
      
      const greetingPatterns = [
        /^hi$/,
        /^hello$/,
        /^hey$/,
        /^greetings$/,
        /^hi there$/,
        /^hello there$/,
        /^hey there$/,
        /^howdy$/,
        /^good morning$/,
        /^good afternoon$/,
        /^good evening$/
      ];
      
      return greetingPatterns.some(pattern => pattern.test(lowerText));
    }
    
    // Function to get greeting response
    function getGreetingResponse() {
      return "Hello! I'm LegalMind, your AI legal assistant. I specialize in analyzing legal documents and providing insights. To get the most out of our conversation, please upload your document using the paperclip icon or images with text using the camera icon. I can read and analyze the content, provide a summary, and suggest improvements.";
    }

    // Function to process image and extract text using OCR
    function processImage(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Reset the image input to allow reupload of the same file later
      const imageInput = document.getElementById('imageInput');
      if (imageInput) {
        // Use setTimeout to reset it after processing is complete
        setTimeout(() => {
          imageInput.value = '';
        }, 100);
      }
      
      // Check if it's actually an image
      if (!file.type.startsWith('image/')) {
        showNotification("Please select a valid image file (PNG, JPG, JPEG)", "error");
        return;
      }
      
      // Ensure we have a chat to work with
      if (!currentChatId) {
        console.log("No active chat found, creating one...");
        addNewChat();
        // Wait a little for the chat to be created
        setTimeout(() => {
          processImageWithOCR(file);
        }, 300);
        return;
      }
      
      // Process the image directly if we already have a chat
      processImageWithOCR(file);
    }
    
    // Separate function to process images with OCR
    function processImageWithOCR(file) {
      showNotification("Processing image: " + file.name, "info");
      
      // For mobile devices, show the image in the chat
      if (window.innerWidth <= 992) {
        if (currentChatId) {
          // Add a file upload message with camera icon
          const fileMessage = `
            <div class="file-upload">
              <i class="fas fa-camera"></i>
              <span>${file.name}</span>
            </div>
          `;
          
          // Create and append the HTML message
          appendHtmlMessage("user", fileMessage);
          
          // Add a notification message about the automatic OCR processing
          const ocrNotification = `
            <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
              <strong> Image uploaded:</strong> ${file.name}
              <div style="margin-top: 5px;">Extracting text with OCR and analyzing content...</div>
              <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
            </div>
          `;
          appendHtmlMessage("bot", ocrNotification);
        }
      }
      
      // Desktop and mobile: Process the image with OCR
      const reader = new FileReader();
      reader.onload = function(e) {
        const imageUrl = e.target.result;
        console.log("Starting OCR processing for image:", file.name);
        
        // Add a loading message
        let ocrLoadingMsg;
        if (currentChatId) {
          appendMessage("bot", "Reading text from image...");
          ocrLoadingMsg = document.querySelector(".message.bot:last-child");
        }
        
        // Process with Tesseract.js
        Tesseract.recognize(
          imageUrl,
          'eng', // English language
          { 
            logger: info => {
              console.log(info);
              if (info.status === 'recognizing text' && info.progress < 1) {
                // Update the loading message with progress
                if (ocrLoadingMsg) {
                  ocrLoadingMsg.textContent = `Reading text from image... ${Math.round(info.progress * 100)}%`;
                }
              }
            }
          }
        ).then(({ data: { text } }) => {
          console.log("Extracted text from image:", text ? text.substring(0, 100) + "..." : "No text found");
          
          // Remove the loading message
          if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
            ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
          }
          
          if (!text || text.trim() === '') {
            showNotification("No text could be detected in the image", "warning");
            appendMessage("bot", "I couldn't detect any text in this image. Please try with a clearer image or upload a text document instead.");
            return;
          }
          
          // Store the extracted text in uploadedDocuments
          uploadedDocuments[file.name] = text;
          showNotification("Image text extracted successfully", "success");
          
          // Add the extracted text to the document preview panel
          const filePreview = document.getElementById("documentPreviews");
          
          // Clear welcome message if it exists
          const welcomeMessage = filePreview.querySelector('.empty-preview-message');
          if (welcomeMessage) {
            filePreview.removeChild(welcomeMessage);
          }
          
          // Create file item element for the document preview
          const fileItem = document.createElement('div');
          fileItem.classList.add('file-item');
          fileItem.setAttribute('data-filename', file.name);
          
          // Create file header
          const fileHeader = document.createElement('div');
          fileHeader.className = 'file-header';
          
          // Create file name container
          const fileNameContainer = document.createElement('div');
          fileNameContainer.className = 'file-name';
          
          // Create file icon (camera for images)
          const fileIcon = document.createElement('i');
          fileIcon.classList.add('fas', 'fa-camera');
          
          // Create filename span
          const fileName = document.createElement('span');
          fileName.textContent = `${file.name} (OCR text)`;
          
          // Add icon and filename to the name container
          fileNameContainer.appendChild(fileIcon);
          fileNameContainer.appendChild(fileName);
          
          // Create delete button
          const closeBtn = document.createElement("button");
          closeBtn.innerHTML = '<i class="fas fa-times"></i>';
          closeBtn.classList.add("delete-file");
          closeBtn.setAttribute('aria-label', 'Remove file');
          
          closeBtn.addEventListener("click", function(e) {
            e.stopPropagation();
            filePreview.removeChild(fileItem);
            
            // Delete from the uploadedDocuments object
            delete uploadedDocuments[file.name];
            console.log(`Deleted document: ${file.name}`);
            
            // Reset the file input to allow reupload
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
              fileInput.value = '';
            }
            
            // If no more files, show welcome message
            if (filePreview.children.length === 0) {
              const welcomeText = document.createElement('p');
              welcomeText.className = 'empty-preview-message';
              welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
              filePreview.appendChild(welcomeText);
            }
          });
          
          // Add name container and delete button to header
          fileHeader.appendChild(fileNameContainer);
          fileHeader.appendChild(closeBtn);
          
          // Add header to file item
          fileItem.appendChild(fileHeader);
          
          // Create a text preview for the OCR content
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container ocr-preview';
          
          // Add a textarea with the OCR text - using CSS classes instead of inline styles
          const textPreview = document.createElement('textarea');
          textPreview.readOnly = true;
          textPreview.value = text;
          
          previewContainer.appendChild(textPreview);
          fileItem.appendChild(previewContainer);
          
          filePreview.appendChild(fileItem);
          
          // Force document preview section visible
          const previewSection = document.querySelector('.documents-preview');
          previewSection.style.display = 'block';
          previewSection.style.visibility = 'visible';
          previewSection.style.opacity = '1';
          
          // Now auto-analyze the extracted text with a prominent notification
          if (currentChatId) {
            console.log("OCR completed, starting auto-analysis for:", file.name);
            
            // Replace any existing loading message with a notification about analysis
            if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
              ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
            }
            
            // Add an OCR completion notification
            const analysisNotification = `
              <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
                <strong> OCR completed:</strong> Successfully extracted text from ${file.name}
                <div style="margin-top: 5px;">Now analyzing the content to provide a summary...</div>
                <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
              </div>
            `;
            appendHtmlMessage("bot", analysisNotification);
          
            // Call autoAnalyzeDocument with a delay to ensure the notification is displayed
          setTimeout(() => {
              try {
            autoAnalyzeDocument(file.name);
              } catch (error) {
                console.error("Error triggering document analysis:", error);
                // Fallback to show a direct message with the extracted text
                appendMessage("bot", `I've extracted the following text from your image. You can ask me specific questions about it:\n\n${text.length > 500 ? text.substring(0, 500) + "..." : text}`);
              }
          }, 1000);
          }
        }).catch(error => {
          console.error("OCR Error:", error);
          showNotification("Error processing image text", "error");
          
          // Remove the loading message
          if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
            ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
          }
          
          if (currentChatId) {
            appendMessage("bot", "I encountered an error processing the text in this image. Please try again with a clearer image or upload a text document instead.");
          }
        });
      };
      
      reader.onerror = function() {
        console.error("Error reading image file");
        showNotification("Error processing image", "error");
      };
      
      reader.readAsDataURL(file);
    }

    // Simple scroll-to-bottom button handler
    document.addEventListener('DOMContentLoaded', function() {
      const scrollBtn = document.getElementById('scrollToBottom');
      if (scrollBtn) {
        scrollBtn.addEventListener('click', function() {
          const chatBox = document.getElementById('chatBox');
          chatBox.scrollTop = chatBox.scrollHeight;
        });
      }
    });
    
    // Function to implement document improvements
    function implementImprovements(filename) {
      if (!window.documentImprovements || !window.documentImprovements[filename]) {
        showNotification("No improvement suggestions found for this document", "error");
        return;
      }
      
      // Show processing notification
      showNotification("Processing document improvements...", "info");
      
      const originalText = window.documentImprovements[filename].original;
      const suggestions = window.documentImprovements[filename].suggestions;
      
      // Create a prompt for implementing the improvements
      let improvementPrompt;
      
      if (modelConfig[activeModel].usingFallbackModel) {
        improvementPrompt = `
          Please implement all the improvement suggestions for the following document.
          
          ORIGINAL DOCUMENT:
          ${originalText}
          
          IMPROVEMENT SUGGESTIONS:
          ${suggestions}
          
          INSTRUCTIONS:
          1. Apply all suggested improvements to the document
          2. Fix any grammatical or spelling errors
          3. Improve formatting and structure
          4. Return ONLY the improved document text, without any comments or explanations
          5. Also provide a summary of changes made, listing each significant change in a brief bullet point
        `;
      } else {
        improvementPrompt = `
          You are an expert document editor. Implement all the improvement suggestions for this document.
          
          ORIGINAL DOCUMENT:
          ${originalText}
          
          IMPROVEMENT SUGGESTIONS:
          ${suggestions}
          
          INSTRUCTIONS:
          1. Apply all suggested improvements to the document
          2. Fix any grammatical or spelling errors
          3. Improve formatting and structure
          4. Return the improved document text, followed by "CHANGES_SUMMARY:" and then a list of bullet points describing each significant change you made
          5. Format your response exactly as: [IMPROVED_DOCUMENT]improved text here[/IMPROVED_DOCUMENT][CHANGES_SUMMARY] Change 1\n Change 2\n etc.[/CHANGES_SUMMARY]
        `;
      }
      
      // API request to implement improvements
      fetch(modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex], {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${modelConfig[activeModel].authTokens[modelConfig[activeModel].currentTokenIndex]}`
        },
        body: JSON.stringify({
          inputs: improvementPrompt,
          parameters: {
            max_new_tokens: 2048,
            temperature: 0.3,
            top_p: 0.8,
            do_sample: true,
            return_full_text: false
          }
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        let modelResponse = "";
        
        // Extract the improved text based on the model's response format
        if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
          modelResponse = data[0].generated_text.trim();
        } else if (data && data.generated_text) {
          modelResponse = data.generated_text.trim();
        } else if (data && data.choices && data.choices.length > 0) {
          modelResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
        } else {
          throw new Error("Unexpected response format");
        }
        
        // Extract improved text and changes summary
        let improvedText = "";
        let changesSummary = "";
        
        // Try to extract using the requested format
        const improvedDocMatch = modelResponse.match(/\[IMPROVED_DOCUMENT\]([\s\S]*?)\[\/IMPROVED_DOCUMENT\]/);
        const changesSummaryMatch = modelResponse.match(/\[CHANGES_SUMMARY\]([\s\S]*?)\[\/CHANGES_SUMMARY\]/);
        
        if (improvedDocMatch && changesSummaryMatch) {
          improvedText = improvedDocMatch[1].trim();
          changesSummary = changesSummaryMatch[1].trim();
        } else {
          // Fallback: if the model didn't use the requested format, assume the first part is the document
          // and look for any section titled "Changes:" or similar
          const changesSectionMatch = modelResponse.match(/(?:CHANGES(?:_SUMMARY)?:|Changes(?:\s+Summary)?:|Summary of Changes:)([\s\S]+)/);
          
          if (changesSectionMatch) {
            improvedText = modelResponse.substring(0, changesSectionMatch.index).trim();
            changesSummary = changesSectionMatch[1].trim();
          } else {
            // If no changes section found, just use the whole response as the improved text
            improvedText = modelResponse;
            changesSummary = "Changes not explicitly listed by the model.";
          }
        }
        
        // Show the review UI with changes
        showChangeReviewUI(filename, originalText, improvedText, changesSummary);
      })
      .catch(error => {
        console.error("Error implementing improvements:", error);
        showNotification("Error implementing document improvements", "error");
        appendMessage("bot", "I encountered an error while trying to implement the improvements. Please try again or implement the suggestions manually.");
      });
    }
    
    // Function to show a UI for reviewing changes
    function showChangeReviewUI(filename, originalText, improvedText, changesSummary) {
      // Create the review UI container
      const reviewUIHtml = `
        <div class="change-review-container" style="padding: 15px; background-color: var(--light-bg); border-radius: 8px; margin: 15px 0; border: 1px solid var(--border-color);">
          <h3 style="margin-top: 0; color: var(--primary-color);">Review Document Changes</h3>
          <p>Please review the proposed changes to your document before accepting:</p>
          
          <div class="changes-summary" style="margin: 15px 0; padding: 10px; background-color: rgba(0,0,0,0.03); border-left: 3px solid var(--primary-color); border-radius: 4px;">
            <h4 style="margin-top: 0;">Summary of Changes:</h4>
            <div style="white-space: pre-line;">${changesSummary}</div>
          </div>
          
          <div class="document-comparison" style="display: flex; gap: 15px; margin: 20px 0; flex-wrap: wrap;">
            <div class="original-document" style="flex: 1; min-width: 250px;">
              <h4 style="margin-top: 0;">Original Document</h4>
              <div style="border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden;">
                <textarea readonly style="width: 100%; height: 250px; padding: 10px; font-family: monospace; resize: vertical; border: none;">${originalText}</textarea>
              </div>
            </div>
            
            <div class="improved-document" style="flex: 1; min-width: 250px;">
              <h4 style="margin-top: 0;">Improved Document</h4>
              <div style="border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden;">
                <textarea id="improved-doc-content" style="width: 100%; height: 250px; padding: 10px; font-family: monospace; resize: vertical; border: none;">${improvedText}</textarea>
              </div>
            </div>
          </div>
          
          <div class="action-buttons" style="display: flex; gap: 10px; margin-top: 15px; justify-content: flex-end; flex-wrap: wrap;">
            <button onclick="rejectChanges()" class="action-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--light-bg); color: var(--text-color); border: 1px solid var(--border-color); cursor: pointer;">
              <i class="fas fa-times"></i> Reject Changes
            </button>
            <button onclick="acceptChanges('${filename}', true)" class="action-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--light-bg); color: var(--text-color); border: 1px solid var(--border-color); cursor: pointer;">
              <i class="fas fa-edit"></i> Edit Before Accepting
            </button>
            <button onclick="acceptChanges('${filename}', false)" class="action-button primary-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--primary-color); color: white; border: none; cursor: pointer;">
              <i class="fas fa-check"></i> Accept All Changes
            </button>
          </div>
        </div>
      `;
      
      // Add to chat
      appendHtmlMessage("bot", reviewUIHtml);
      
      // Store the improved text for later use
      if (!window.pendingDocumentChanges) {
        window.pendingDocumentChanges = {};
      }
      window.pendingDocumentChanges[filename] = improvedText;
      
      showNotification("Please review the suggested changes", "info");
    }
    
    // Function to accept changes
    function acceptChanges(filename, allowEdit) {
      if (!window.pendingDocumentChanges || !window.pendingDocumentChanges[filename]) {
        showNotification("No pending changes found", "error");
        return;
      }
      
      let improvedText = window.pendingDocumentChanges[filename];
      
      // If user edited the content, get the updated version
      if (allowEdit) {
        const editedContent = document.getElementById('improved-doc-content');
        if (editedContent) {
          improvedText = editedContent.value;
        }
      }
      
      // Store the improved document
      const improvedFilename = filename.replace(/(\.[^.]+)$/, "_improved$1");
      uploadedDocuments[improvedFilename] = improvedText;
      
      // Add the improved document to UI
      addImprovedDocumentToUI(improvedFilename, improvedText);
      
      // Show success message with download options
      const successMessageHtml = `
        <div style="padding: 15px; background-color: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 4px; margin: 15px 0;">
          <h4 style="margin-top: 0; color: #2e7d32;"> Document Changes Applied Successfully</h4>
          <p>The improved document "${improvedFilename}" is now available in your document panel.</p>
          <div style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
            <button onclick="downloadDocument('${improvedFilename}')" class="action-button primary-button" style="padding: 8px 15px; border-radius: 4px; background-color: var(--primary-color); color: white; border: none; cursor: pointer; display: flex; align-items: center; gap: 5px;">
              <i class="fas fa-download"></i> Download Improved Document
            </button>
          </div>
        </div>
      `;
      appendHtmlMessage("bot", successMessageHtml);
      
      // Clear the pending changes
      delete window.pendingDocumentChanges[filename];
      
      showNotification("Changes applied successfully!", "success");
    }
    
    // Function to reject changes
    function rejectChanges() {
      showNotification("Changes rejected", "info");
      appendMessage("bot", "Document changes have been rejected. If you'd like to try again with different improvements, please let me know.");
    }
    
    // Function to add improved document to UI
    function addImprovedDocumentToUI(filename, content) {
      const filePreview = document.getElementById("documentPreviews");
      
      // Create file item element
      const fileItem = document.createElement('div');
      fileItem.classList.add('file-item');
      fileItem.setAttribute('data-filename', filename);
      
      // Create file header
      const fileHeader = document.createElement('div');
      fileHeader.className = 'file-header';
      
      // Create file name container
      const fileNameContainer = document.createElement('div');
      fileNameContainer.className = 'file-name';
      
      // Determine icon based on file type
      let iconClass = 'fa-file-alt';
      if (filename.endsWith('.pdf')) {
        iconClass = 'fa-file-pdf';
      } else if (filename.match(/\.(jpg|jpeg|png|gif)$/i)) {
        iconClass = 'fa-file-image';
      } else if (filename.match(/\.(doc|docx)$/i)) {
        iconClass = 'fa-file-word';
      }
      
      // Create file icon
      const fileIcon = document.createElement('i');
      fileIcon.classList.add('fas', iconClass);
      fileIcon.style.color = '#4caf50'; // Green color for improved documents
      
      // Create filename span with "improved" badge
      const fileName = document.createElement('span');
      fileName.innerHTML = `${filename} <span style="background-color: #4caf50; color: white; padding: 2px 6px; font-size: 10px; border-radius: 10px; margin-left: 5px;">IMPROVED</span>`;
      
      // Add icon and filename to the name container
      fileNameContainer.appendChild(fileIcon);
      fileNameContainer.appendChild(fileName);
      
      // Create delete button
      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = '<i class="fas fa-times"></i>';
      closeBtn.classList.add("delete-file");
      closeBtn.setAttribute('aria-label', 'Remove file');
      
      closeBtn.addEventListener("click", function(e) {
        e.stopPropagation();
        filePreview.removeChild(fileItem);
        delete uploadedDocuments[filename];
        
        // If no more files, show welcome message
        if (filePreview.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          filePreview.appendChild(welcomeText);
        }
      });
      
      // Add name container and delete button to header
      fileHeader.appendChild(fileNameContainer);
      fileHeader.appendChild(closeBtn);
      
      // Add header to file item
      fileItem.appendChild(fileHeader);
      
      // Create a text preview
      const previewContainer = document.createElement('div');
      previewContainer.className = 'file-preview-container ocr-preview';
      
      // Add a textarea with the content
      const textPreview = document.createElement('textarea');
      textPreview.readOnly = true;
      textPreview.value = content;
      
      previewContainer.appendChild(textPreview);
      fileItem.appendChild(previewContainer);
      
      filePreview.appendChild(fileItem);
      
      // Force document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      previewSection.style.display = 'block';
      previewSection.style.visibility = 'visible';
      previewSection.style.opacity = '1';
    }
    
    // Function to download original document
    function downloadOriginalDocument(filename) {
      if (!uploadedDocuments[filename]) {
        showNotification("Document not found", "error");
        return;
      }
      
      downloadDocument(filename);
    }
    
    // Function to download any document
    function downloadDocument(filename) {
      if (!uploadedDocuments[filename]) {
        showNotification("Document not found", "error");
        return;
      }
      
      const content = uploadedDocuments[filename];
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      
      // Cleanup
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      showNotification(`Downloading ${filename}`, "success");
    }
    
    // Function to toggle thinking details visibility
    function toggleThinkingDetails(header) {
      const thinkingContainer = header.closest('.thinking-expandable');
      const isExpanded = thinkingContainer.classList.contains('expanded');
      const toggleButton = thinkingContainer.querySelector('.thinking-toggle i');
      
      if (isExpanded) {
        // Collapse
        thinkingContainer.classList.remove('expanded');
        toggleButton.classList.remove('fa-chevron-up');
        toggleButton.classList.add('fa-chevron-down');
      } else {
        // Expand
        thinkingContainer.classList.add('expanded');
        toggleButton.classList.remove('fa-chevron-down');
        toggleButton.classList.add('fa-chevron-up');
      }
    }

    // Helper function to get file type
    function getFileType(filename) {
      if (!filename) return "unknown";
      
      const extension = filename.split('.').pop().toLowerCase();
      
      if (extension === 'pdf') return 'pdf';
      if (extension === 'txt') return 'txt';
      if (extension === 'doc' || extension === 'docx') return 'doc';
      if (extension === 'jpg' || extension === 'jpeg' || extension === 'png') return 'image';
      
      return 'unknown';
    }
    
    // Simple scroll-to-bottom button handler
    document.addEventListener('DOMContentLoaded', function() {
      const chatBox = document.getElementById('chatBox');
      const scrollBottomBtn = document.getElementById('scrollBottomBtn');
      
      if (!chatBox || !scrollBottomBtn) return;
      
      // Simple scroll position check
      chatBox.addEventListener('scroll', function() {
        // Show button when not at bottom (with small threshold)
        const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
        
        if (isAtBottom) {
          scrollBottomBtn.classList.remove('visible');
        } else {
          scrollBottomBtn.classList.add('visible');
        }
      });
      
      // Simple click handler for scroll button
      scrollBottomBtn.addEventListener('click', function() {
        chatBox.scrollTo({
          top: chatBox.scrollHeight,
          behavior: 'smooth'
        });
      });
    });
  </script>
</body>
</html>
            
