<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="LegalMind - AI-powered legal document assistant">
  <title>LegalMind Dashboard</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Add PDF.js library for PDF processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <!-- Add Tesseract.js for OCR (image text recognition) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.3/dist/tesseract.min.js"></script>

  <!-- OCR Styles -->
  <style>
    .file-preview-container.ocr-preview {
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
      background-color: var(--light-bg);
      border-radius: 5px;
      margin-top: 10px;
    }

    .file-preview-container.ocr-preview textarea {
      width: 100%;
      height: 150px;
      resize: none;
      font-family: monospace;
      font-size: 12px;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--main-bg);
      color: var(--text-color);
    }

    .dark-mode .file-preview-container.ocr-preview {
      background-color: var(--sidebar-bg);
    }

    .dark-mode .file-preview-container.ocr-preview textarea {
      background-color: var(--main-bg);
      border-color: var(--dark-border-color);
    }

    /* Scrollbar for OCR Preview */
    .file-preview-container.ocr-preview::-webkit-scrollbar {
      width: 8px;
    }

    .file-preview-container.ocr-preview::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
    }

    .file-preview-container.ocr-preview::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 4px;
    }

    .file-preview-container.ocr-preview::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-hover);
    }

    /* Updated animated thinking indicator styles */
    .thinking-container {
      display: flex;
      align-items: center;
      gap: 5px;
      color: var(--text-color);
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .thinking-dots {
      display: inline-flex;
      align-items: center;
      height: 20px;
    }

    .thinking-dot {
      width: 4px;
      height: 4px;
      margin: 0 2px;
      background-color: currentColor;
      border-radius: 50%;
      display: inline-block;
      animation: thinkingDot 1.4s infinite ease-in-out both;
    }

    .thinking-dot:nth-child(1) {
      animation-delay: -0.32s;
    }

    .thinking-dot:nth-child(2) {
      animation-delay: -0.16s;
    }

    @keyframes thinkingDot {

      0%,
      80%,
      100% {
        transform: scale(0);
      }

      40% {
        transform: scale(1);
      }
    }

    /* Additional thinking animation details */
    .thinking-brain {
      display: inline-block;
      animation: pulse 1.5s infinite ease-in-out;
      margin-right: 5px;
      color: var(--primary-color);
    }

    @keyframes pulse {
      0% {
        opacity: 0.3;
        transform: scale(0.8);
      }

      50% {
        opacity: 1;
        transform: scale(1.1);
      }

      100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
    }

    /* Hidden text that appears during thinking */
    .thinking-context {
      font-size: 0.85rem;
      color: var(--text-color);
      opacity: 0.7;
      margin-top: 5px;
      font-style: italic;
      display: block;
      animation: fadeInOut 8s infinite ease-in-out;
    }

    @keyframes fadeInOut {

      0%,
      100% {
        opacity: 0.3;
      }

      50% {
        opacity: 0.7;
      }
    }

    /* Animated thinking indicator styles */
    @keyframes ellipsis {
      0% {
        content: '.';
      }

      33% {
        content: '..';
      }

      66% {
        content: '...';
      }

      100% {
        content: '';
      }
    }

    .message.bot:last-child:has(span[data-thinking="true"]) {
      position: relative;
    }

    .message.bot:last-child:has(span[data-thinking="true"])::after {
      content: '';
      position: absolute;
      display: inline-block;
      animation: ellipsis 1.5s infinite steps(4);
      width: 1.5em;
      overflow: hidden;
      vertical-align: bottom;
      margin-left: 0.2em;
    }
  </style>
  <style>
    /* CSS Variables for theming */
    :root {
      --primary-color: #007bff;
      --primary-hover: #0056b3;
      --success-color: #28a745;
      --success-hover: #218838;
      --danger-color: #dc3545;
      --light-bg: #f8f9fa;
      --dark-bg: #121212;
      --light-surface: #ffffff;
      --dark-surface: #1e1e1e;
      --light-text: #212529;
      --dark-text: #f8f9fa;
      --light-border: #dee2e6;
      --dark-border: #444;
      --box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      --dark-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      --transition: all 0.3s ease;
      --border-radius-sm: 8px;
      --border-radius-md: 12px;
      --border-radius-lg: 16px;
      --border-radius-xl: 24px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
    }

    /* Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: var(--light-bg);
      color: var(--light-text);
      transition: var(--transition);
      overflow-x: hidden;
    }

    body.dark-mode {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }

    .dashboard {
      display: flex;
      width: 100%;
      height: 100vh;
      border-radius: var(--border-radius-lg);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      transition: var(--transition);
    }

    body.dark-mode .dashboard {
      box-shadow: var(--dark-box-shadow);
    }

    /* Left Sidebar with improved padding */
    .sidebar {
      position: relative;
      display: flex;
      flex-direction: column;
      width: 300px;
      height: 100%;
      background-color: var(--bg-color-surface);
      overflow-y: auto;
      transition: all 0.3s ease;
      padding: 15px 12px 0;
    }

    body.dark-mode .sidebar {
      background: var(--dark-surface);
      border-right: 1px solid var(--dark-border);
    }

    .chat-header {
      margin-bottom: var(--spacing-lg);
      padding-left: 5px;
      display: flex;
      align-items: center;
    }

    .chat-header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin: 0;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .new-chat {
      width: 100%;
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
      cursor: pointer;
      border: none;
      border-radius: var(--border-radius-md);
      background: var(--primary-color);
      color: white;
      transition: var(--transition);
      font-size: 0.95rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }

    .new-chat:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
    }

    .new-chat i {
      margin-right: var(--spacing-xs);
    }

    .chat-list {
      padding: 0;
      overflow-y: auto;
      margin-bottom: var(--spacing-lg);
      flex-grow: 1;
    }

    .chat-list li {
      list-style: none;
      padding: var(--spacing-md);
      margin: var(--spacing-xs) 0;
      background-color: var(--light-bg);
      border-radius: var(--border-radius-md);
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition);
      cursor: pointer;
      font-weight: 500;
    }

    .chat-list li:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }

    .chat-list li.active {
      background-color: rgba(0, 123, 255, 0.2);
      border-left: 3px solid var(--primary-color);
    }

    body.dark-mode .chat-list li {
      background: rgba(255, 255, 255, 0.05);
    }

    body.dark-mode .chat-list li:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .chat-list li.active {
      background: rgba(0, 123, 255, 0.3);
    }

    .chat-list li .delete-chat {
      cursor: pointer;
      background: none;
      border: none;
      font-size: 0.9rem;
      color: var(--danger-color);
      opacity: 0.7;
      transition: var(--transition);
    }

    .chat-list li .delete-chat:hover {
      opacity: 1;
    }

    /* Document Preview section with fixed styling */
    .documents-preview {
      position: relative;
      display: flex;
      flex-direction: column;
      margin: 15px 10px;
      background: var(--light-surface);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--light-border);
      padding: var(--spacing-md);
      box-shadow: var(--box-shadow);
      z-index: 5;
      max-height: none;
    }

    body.dark-mode .documents-preview {
      background: var(--dark-surface);
      border-color: var(--dark-border);
      box-shadow: var(--dark-box-shadow);
    }

    .documents-preview h3 {
      margin-bottom: var(--spacing-md);
      font-size: 1rem;
      font-weight: 600;
      color: var(--light-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    body.dark-mode .documents-preview h3 {
      color: var(--dark-text);
    }

    #documentPreviews {
      flex: 1;
      min-height: 50px;
      max-height: 250px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 5px;
    }

    .file-item {
      display: flex;
      flex-direction: column;
      background: var(--light-surface);
      border-radius: var(--border-radius-md);
      border: 1px solid var(--light-border);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      transition: var(--transition);
      overflow: hidden;
      margin-bottom: var(--spacing-md);
    }

    .file-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
    }

    .file-name-container {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .file-name-container i {
      color: #555;
    }

    body.dark-mode .file-name-container i {
      color: #ddd;
    }

    .file-name-container span {
      font-weight: 500;
      font-size: 0.9rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-preview-container {
      padding: 10px;
      max-height: 200px;
      overflow: hidden;
    }

    .file-preview-container img {
      max-width: 100%;
      max-height: 180px;
      object-fit: contain;
      display: block;
      margin: 0 auto;
    }

    .delete-file {
      cursor: pointer;
      background: none;
      border: none;
      font-size: 0.85rem;
      color: var(--danger-color);
      opacity: 0.7;
      transition: var(--transition);
    }

    .delete-file:hover {
      opacity: 1;
    }

    /* PDF specific styling to match screenshot */
    .pdf-icon {
      color: #e74c3c;
    }

    .pdf-preview {
      height: 200px;
      overflow: hidden;
    }

    body.dark-mode .pdf-preview {
      background: #2a2a2a;
    }

    /* Chat Section */
    .chat-section {
      flex: 1;
      padding: var(--spacing-lg);
      display: flex;
      flex-direction: column;
      background-color: var(--light-surface);
      transition: var(--transition);
      position: relative;
      height: 100vh;
      overflow: hidden;
    }

    body.dark-mode .chat-section {
      background-color: var(--dark-surface);
    }

    /* Navigation Bar */
    .chat-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--light-bg);
      padding: var(--spacing-md) var(--spacing-lg);
      box-shadow: var(--box-shadow);
      margin-bottom: var(--spacing-md);
      border-radius: var(--border-radius-md);
      transition: var(--transition);
      position: relative;
      z-index: 10;
    }

    body.dark-mode .chat-nav {
      background-color: rgba(255, 255, 255, 0.05);
      box-shadow: var(--dark-box-shadow);
    }

    /* Nav Left: Menu Toggle + LegalMind.Space */
    .nav-left {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }

    .menu-toggle {
      display: none;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .menu-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    body.dark-mode .menu-toggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .menu-toggle {
      color: var(--dark-text);
    }

    .nav-brand {
      font-weight: 700;
      font-size: 1.2rem;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Nav Right: Dropdowns, Contact Us, and Profile */
    .nav-right {
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .nav-links {
      display: flex;
      gap: var(--spacing-xl);
      font-weight: 500;
      align-items: center;
    }

    .nav-links a {
      text-decoration: none;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition);
    }

    .nav-links a:hover {
      color: var(--primary-color);
    }

    body.dark-mode .nav-links a {
      color: var(--dark-text);
    }

    /* Dropdown styling */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background-color: var(--light-surface);
      min-width: 180px;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius-md);
      z-index: 1;
      overflow: hidden;
      transition: var(--transition);
    }

    body.dark-mode .dropdown-content {
      background-color: var(--dark-surface);
      box-shadow: var(--dark-box-shadow);
    }

    .dropdown-content a {
      color: var(--light-text);
      padding: var(--spacing-md);
      text-decoration: none;
      display: block;
      transition: var(--transition);
    }

    body.dark-mode .dropdown-content a {
      color: var(--dark-text);
    }

    .dropdown-content a:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }

    body.dark-mode .dropdown-content a:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    /* Nav Profile */
    .nav-profile {
      position: relative;
    }

    .nav-profile img {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--light-border);
      object-fit: cover;
      transition: var(--transition);
    }

    body.dark-mode .nav-profile img {
      border-color: var(--dark-border);
    }

    .nav-profile img:hover {
      transform: scale(1.05);
      border-color: var(--primary-color);
    }

    /* Profile Menu - Upgraded UI */
    .profile-menu {
      display: none;
      flex-direction: column;
      position: absolute;
      right: 0;
      top: 50px;
      background: var(--light-surface);
      padding: var(--spacing-lg);
      border-radius: var(--border-radius-md);
      box-shadow: var(--box-shadow);
      width: 280px;
      transition: var(--transition);
      z-index: 99;
    }

    body.dark-mode .profile-menu {
      background: var(--dark-surface);
      box-shadow: var(--dark-box-shadow);
    }

    .profile-menu.active {
      display: flex;
    }

    .profile-menu-header {
      display: flex;
      flex-direction: column;
      margin-bottom: var(--spacing-md);
      padding-bottom: var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
    }

    body.dark-mode .profile-menu-header {
      border-color: var(--dark-border);
    }

    .profile-menu-header .user-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 4px;
    }

    .profile-menu-header .user-plan {
      color: #6c757d;
      font-size: 0.9rem;
    }

    body.dark-mode .profile-menu-header .user-plan {
      color: #adb5bd;
    }

    .profile-menu-actions {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .profile-menu-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-md);
      border-radius: var(--border-radius-md);
      border: none;
      background: var(--light-bg);
      color: var(--light-text);
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
    }

    body.dark-mode .profile-menu-btn {
      background: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
    }

    .profile-menu-btn:hover {
      background: rgba(0, 123, 255, 0.1);
      transform: translateY(-2px);
    }

    .profile-menu-btn.logout {
      background-color: rgba(220, 53, 69, 0.1);
      color: var(--danger-color);
    }

    .profile-menu-btn.logout:hover {
      background-color: var(--danger-color);
      color: white;
    }

    /* Settings Panel */
    .settings-panel {
      display: none;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .settings-panel.active {
      display: flex;
    }

    .settings-section {
      background: var(--light-bg);
      border-radius: var(--border-radius-md);
      padding: var(--spacing-md);
      border: 1px solid var(--light-border);
    }

    body.dark-mode .settings-section {
      background: rgba(255, 255, 255, 0.05);
      border-color: var(--dark-border);
    }

    .settings-section-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-sm);
      font-weight: 500;
    }

    .back-to-menu {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      margin-bottom: var(--spacing-md);
      color: var(--primary-color);
      background: none;
      border: none;
      padding: 0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .back-to-menu:hover {
      text-decoration: underline;
    }

    /* Dark mode toggle enhanced */
    .switch {
      display: flex;
      align-items: center;
      margin-top: var(--spacing-xs);
      cursor: pointer;
    }

    .switch input {
      appearance: none;
      width: 44px;
      height: 22px;
      background: #ccc;
      border-radius: 11px;
      position: relative;
      transition: var(--transition);
      cursor: pointer;
      margin-right: var(--spacing-md);
    }

    .switch input:checked {
      background: var(--primary-color);
    }

    .switch input::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      transition: var(--transition);
    }

    .switch input:checked::before {
      transform: translateX(22px);
    }

    /* File upload */
    .profile-menu input[type="file"] {
      margin-top: var(--spacing-md);
      display: block;
      width: 100%;
      border-radius: var(--border-radius-md);
      padding: var(--spacing-sm);
      border: 1px solid var(--light-border);
      font-size: 0.9rem;
    }

    body.dark-mode .profile-menu input[type="file"] {
      border-color: var(--dark-border);
      color: var(--dark-text);
      background: rgba(255, 255, 255, 0.05);
    }

    .profile-menu #uploadedFileName {
      font-size: 0.8rem;
      color: #6c757d;
      margin-top: var(--spacing-xs);
    }

    body.dark-mode .profile-menu #uploadedFileName {
      color: #adb5bd;
    }

    /* Chat Box with padding adjustments for welcome message */
    .chat-box {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border: 1px solid var(--light-border);
      /* Update padding to accommodate the sticky welcome message */
      padding: 0 var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
      background-color: var(--light-bg);
      border-radius: var(--border-radius-lg);
      transition: var(--transition);
      margin-bottom: var(--spacing-md);
      position: relative;
      scroll-behavior: smooth;
    }

    /* Add margin to first message to create space after welcome message */
    .chat-box>.message:first-of-type {
      margin-top: var(--spacing-lg);
    }

    body.dark-mode .chat-box {
      background: rgba(255, 255, 255, 0.02);
      border-color: var(--dark-border);
    }

    /* Add padding after welcome message for better spacing */
    .chat-box>.message:first-of-type {
      margin-top: var(--spacing-lg);
    }

    /* Chat Input */
    .chat-input {
      display: flex;
      margin-top: var(--spacing-md);
      gap: var(--spacing-md);
      position: relative;
    }

    .input-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
    }

    .chat-input input {
      flex: 1;
      width: 100%;
      padding: var(--spacing-md) var(--spacing-lg);
      padding-left: 16px;
      padding-right: 135px;
      border: 1px solid var(--light-border);
      border-radius: 30px;
      font-size: 1rem;
      background-color: var(--light-surface);
      color: var(--light-text);
      transition: var(--transition);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    body.dark-mode .chat-input input {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
      border-color: var(--dark-border);
    }

    .chat-input input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }

    .attach-btn {
      position: absolute;
      right: 55px;
      top: 50%;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .attach-btn:hover {
      color: var(--primary-color);
    }

    body.dark-mode .attach-btn {
      color: #adb5bd;
    }

    .image-btn {
      position: absolute;
      right: 95px;
      top: 50%;
      transform: translateY(-50%);
      color: #6c757d;
      font-size: 1.2rem;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .image-btn:hover {
      color: var(--primary-color);
    }

    body.dark-mode .image-btn {
      color: #adb5bd;
    }

    #sendBtn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      transition: all 0.2s ease;
    }

    #sendBtn:hover {
      transform: translateY(-50%) scale(1.1);
    }

    /* Chat Messages */
    .message {
      margin-bottom: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: 20px;
      max-width: 70%;
      word-wrap: break-word;
      line-height: 1.5;
      animation: fadeIn 0.3s ease-out;
      position: relative;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .user {
      background-color: var(--primary-color);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }

    .bot {
      background-color: var(--light-surface);
      color: var(--light-text);
      align-self: flex-start;
      border-bottom-left-radius: 5px;
      border: 1px solid var(--light-border);
    }

    body.dark-mode .bot {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--dark-text);
      border-color: var(--dark-border);
    }

    /* Welcome Message with fixed positioning */
    .welcome-message {
      text-align: center;
      padding: 20px;
      background-color: var(--light-bg);
      border-bottom: 1px solid var(--light-border);
      margin-bottom: 0;
      position: relative;
      width: 100%;
      border-top-left-radius: var(--border-radius-lg);
      border-top-right-radius: var(--border-radius-lg);
      transition: var(--transition);
    }

    body.dark-mode .welcome-message {
      background-color: var(--dark-bg);
      border-color: var(--dark-border);
    }

    .welcome-message.hidden {
      display: none;
    }

    .welcome-message h2 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 600;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: var(--spacing-xs);
    }

    .welcome-message p {
      margin-top: var(--spacing-xs);
      font-size: 1.1rem;
      color: #6c757d;
    }

    body.dark-mode .welcome-message p {
      color: #ddd;
    }

    .welcome-message .model-info {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      background: #f2f5f9;
      display: inline-block;
      padding: 4px 10px;
      border-radius: 15px;
    }

    .welcome-message .model-info .fas {
      color: #4CAF50;
      margin-right: 5px;
    }

    .welcome-message .model-info .model-id {
      color: #888;
      font-size: 12px;
    }

    body.dark-mode .welcome-message .model-info {
      background: #2d3748;
      color: #cbd5e0;
    }

    body.dark-mode .welcome-message .model-info .model-id {
      color: #a0aec0;
    }

    /* Responsive adjustments for sidebar */
    @media (max-width: 992px) {
      .dashboard {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
      }

      .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 990;
        background-color: var(--light-surface);
        display: none;
        flex-direction: column;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        padding: 15px;
      }

      body.dark-mode .sidebar {
        background-color: var(--dark-surface);
      }

      .sidebar .chat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .sidebar .chat-header:after {
        content: "\f00d";
        font-family: "Font Awesome 5 Free";
        font-weight: 900;
        font-size: 1.2rem;
        cursor: pointer;
        color: var(--light-text);
      }

      body.dark-mode .sidebar .chat-header:after {
        color: var(--dark-text);
      }

      .documents-preview {
        margin-top: 15px;
        flex: 1;
        max-height: none;
      }

      #documentPreviews {
        max-height: none;
        flex: 1;
        overflow-y: auto;
      }

      .chat-section {
        padding: var(--spacing-md);
        height: 100vh !important;
      }

      .nav-links {
        display: none;
      }

      .nav-right {
        gap: var(--spacing-md);
      }

      .menu-toggle {
        display: block;
        position: relative;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--light-text);
        cursor: pointer;
        transition: var(--transition);
      }

      body.dark-mode .menu-toggle {
        color: var(--dark-text);
      }

      .chat-box {
        max-height: calc(100vh - 140px) !important;
      }

      /* Fixed document preview visibility */
      .sidebar.collapsed .documents-preview {
        display: none !important;
      }

      .sidebar:not(.collapsed) .documents-preview {
        display: flex !important;
        max-height: none;
        overflow: visible;
        margin-bottom: var(--spacing-md);
      }

      /* Ensure toggle button is always visible */
      .documents-toggle {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        height: 35px;
        border-radius: 0;
        position: relative;
        bottom: 0;
        margin-top: 0;
        z-index: 100;
      }

      .documents-preview {
        position: relative;
        max-height: none;
        border: 1px solid var(--light-border);
        margin: 20px 15px;
        border-radius: var(--border-radius-md);
        overflow: hidden;
      }

      #documentPreviews {
        max-height: 200px;
        padding: 8px;
      }
    }

    @media (max-width: 768px) {
      .sidebar {
        padding: 10px 8px 0;
      }

      .message {
        max-width: 85%;
      }

      .profile-menu {
        width: 260px;
        right: -10px;
        padding: var(--spacing-md);
      }

      .documents-preview {
        margin: 15px 10px;
        padding: 12px;
      }

      #documentPreviews {
        max-height: 150px;
        padding: 5px;
      }

      .documents-toggle {
        height: 30px;
      }

      .profile-pic-section {
        padding: var(--spacing-sm);
      }

      .profile-preview {
        width: 60px;
        height: 60px;
      }

      .chat-input {
        display: grid;
        grid-template-columns: 40px 1fr;
        grid-template-rows: auto auto;
        gap: var(--spacing-sm);
      }

      .attach-btn {
        position: relative;
        grid-row: 2;
        grid-column: 1;
        transform: none;
        top: auto;
        left: auto;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--light-bg);
        border-radius: var(--border-radius-md);
        border: 1px solid var(--light-border);
      }

      body.dark-mode .attach-btn {
        background: rgba(255, 255, 255, 0.05);
        border-color: var(--dark-border);
      }

      .chat-input input {
        grid-row: 2;
        grid-column: 2;
        padding-left: var(--spacing-md);
      }

      #sendBtn {
        grid-row: 3;
        grid-column: 1 / span 2;
        width: 100%;
        margin-top: var(--spacing-xs);
      }

      .chat-nav {
        flex-wrap: wrap;
      }

      .nav-profile img {
        width: 35px;
        height: 35px;
      }
    }

    @media (max-width: 576px) {
      .sidebar {
        padding: 8px 5px 0;
      }

      .chat-nav {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .nav-left {
        font-size: 1rem;
      }

      .chat-section {
        padding: var(--spacing-md);
      }

      .welcome-message h2 {
        font-size: 1.5rem;
      }

      .welcome-message p {
        font-size: 1rem;
      }

      .chat-box {
        padding: var(--spacing-md);
      }

      .message {
        max-width: 90%;
        padding: var(--spacing-sm) var(--spacing-md);
      }

      #currentChat {
        font-size: 0.8rem;
      }

      .chat-header h1 {
        font-size: 1.3rem;
      }
    }

    @media (max-width: 480px) {
      .sidebar {
        padding: 8px 5px 0;
      }

      .documents-preview {
        margin: 10px 5px;
        padding: 10px;
      }

      .message {
        max-width: 95%;
      }

      .chat-nav {
        padding: var(--spacing-xs) var(--spacing-sm);
      }

      .nav-left {
        font-size: 0.9rem;
      }

      .nav-profile img {
        width: 30px;
        height: 30px;
      }

      .profile-menu {
        width: 240px;
        right: -15px;
        padding: var(--spacing-md);
      }
    }

    /* Enhanced mobile menu styling */
    .mobile-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 85%;
      max-width: 320px;
      height: 100vh;
      background-color: var(--light-surface);
      z-index: 999;
      transform: translateX(-100%);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: var(--dark-box-shadow);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border-right: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .mobile-menu {
      background-color: var(--dark-surface);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    .mobile-menu.active {
      transform: translateX(0);
    }

    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 998;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(2px);
    }

    .mobile-menu-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    /* Refined mobile menu header */
    .mobile-menu-header {
      padding: var(--spacing-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      border-bottom: 1px solid var(--light-border);
      position: sticky;
      top: 0;
      background-color: var(--light-surface);
      z-index: 2;
    }

    body.dark-mode .mobile-menu-header {
      border-color: var(--dark-border);
      background-color: var(--dark-surface);
    }

    .mobile-menu-header h1 {
      font-size: 1.5rem;
      margin: 0;
      background: linear-gradient(90deg, var(--primary-color), #6b47fb);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .mobile-menu-content {
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      overflow-y: auto;
    }

    /* Enhanced mobile menu buttons */
    .mobile-menu-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: 12px var(--spacing-lg);
      border-radius: 10px;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .mobile-menu-btn::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background-color: rgba(0, 123, 255, 0.1);
      transition: width 0.2s ease;
      z-index: -1;
      border-radius: 10px;
    }

    .mobile-menu-btn:active {
      transform: scale(0.98);
    }

    .mobile-menu-btn:hover::after {
      width: 100%;
    }

    body.dark-mode .mobile-menu-btn {
      color: var(--dark-text);
    }

    body.dark-mode .mobile-menu-btn::after {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .mobile-menu-btn.new-chat-btn {
      background: var(--primary-color);
      color: white;
      font-weight: 500;
      margin-bottom: var(--spacing-md);
      box-shadow: 0 4px 6px rgba(0, 123, 255, 0.2);
    }

    .mobile-menu-btn.new-chat-btn:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 123, 255, 0.3);
    }

    .mobile-menu-btn.new-chat-btn:active {
      transform: translateY(0);
    }

    /* Improved section headers */
    .mobile-section-header {
      font-size: 0.85rem;
      font-weight: 600;
      color: #6c757d;
      padding: 14px var(--spacing-lg) 8px;
      margin-top: var(--spacing-md);
      position: sticky;
      top: 71px;
      background-color: var(--light-surface);
      z-index: 1;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    body.dark-mode .mobile-section-header {
      color: #adb5bd;
      background-color: var(--dark-surface);
    }

    /* Enhanced chat items */
    .mobile-chat-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--spacing-sm);
      padding: 10px var(--spacing-md);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .mobile-chat-item .chat-info {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      flex: 1;
      overflow: hidden;
    }

    .mobile-chat-item .delete-chat {
      background: none;
      border: none;
      color: var(--danger-color);
      opacity: 0.7;
      font-size: 0.85rem;
      padding: 5px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .mobile-chat-item .delete-chat:hover {
      opacity: 1;
    }

    .mobile-chat-item i {
      color: #6c757d;
      font-size: 0.9rem;
      width: 20px;
      text-align: center;
    }

    body.dark-mode .mobile-chat-item i {
      color: #adb5bd;
    }

    .mobile-chat-item span {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .mobile-chat-item::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background-color: rgba(0, 123, 255, 0.1);
      transition: width 0.2s ease;
      z-index: -1;
      border-radius: 10px;
    }

    .mobile-chat-item:hover::after {
      width: 100%;
    }

    .mobile-chat-item.active {
      background-color: rgba(0, 123, 255, 0.15);
      font-weight: 500;
    }

    .mobile-chat-item.active i {
      color: var(--primary-color);
    }

    body.dark-mode .mobile-chat-item.active {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Better menu button animation */
    .menu-toggle {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--light-text);
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .menu-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .menu-toggle:active {
      transform: scale(0.95);
    }

    /* Model dropdown styling */
    .model-dropdown {
      display: flex;
      align-items: center;
      cursor: pointer;
      position: relative;
    }

    /* Mobile responsiveness */
    @media (max-width: 992px) {
      .menu-toggle {
        display: block;
      }

      .nav-left {
        gap: var(--spacing-sm);
      }

      .dashboard {
        height: 100vh;
        overflow: hidden;
      }

      .sidebar {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .chat-section {
        padding: var(--spacing-md) var(--spacing-md);
      }

      .chat-nav {
        padding: var(--spacing-sm) var(--spacing-md);
        margin-bottom: var(--spacing-sm);
      }

      .chat-box {
        padding: var(--spacing-md);
      }
    }

    @media (max-width: 576px) {
      .chat-section {
        padding: var(--spacing-sm);
      }

      .chat-nav {
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }
    }

    @media (max-width: 480px) {
      .nav-brand {
        font-size: 1rem;
      }

      .model-dropdown i {
        font-size: 0.7rem !important;
      }
    }

    @media (max-width: 992px) {

      /* Remove document preview button from mobile menu */
      .mobile-menu-btn[onclick*="toggleDocumentPreview"] {
        display: none;
      }

      /* Use full screen height for chat section on mobile */
      .chat-section {
        height: 100vh !important;
        max-height: none !important;
        padding-bottom: 10px;
      }

      /* Fix chat box height to utilize full screen */
      .chat-box {
        max-height: calc(100vh - 120px) !important;
        margin-bottom: 10px;
      }

      /* Hide document preview section entirely on mobile */
      .documents-preview,
      .sidebar .documents-preview,
      .sidebar:not(.collapsed) .documents-preview {
        display: none !important;
      }

      /* Hide document-related toggle buttons */
      .documents-toggle {
        display: none !important;
      }
    }

    /* File upload message styling in chat */
    .file-upload {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      margin: 5px 0;
    }

    body.dark-mode .file-upload {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .file-upload i {
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    .file-upload span {
      font-size: 0.95rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 200px;
    }

    @media (max-width: 768px) {
      .chat-input {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
        position: relative;
      }

      .input-container {
        flex: 1;
        position: relative;
      }

      .attach-btn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        height: auto;
        width: auto;
        background: transparent;
        border: none;
        z-index: 2;
      }

      .image-btn {
        position: absolute;
        left: 40px;
        top: 50%;
        transform: translateY(-50%);
        height: auto;
        width: auto;
        background: transparent;
        border: none;
        z-index: 2;
      }

      #messageInput {
        padding-left: 70px !important;
      }

      #sendBtn {
        right: 8px;
        font-size: 1.2rem;
      }
    }

    /* Scroll to bottom button */
    .scroll-bottom-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.3s ease;
      z-index: 10;
      border: none;
    }

    .scroll-bottom-btn.visible {
      opacity: 1;
      transform: scale(1);
    }

    .scroll-bottom-btn:hover {
      background-color: var(--primary-hover);
      transform: scale(1.05);
    }

    .scroll-bottom-btn:active {
      transform: scale(0.95);
    }

    /* Mobile-specific adjustments for chat input */
    @media (max-width: 768px) {
      .chat-input {
        display: flex;
        flex-direction: row;
        position: relative;
        margin-top: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }

      .input-container {
        flex: 1;
        display: flex;
        align-items: center;
        position: relative;
      }

      .chat-input input {
        width: 100%;
        padding: 12px 40px;
        border-radius: 24px;
        font-size: 1rem;
      }

      .attach-btn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: #6c757d;
        z-index: 2;
      }

      .image-btn {
        position: absolute;
        left: 40px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: #6c757d;
        z-index: 2;
      }

      #sendBtn {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: var(--primary-color);
        font-size: 1.2rem;
        z-index: 2;
      }

      /* Ensure chat box fills available space */
      .chat-box {
        max-height: calc(100vh - 170px);
      }
    }

    /* Further mobile refinements */
    @media (max-width: 576px) {
      .chat-input {
        margin-top: 6px;
        margin-bottom: 6px;
      }

      .chat-input input {
        padding: 10px 38px;
        font-size: 0.95rem;
      }

      #sendBtn,
      .attach-btn {
        font-size: 1.1rem;
      }

      #sendBtn {
        width: 32px;
        height: 32px;
        padding: 0;
        right: 8px;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }

      #sendBtn i {
        font-size: 0.85rem;
      }
    }

    /* Small mobile screens */
    @media (max-width: 480px) {
      .chat-input {
        margin-top: 4px;
        margin-bottom: 4px;
      }

      .chat-input input {
        padding: 9px 36px;
        font-size: 0.9rem;
      }

      #sendBtn,
      .attach-btn {
        font-size: 1rem;
      }

      #sendBtn {
        width: 28px;
        height: 28px;
        padding: 0;
        right: 8px;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }

      #sendBtn i {
        font-size: 0.85rem;
      }
    }

    /* Mobile-specific adjustments for chat input */
    @media (max-width: 992px) {
      .chat-section {
        position: relative;
        display: flex;
        flex-direction: column;
        height: fit-content !important;
        min-height: 100vh;
        padding-bottom: 80px !important;
        /* Space for input */
      }

      .chat-box {
        flex: 1;
        height: calc(100vh - 180px) !important;
        margin-bottom: 5px;
      }

      .chat-input {
        position: fixed;
        bottom: 10px;
        left: 0;
        right: 0;
        padding: 0 15px;
        margin: 0;
        z-index: 20;
        background: var(--light-surface);
      }

      body.dark-mode .chat-input {
        background: var(--dark-surface);
      }

      .input-container {
        width: 100%;
        border-radius: 30px;
        background-color: var(--light-surface);
        box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
        padding: 2px;
        display: flex;
        align-items: center;
        border: 1px solid var(--light-border);
        transition: all 0.3s ease;
        position: relative;
      }

      body.dark-mode .input-container {
        background-color: var(--dark-surface);
        border-color: var(--dark-border);
        box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
      }

      .attach-btn {
        position: absolute;
        right: 55px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 0;
      }

      .image-btn {
        position: absolute;
        right: 95px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 0;
      }

      .chat-input input {
        height: 50px;
        font-size: 16px;
        padding: 12px 50px 12px 15px;
        padding-right: 135px;
        border: none;
        background: transparent;
        width: 100%;
      }

      #sendBtn {
        width: 36px;
        height: 36px;
        padding: 0;
        right: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--primary-color);
        color: white;
        border-radius: 50%;
      }

      #sendBtn i {
        font-size: 0.9rem;
      }

      body.dark-mode #sendBtn {
        background-color: var(--primary-color);
      }
    }

    /* Additional mobile refinements */
    @media (max-width: 576px) {
      .chat-section {
        height: fit-content !important;
        min-height: 100vh;
      }

      .chat-box {
        height: calc(100vh - 160px) !important;
      }

      .attach-btn {
        width: 35px;
        height: 35px;
        right: 52px;
      }

      .image-btn {
        width: 35px;
        height: 35px;
        right: 90px;
      }
    }

    /* Small mobile screens */
    @media (max-width: 480px) {
      .chat-section {
        padding: var(--spacing-sm);
      }

      .chat-box {
        height: calc(100vh - 150px) !important;
      }

      .attach-btn {
        width: 32px;
        height: 32px;
        right: 50px;
      }

      .image-btn {
        width: 32px;
        height: 32px;
        right: 85px;
      }
    }

    /* Interactive effects for mobile inputs */
    @media (max-width: 992px) {

      /* Input animation when focused */
      .input-container:focus-within {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border-color: var(--primary-color);
      }

      /* Message animations */
      .message {
        transition: transform 0.2s ease, opacity 0.2s ease;
      }

      .message.user {
        animation: messageSlideInRight 0.3s ease forwards;
      }

      .message.bot {
        animation: messageSlideInLeft 0.3s ease forwards;
      }

      @keyframes messageSlideInRight {
        from {
          opacity: 0;
          transform: translateX(30px);
        }

        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @keyframes messageSlideInLeft {
        from {
          opacity: 0;
          transform: translateX(-30px);
        }

        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      /* Send button ripple effect */
      #sendBtn::after {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.4);
        transform: scale(0);
        transition: transform 0.3s ease-out;
      }

      #sendBtn:active::after {
        transform: scale(2);
        opacity: 0;
        transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      }

      /* Attach button ripple effect */
      .attach-btn::after {
        content: '';
        position: absolute;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1);
        transform: scale(0);
        left: 50%;
        top: 50%;
        margin-left: -15px;
        margin-top: -15px;
      }

      .attach-btn:active::after {
        transform: scale(1);
        opacity: 0;
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
      }

      /* Input placeholder animation */
      @keyframes placeholderPulse {
        0% {
          opacity: 0.6;
        }

        50% {
          opacity: 1;
        }

        100% {
          opacity: 0.6;
        }
      }

      .chat-input input::placeholder {
        animation: placeholderPulse 2s infinite;
      }

      /* Make sure input is always visible */
      .chat-section {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        /* Smooth scrolling on iOS */
      }
    }

    /* Touch-specific styling for active elements */
    .touch-active {
      transform: scale(0.96) !important;
      opacity: 0.8;
      transition: transform 0.1s ease, opacity 0.1s ease;
    }

    #sendBtn.touch-active {
      background-color: var(--primary-hover);
    }

    .attach-btn.touch-active {
      color: var(--primary-color);
    }

    /* Ensure iOS Safari specific improvements */
    @supports (-webkit-touch-callout: none) {
      .chat-input input {
        font-size: 16px;
        /* Prevents iOS zoom on focus */
      }

      .chat-section {
        padding-bottom: 85px !important;
        /* Extra room for iOS virtual keyboard */
      }
    }

    /* Active model in dropdown */
    .dropdown-content a.active-model {
      background-color: #e8f4ff;
      color: #007bff;
      position: relative;
    }

    .dropdown-content a.active-model::after {
      content: '';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }

    body.dark-mode .dropdown-content a.active-model {
      background-color: #1a3554;
      color: #60a5fa;
    }

    /* Notification system */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 6px;
      background-color: #f8f9fa;
      color: #333;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
      z-index: 9999;
      transform: translateY(-20px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
      max-width: 300px;
      word-wrap: break-word;
    }

    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }

    .notification.info {
      background-color: #e7f2fd;
      border-left: 4px solid #2196F3;
    }

    .notification.success {
      background-color: #e8f6e9;
      border-left: 4px solid #4CAF50;
    }

    .notification.warning {
      background-color: #fff8e6;
      border-left: 4px solid #FF9800;
    }

    body.dark-mode .notification.error {
      background-color: #742a2a;
      border-left: 4px solid #f56565;
    }

    /* Test API button */
    .test-api-btn,
    .wake-up-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: var(--border-radius-sm);
      margin-top: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .test-api-btn:hover,
    .wake-up-btn:hover {
      background-color: var(--primary-hover);
    }

    .test-api-btn i,
    .wake-up-btn i {
      margin-right: 6px;
    }

    .wake-up-btn {
      background-color: #28a745;
    }

    .wake-up-btn:hover {
      background-color: #218838;
    }

    body.dark-mode .test-api-btn {
      background-color: #2d3748;
    }

    body.dark-mode .test-api-btn:hover {
      background-color: #4a5568;
    }

    body.dark-mode .wake-up-btn {
      background-color: #1e7e34;
    }

    body.dark-mode .wake-up-btn:hover {
      background-color: #155724;
    }

    .chat-input .attach-btn:hover {
      color: var(--primary-color);
    }

    .chat-input .image-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 12px;
      color: #888;
      cursor: pointer;
      transition: var(--transition);
    }

    .chat-input .image-btn:hover {
      color: var(--primary-color);
    }

    /* Mobile specific fixes */
  </style>

  <script>
    // Add haptic feedback for mobile interactions
    document.addEventListener('DOMContentLoaded', function () {
      // Haptic feedback function
      function vibrateOnTouch(duration = 20) {
        if ('vibrate' in navigator) {
          navigator.vibrate(duration);
        }
      }

      // Add haptic feedback to send button
      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) {
        sendBtn.addEventListener('touchstart', function () {
          vibrateOnTouch(20);
          this.classList.add('touch-active');
        }, { passive: true });

        sendBtn.addEventListener('touchend', function () {
          this.classList.remove('touch-active');
        }, { passive: true });
      }

      // Add haptic feedback to attach button
      const attachBtn = document.querySelector('.attach-btn');
      if (attachBtn) {
        attachBtn.addEventListener('touchstart', function () {
          vibrateOnTouch(15);
          this.classList.add('touch-active');
        }, { passive: true });

        attachBtn.addEventListener('touchend', function () {
          this.classList.remove('touch-active');
        }, { passive: true });
      }

      // Improve message input focus handling
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        // Auto focus input when chat loads on mobile
        // but only if a chat is already selected
        if (window.innerWidth <= 992 && currentChatId) {
          setTimeout(() => {
            // Scroll to ensure input is visible without forcing focus
            const chatSection = document.querySelector('.chat-section');
            if (chatSection) {
              chatSection.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
          }, 300);
        }

        // Add haptic feedback when typing
        messageInput.addEventListener('keydown', function () {
          if (window.innerWidth <= 992) {
            vibrateOnTouch(5); // Very subtle vibration
          }
        }, { passive: true });
      }
    });
  </script>
</head>

<body>
  <div class="dashboard">
    <!-- Left Sidebar -->
    <div class="sidebar">
      <div class="chat-header">
        <h1><i class="fas fa-scale-balanced"></i> LegalMind</h1>
      </div>

      <div id="currentChat"
        style="margin-bottom: var(--spacing-md); font-weight: 500; font-size: 0.9rem; color: #6c757d;">
        <span>Current Chat:</span> <span id="currentChatName">None</span>
      </div>

      <button class="new-chat" onclick="addNewChat()">
        <i class="fas fa-plus"></i> New Chat
      </button>

      <ul class="chat-list" id="chatList"></ul>

      <div class="documents-preview">
        <h3><i class="fas fa-file-alt"></i> Documents</h3>
        <div id="documentPreviews"></div>
        <button class="documents-toggle" id="documentsToggle">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
    </div>

    <!-- Chat Section -->
    <div class="chat-section">
      <!-- Navigation Bar -->
      <div class="chat-nav">
        <div class="nav-left">
          <button class="menu-toggle" id="mobileMenuToggle" aria-label="Open menu">
            <i class="fas fa-bars"></i>
          </button>
          <div class="model-dropdown">
            <span class="nav-brand">LegalMind</span>
            <i class="fas fa-chevron-down" style="font-size: 0.8rem; margin-left: 5px;"></i>
          </div>
        </div>

        <div class="nav-right">
          <div class="nav-links">
            <div class="dropdown">
              <a href="#" onclick="togglePlansDropdown(event)">
                <i class="fas fa-crown"></i> Plans
              </a>
              <div class="dropdown-content" id="plansDropdown">
                <a href="#"><i class="fas fa-calendar-alt"></i> 1 Month  100</a>
                <a href="#"><i class="fas fa-calendar-alt"></i> 3 Months  250</a>
                <a href="#"><i class="fas fa-calendar-alt"></i> 1 Year  800</a>
              </div>
            </div>

            <div class="dropdown">
              <a href="#" onclick="toggleModelsDropdown(event)">
                <i class="fas fa-microchip"></i> <span id="currentModelDisplay">LegalMind</span>
              </a>
              <div class="dropdown-content" id="modelsDropdown">
                <a href="#" data-model="legalMind" onclick="setActiveModel('legalMind'); return false;"
                  class="active-model"><i class="fas fa-brain"></i> LegalMind (Abbasgamer1)</a>
                <a href="#" data-model="distilBert" onclick="setActiveModel('distilBert'); return false;"><i
                    class="fas fa-brain"></i> Distl-BERT Model</a>
                <a href="#" data-model="llama" onclick="setActiveModel('llama'); return false;"><i
                    class="fas fa-brain"></i> Llama Model</a>
              </div>
            </div>

            <a href="contact.html"><i class="fas fa-envelope"></i> Contact Us</a>
          </div>

          <div class="nav-profile">
            <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile" id="profilePicNav" />
            <div class="profile-menu" id="profileMenu">
              <div class="profile-menu-header">
                <span class="user-name" id="profileUserName">User Name</span>
                <span class="user-plan">Subscription: Basic</span>
              </div>

              <div class="profile-menu-actions" id="profileMainMenu">
                <button class="profile-menu-btn" id="settingsButton">
                  <i class="fas fa-cog"></i> Settings
                </button>
                <button class="profile-menu-btn logout" id="logoutButton">
                  <i class="fas fa-sign-out-alt"></i> Logout
                </button>
              </div>

              <div class="settings-panel" id="settingsPanel">
                <button class="back-to-menu" id="backToMenu">
                  <i class="fas fa-arrow-left"></i> Back
                </button>

                <div class="settings-section">
                  <div class="settings-section-header">
                    <i class="fas fa-moon"></i> Appearance
                  </div>
                  <label class="switch">
                    <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
                    <span>Dark Mode</span>
                  </label>
                </div>

                <div class="settings-section">
                  <div class="settings-section-header">
                    <i class="fas fa-user"></i> Profile Picture
                  </div>
                  <div class="profile-pic-upload">
                    <div class="profile-preview">
                      <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile Preview"
                        id="profilePreview">
                    </div>
                    <label for="uploadProfile" class="upload-btn">
                      <i class="fas fa-upload"></i> Choose File
                    </label>
                    <input type="file" id="uploadProfile" onchange="uploadProfilePicture(event)" accept="image/*"
                      style="display: none;">
                    <p id="uploadedFileName" class="file-name"></p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Mobile Menu -->
      <div class="mobile-menu-overlay" id="mobileMenuOverlay"></div>
      <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
          <img src="https://ui-avatars.com/api/?name=Legal&background=0D8ABC&color=fff" width="30" height="30"
            alt="Logo" style="border-radius: 50%;">
          <h1>LegalMind</h1>
        </div>
        <div class="mobile-menu-content">
          <button class="mobile-menu-btn new-chat-btn" onclick="addNewChat(); closeMobileMenu();">
            <i class="fas fa-plus"></i>
            <span>New chat</span>
          </button>

          <div class="mobile-section-header">Today</div>
          <div id="mobileTodayChats">
            <!-- Today's chats will be populated here -->
          </div>

          <div class="mobile-section-header">Previous days</div>
          <div id="mobilePreviousChats">
            <!-- Previous chats will be populated here -->
          </div>

          <div class="mobile-section-header">Features</div>
          <button class="mobile-menu-btn" onclick="toggleDocumentPreview(); closeMobileMenu();">
            <i class="fas fa-file-alt"></i>
            <span>Document Preview</span>
          </button>
          <button class="mobile-menu-btn" onclick="window.location.href='contact.html'">
            <i class="fas fa-envelope"></i>
            <span>Contact Us</span>
          </button>
        </div>
      </div>

      <div class="chat-box" id="chatBox">
        <div class="welcome-message">
          <h2>Hi, I'm LegalMind.</h2>
          <p>Ask me anything about legal documents and concepts.</p>
          <p><i class="fas fa-file-upload"></i> Upload documents using the paperclip icon or <i
              class="fas fa-camera"></i> upload images with text using the camera icon.</p>
          <div class="model-info">
            <i class="fas fa-plug"></i> Connected to <span id="welcomeModelName">LegalMind</span> model
            <span class="model-id">(revision: 81f0038)</span>
          </div>
        </div>
        <button class="scroll-bottom-btn" id="scrollBottomBtn" aria-label="Scroll to bottom">
          <i class="fas fa-chevron-down"></i>
        </button>
      </div>

      <div class="chat-input">
        <div class="input-container">
          <input type="text" id="messageInput" placeholder="Type your message..." aria-label="Type your message"
            onkeypress="if(event.key === 'Enter') sendMessage()">

          <span class="image-btn" onclick="document.getElementById('imageInput').click()">
            <i class="fas fa-camera"></i>
          </span>
          <input type="file" id="imageInput" accept="image/png,image/jpeg,image/jpg" style="display:none;"
            onchange="processImage(event)">

          <span class="attach-btn" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-paperclip"></i>
          </span>
          <input type="file" id="fileInput" accept=".pdf,.txt,.docx" style="display:none;"
            onchange="previewFile(event)">

          <button id="sendBtn" onclick="sendMessage()" aria-label="Send message">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="auth.js" type="module"></script>
  <script>
    // Global storage for chat conversations and documents
    let chats = {};
    let currentChatId = null;
    let uploadedDocuments = {}; // Store document content by filename

    // Model configuration
    const modelConfig = {
      legalMind: {
        name: "LegalMind",
        // Reordered endpoints to put LegalMind model first
        endpoints: [
          "https://api-inference.huggingface.co/models/Abbasgamer1/legalMind", // Legal mind first
          "https://api-inference.huggingface.co/models/deepseek-ai/DeepSeek-V3-0324" // DeepSeek as fallback
        ],
        // Auth tokens specific to LegalMind
        authTokens: [
          "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",  // Write token
          "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",  // Read token
        ],
        // Track which endpoint and token is currently being used
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        // Set this to false as we're now using LegalMind as default
        usingFallbackModel: false,
        // Response time in ms (to be measured)
        responseTime: 12000,
        // Specific timeout for legal documents
        legalDocTimeout: 20000
      },
      // DeepSeek math model specifically for math questions
      mathModel: {
        name: "LegalMind", // Display name stays as LegalMind for UI consistency
        endpoints: [
          "https://api-inference.huggingface.co/models/deepseek-ai/deepseek-math-7b-rl" // DeepSeek Math model
        ],
        authTokens: [
          "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",  // Write token
          "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"   // Read token
        ],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        usingFallbackModel: false,
        responseTime: 12000
      },
      // Mistral model for general questions
      mistralModel: {
        name: "LegalMind", // Display name stays as LegalMind for UI consistency
        endpoints: [
          "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2", // Mistral model
        ],
        authTokens: [
          "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",  // Write token
          "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"   // Read token
        ],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        usingFallbackModel: false,
        responseTime: 10000
      },
      // DeepSeek general model as fallback
      deepseekModel: {
        name: "LegalMind", // Display name stays as LegalMind for UI consistency
        endpoints: [
          "https://api-inference.huggingface.co/models/deepseek-ai/DeepSeek-V3-0324" // DeepSeek general model
        ],
        authTokens: [
          "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",  // Write token
          "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"   // Read token
        ],
        currentEndpointIndex: 0,
        currentTokenIndex: 0,
        usingFallbackModel: false,
        responseTime: 11000
      }
    };
    
    // Current active model
    let activeModel = "mistralModel"; // Default to Mistral for general queries
    // Flag to track if endpoints are being connected
    let connectingEndpoints = false;
    // Store conversation context for continuity
    let conversationHistory = {};
    // Track if document is a legal document
    let isLegalDocument = false;

    // Function to show a notification
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;

      // Add to body
      document.body.appendChild(notification);

      // Show with animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      // Auto-hide after 3 seconds
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // Function to set the active model
    function setActiveModel(modelKey) {
      if (modelConfig[modelKey]) {
        const previousModel = activeModel;
        activeModel = modelKey;

        // Update UI to indicate the active model
        const modelDropdown = document.getElementById("modelsDropdown");
        if (modelDropdown) {
          const menuItems = modelDropdown.querySelectorAll('a');
          menuItems.forEach(item => {
            if (item.getAttribute('data-model') === modelKey) {
              item.classList.add('active-model');
            } else {
              item.classList.remove('active-model');
            }
          });
        }

        // Update the model name in the dropdown header
        const currentModelDisplay = document.getElementById("currentModelDisplay");
        if (currentModelDisplay) {
          currentModelDisplay.textContent = modelConfig[modelKey].name;
        }

        // Update the welcome message model name
        const welcomeModelName = document.getElementById("welcomeModelName");
        if (welcomeModelName) {
          welcomeModelName.textContent = modelConfig[modelKey].name;
        }

        // Show notification if the model actually changed
        if (previousModel !== modelKey) {
          showNotification(`Model changed to ${modelConfig[modelKey].name}`, 'success');
        }

        return true;
      }
      return false;
    }

    // Initialize dark mode from preferences
    document.addEventListener('DOMContentLoaded', function() {
      // Check for saved dark mode preference
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').checked = true;
        if (document.getElementById('darkModeIcon')) {
          document.getElementById('darkModeIcon').classList.remove('fa-moon');
          document.getElementById('darkModeIcon').classList.add('fa-sun');
          document.getElementById('darkModeText').textContent = 'Light Mode';
        }
      }
      
      // Connect to all endpoints as soon as the website loads
      connectToAllEndpoints();
      
      // Create a new chat if none exists
      if (!currentChatId) {
        // Check if there are any existing chats in the list
        const chatList = document.getElementById("chatList");
        if (chatList && chatList.children.length === 0) {
          // If no chats exist, create a new one
          addNewChat();
        } else if (chatList && chatList.children.length > 0) {
          // If chats exist but none is selected, select the first one
          const firstChat = chatList.children[0];
          const chatId = firstChat.getAttribute("data-chat-id");
          if (chatId) {
            firstChat.classList.add('active');
            loadChat(chatId);
            
            // Add a default "Hi" message if this is a page reload but the chat exists
            setTimeout(() => {
              // Only add if this chat doesn't have any messages yet
              if (currentChatId && (!chats[currentChatId].messages || chats[currentChatId].messages.length === 0)) {
                // Add the message to the UI
                appendMessage("user", "Hi");
                
                // Add to conversation history for continuity
                if (!conversationHistory[currentChatId]) {
                  conversationHistory[currentChatId] = [];
                }
                conversationHistory[currentChatId].push({
                  role: "user",
                  content: "Hi"
                });
                
                // Automatically trigger a response
                setTimeout(() => {
                  const greetingResponse = getGreetingResponse();
                  appendMessage("bot", greetingResponse);
                  
                  // Store in conversation history
                  conversationHistory[currentChatId].push({
                    role: "assistant",
                    content: greetingResponse
                  });
                }, 500);
              }
            }, 300);
          }
        }
      }
      
      // Mobile menu handlers
      document.getElementById('mobileMenuToggle').addEventListener('click', function () {
        document.getElementById('mobileMenu').classList.add('active');
        document.getElementById('mobileMenuOverlay').classList.add('active');
        updateMobileChats();
      });

      document.getElementById('mobileMenuOverlay').addEventListener('click', closeMobileMenu);

      // Check screen width and adapt layout
      function checkScreenWidth() {
        const sidebar = document.querySelector('.sidebar');
        if (window.innerWidth <= 992 && sidebar) {
          if (!sidebar.classList.contains('collapsed')) {
            sidebar.classList.add('collapsed');
          }
        }
      }

      // Initial check
      checkScreenWidth();

      // Listen for window resize
      window.addEventListener('resize', checkScreenWidth);

      // Fix mobile scrolling issues for chat box
      const chatBox = document.getElementById('chatBox');
      if (chatBox) {
        window.addEventListener('resize', function () {
          if (window.innerWidth <= 992) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
        });

        // Handle welcome message visibility on scroll
        const welcomeMessage = document.querySelector('.welcome-message');

        if (welcomeMessage) {
          // Show welcome message initially
          welcomeMessage.classList.remove('hidden');

          // Check on scroll
          chatBox.addEventListener('scroll', function () {
            if (chatBox.scrollTop > 10) {
              welcomeMessage.classList.add('hidden');
            } else {
              welcomeMessage.classList.remove('hidden');
            }
          });
        }
      }

      // Make document preview fully visible on page load with enhanced visibility
      const previewSection = document.querySelector('.documents-preview');
      if (previewSection) {
        previewSection.style.display = 'block';
        previewSection.style.visibility = 'visible';
        previewSection.style.opacity = '1';
        previewSection.style.zIndex = '5';

        // Initialize preview area
        const documentPreviews = document.getElementById('documentPreviews');
        if (documentPreviews && documentPreviews.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          documentPreviews.appendChild(welcomeText);
        }
      }

      // Simplified documents toggle functionality with forced visibility
      const documentsToggle = document.getElementById('documentsToggle');
      const documentPreviews = document.getElementById('documentPreviews');

      if (documentsToggle && documentPreviews) {
        // Make sure it starts visible
        documentPreviews.style.display = 'block';

        documentsToggle.addEventListener('click', function () {
          if (documentPreviews.style.display === 'none') {
            documentPreviews.style.display = 'block';
            this.querySelector('i').classList.remove('fa-chevron-down');
            this.querySelector('i').classList.add('fa-chevron-up');
          } else {
            documentPreviews.style.display = 'none';
            this.querySelector('i').classList.remove('fa-chevron-up');
            this.querySelector('i').classList.add('fa-chevron-down');
          }
        });
      }

      // Add mobile menu button to toggle document visibility
      document.getElementById('toggleSidebarBtn').addEventListener('click', function () {
        toggleSidebar();
        document.getElementById('mobileMenu').classList.remove('active');
      });
    });

    function addNewChat() {
      const chatList = document.getElementById("chatList");
      const chatId = "chat_" + Date.now();
      const chatName = "Chat " + (chatList.children.length + 1);

      const chatItem = document.createElement("li");
      chatItem.setAttribute("data-chat-id", chatId);
      chatItem.innerHTML = `
        <span>${chatName}</span>
        <button class="delete-chat" onclick="deleteChat(event, this)" aria-label="Delete chat">
          <i class="fas fa-times"></i>
        </button>
      `;
      
      chatItem.addEventListener("click", function(e) {
        if (e.target.classList.contains("delete-chat") || e.target.closest('.delete-chat')) return;
        
        document.querySelectorAll('#chatList li').forEach(item => {
          item.classList.remove('active');
        });
        
        this.classList.add('active');
        loadChat(chatId, chatName);
        
        // On mobile, collapse sidebar after selecting chat
        if (window.innerWidth <= 992) {
          document.querySelector('.sidebar').classList.add('collapsed');
        }
      });
      
      chatList.appendChild(chatItem);
      chats[chatId] = [];
      loadChat(chatId, chatName);
      
      // Show the chat list after creating new chat
      const sidebar = document.querySelector('.sidebar');
      if (sidebar.classList.contains('collapsed')) {
        sidebar.classList.remove('collapsed');
      }
      
      // Update mobile menu after adding new chat
      setTimeout(updateMobileChats, 100);
      
      // Add a default "Hi" message from the user with slight delay to ensure chat is loaded
      setTimeout(() => {
        if (currentChatId === chatId) {
          // Add the message to the UI
          appendMessage("user", "Hi");
          
          // Add to conversation history for continuity
          if (!conversationHistory[chatId]) {
            conversationHistory[chatId] = [];
          }
          conversationHistory[chatId].push({
            role: "user",
            content: "Hi"
          });
          
          // Automatically trigger a response to the greeting after a short delay
          setTimeout(() => {
            const greetingResponse = getGreetingResponse();
            appendMessage("bot", greetingResponse);
            
            // Store in conversation history
            conversationHistory[chatId].push({
              role: "assistant",
              content: greetingResponse
            });
          }, 500);
        }
      }, 300);
    }

    function loadChat(chatId) {
      // Set current chat
      currentChatId = chatId;

      // Clear chat box
      const chatBox = document.getElementById("chatBox");
      chatBox.innerHTML = '';

      // Always add welcome message
      const welcomeMessage = document.createElement("div");
      welcomeMessage.classList.add("welcome-message");
      welcomeMessage.innerHTML = `
            <h2>Hi, I'm LegalMind.</h2>
            <p>Ask me anything about legal documents and concepts.</p>
            <p><i class="fas fa-file-upload"></i> Upload documents using the paperclip icon and I can analyze them for you.</p>
        `;
      chatBox.appendChild(welcomeMessage);

      // Add scroll button
      const scrollBtn = document.createElement("button");
      scrollBtn.className = "scroll-bottom-btn";
      scrollBtn.id = "scrollBottomBtn";
      scrollBtn.setAttribute("aria-label", "Scroll to bottom");
      scrollBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
      chatBox.appendChild(scrollBtn);

      // Update current chat name
      document.getElementById("currentChatName").textContent = chats[chatId]?.name || "New Chat";

      // Load messages for this chat and append them
      if (chats[chatId] && chats[chatId].messages) {
        chats[chatId].messages.forEach(msg => {
          if (msg.type === "text") {
            // Use a special version that doesn't auto-scroll during loading
            const msgDiv = document.createElement("div");
            msgDiv.textContent = msg.content;
            msgDiv.classList.add("message", msg.sender);
            chatBox.appendChild(msgDiv);
          } else if (msg.type === "html") {
            // Use a special version that doesn't auto-scroll during loading
            const msgDiv = document.createElement("div");
            msgDiv.innerHTML = msg.content;
            msgDiv.classList.add("message", msg.sender);
            chatBox.appendChild(msgDiv);
          }
        });
      }

      // Set active class for chat items
      const chatItems = document.querySelectorAll(".chat-item, .mobile-chat-item");
      chatItems.forEach(item => {
        item.classList.remove("active");
        if (item.getAttribute("data-chat-id") === chatId) {
          item.classList.add("active");
        }
      });

      // Focus input field to make keyboard appear on mobile
      setTimeout(() => {
        const messageInput = document.getElementById("messageInput");
        if (messageInput && window.innerWidth <= 992) {
          // On mobile, scroll to make input visible and focus it
          const chatSection = document.querySelector(".chat-section");
          if (chatSection) {
            chatSection.scrollTop = chatSection.scrollHeight;
          }

          // Gently scroll to show input without forcefully focusing
          // (which would bring up keyboard automatically)
          chatBox.scrollTo({
            top: chatBox.scrollHeight,
            behavior: 'auto'
          });
        }

        // Initialize the scroll button (check visibility)
        const scrollBottomBtn = document.getElementById('scrollBottomBtn');
        if (scrollBottomBtn) {
          const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;
          if (isAtBottom) {
            scrollBottomBtn.classList.remove('visible');
          } else {
            scrollBottomBtn.classList.add('visible');
          }
        }
      }, 100);
    }

    function deleteChat(event, button) {
      event.stopPropagation();
      const chatItem = button.closest('li');
      const chatId = chatItem.getAttribute("data-chat-id");

      if (chats[chatId]) {
        delete chats[chatId];
      }
      chatItem.remove();

      if (currentChatId === chatId) {
        currentChatId = null;
        const chatBox = document.getElementById("chatBox");
        const welcomeMessage = document.querySelector('.welcome-message');

        // Clear chat and ensure welcome message is preserved
        if (welcomeMessage) {
          chatBox.innerHTML = '';
          welcomeMessage.classList.remove('hidden');
          chatBox.appendChild(welcomeMessage);
        } else {
          chatBox.innerHTML = '';
        }

        document.getElementById("currentChatName").textContent = "None";
      }

      // Update mobile menu after deleting chat
      setTimeout(updateMobileChats, 100);
    }

    // Improved appendMessage function with less intrusive scrolling
    window.appendMessage = function (sender, text) {
      const chatBox = document.getElementById('chatBox');
      if (!chatBox) return;

      const msgDiv = document.createElement("div");
      msgDiv.textContent = text;
      msgDiv.classList.add("message", sender);

      // Check if we're at the bottom before adding the message
      const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;

      // Append the message
      chatBox.appendChild(msgDiv);

      // Only auto-scroll if we were already at the bottom
      if (wasAtBottom) {
        chatBox.scrollTo({
          top: chatBox.scrollHeight,
          behavior: 'smooth'
        });
      }

      // Store in current chat if available
      if (currentChatId && chats[currentChatId]) {
        if (!chats[currentChatId].messages) {
          chats[currentChatId].messages = [];
        }
        chats[currentChatId].messages.push({
          type: 'text',
          sender: sender,
          content: text
        });
      }
    };

    // Updated appendHtmlMessage function
    window.appendHtmlMessage = function (sender, htmlContent) {
      const chatBox = document.getElementById('chatBox');
      if (!chatBox) return;

      const msgDiv = document.createElement("div");
      msgDiv.innerHTML = htmlContent;
      msgDiv.classList.add("message", sender);

      // Special handling for thinking messages
      if (htmlContent.includes('data-thinking="true"')) {
        // Replace with new thinking animation
        const thinkingContainer = document.createElement("div");
        thinkingContainer.className = "thinking-container";

        // Add brain icon and thinking text
        thinkingContainer.innerHTML = `
                <span class="thinking-brain"><i class="fas fa-brain"></i></span>
                <span>Thinking</span>
                <div class="thinking-dots">
                    <span class="thinking-dot"></span>
                    <span class="thinking-dot"></span>
                    <span class="thinking-dot"></span>
                </div>
            `;

        // Add some context about what the model is doing
        const thinkingContext = document.createElement("span");
        thinkingContext.className = "thinking-context";

        // Rotate through different thinking messages
        const thinkingMessages = [
          "Analyzing your question...",
          "Retrieving relevant information...",
          "Formulating a response...",
          "Checking context from previous messages...",
          "Organizing thoughts..."
        ];

        // Start the thinking context animation
        let messageIndex = 0;
        const thinkingInterval = setInterval(() => {
          thinkingContext.textContent = thinkingMessages[messageIndex];
          messageIndex = (messageIndex + 1) % thinkingMessages.length;
        }, 4000);

        // Store the interval ID on the element to clear it later
        thinkingContainer.dataset.intervalId = thinkingInterval;

        thinkingContainer.appendChild(thinkingContext);
        msgDiv.innerHTML = '';
        msgDiv.appendChild(thinkingContainer);
      }

      // Check if we're at the bottom before adding the message
      const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;

      // Append the message
      chatBox.appendChild(msgDiv);

      // Only auto-scroll if we were already at the bottom
      if (wasAtBottom) {
        chatBox.scrollTo({
          top: chatBox.scrollHeight,
          behavior: 'smooth'
        });
      }

      // Store in current chat if available
      if (currentChatId && chats[currentChatId]) {
        if (!chats[currentChatId].messages) {
          chats[currentChatId].messages = [];
        }
        chats[currentChatId].messages.push({
          type: 'html',
          sender: sender,
          content: htmlContent
        });
      }
    };

    // Function to check if the message is asking about chatbot identity
    function isIdentityQuestion(text) {
      const lowerText = text.toLowerCase().trim();

      // Check for common identity questions
      const identityPatterns = [
        /^who are you/,
        /^what are you/,
        /tell me about yourself/,
        /^who is legal ?mind/,
        /^what is legal ?mind/,
        /introduce yourself/,
        /your name/,
        /^who created you/,
        /^who made you/,
        /^who is your owner/,
        /^what do you do/,
        /^what can you do/
      ];

      return identityPatterns.some(pattern => pattern.test(lowerText));
    }

    // Function to handle identity questions
    function getIdentityResponse(text) {
      const lowerText = text.toLowerCase().trim();

      // Check if asking about creator/owner
      if (lowerText.includes("who made you") ||
        lowerText.includes("who created you") ||
        lowerText.includes("who is your owner") ||
        lowerText.includes("who developed you")) {
        return "I was created by Mohammad Suheb Abbas. You can find the project repository at https://github.com/SM-Abbas/Final-Year-Project-54";
      }

      // Default identity response
      return "I am LegalMind, an AI legal assistant that specializes in analyzing legal documents. I can help review contracts, legal agreements, and other documents, providing insights and suggestions for improvements. If you have a document you'd like me to analyze, please upload it using the paperclip icon in the chat input.";
    }

    // Function to determine if a question is a continuation of previous conversation
    function isContinuationQuestion(text, messages) {
      if (!text || !messages || messages.length < 2) return false;

      const lowerText = text.toLowerCase().trim();

      // Very short questions are often continuations
      if (lowerText.split(' ').length <= 5) {
        return true;
      }

      // Check for pronouns and continuation phrases
      const continuationPatterns = [
        /\b(it|this|that|they|them|these|those)\b/i,
        /\b(its|their|theirs)\b/i,
        /\b(why|how|what|when|where|who)\b.*\?$/i,
        /^(and|but|so|also|besides|additionally)\b/i,
        /\b(more|elaboration|clarify|explain|details)\b/i,
        /\bcan you/i,
        /\b(the|your|previous) (answer|response|explanation)\b/i
      ];

      return continuationPatterns.some(pattern => pattern.test(lowerText));
    }

    // Function to detect and filter inappropriate content related to intimacy
    function containsInappropriateContent(text) {
      if (!text) return false;

      const lowerText = text.toLowerCase().trim();

      // Define patterns for inappropriate content related to intimacy
      const inappropriatePatterns = [
        /\b(sex|sexual|sexuality|nude|naked|porn|explicit|adult content)\b/i,
        /\b(intercourse|foreplay|orgasm|climax|ejacul|penetrat)\w*\b/i,
        /\b(masturbat|genital|privates|private parts)\w*\b/i,
        /\b(erotic|erotica|69|bdsm|fetish|kink)\b/i,
        /\b(nsfw|xxx|x-rated|arousal|aroused)\b/i,
        /\b(boob|breast|tit|ass|butt|penis|vagina|dick|cock|pussy)\w*\b/i,
        /\b(fuck|fucking|fucked|anal|oral sex|blow job|hand job)\b/i,
        /\b(intimate|intimacy)\b.*\b(physical|detail|guide|how|instruct)/i,
        /\b(dirty talk|obscen|lewd|lust|horny|sensual pleasure)\b/i
      ];

      return inappropriatePatterns.some(pattern => pattern.test(lowerText));
    }

    // Send message function
    function sendMessage() {
      const messageInput = document.getElementById("messageInput");
      const userMessageText = messageInput.value.trim();
      messageInput.value = "";

      // Don't send empty messages
      if (!userMessageText) return;

      if (currentChatId) {
        // Check for inappropriate content before proceeding
        if (containsInappropriateContent(userMessageText)) {
          // Display user message but mark it as flagged
          appendMessage("user", userMessageText);

          // Send censored response
          setTimeout(() => {
            const moderationResponse = "I'm designed to provide legal and professional assistance only. I cannot discuss topics related to intimate or adult content. Please keep our conversation professional and focused on legal document analysis and advice. How else can I assist you today?";
            appendMessage("bot", moderationResponse);

            // Add to chat history
            if (!chats[currentChatId].messages) {
              chats[currentChatId].messages = [];
            }
            chats[currentChatId].messages.push({
              sender: "user",
              content: userMessageText
            });
            chats[currentChatId].messages.push({
              sender: "bot",
              content: moderationResponse
            });

            // Store in conversation history for continuity
            if (!conversationHistory[currentChatId]) {
              conversationHistory[currentChatId] = [];
            }
            conversationHistory[currentChatId].push({
              role: "user",
              content: userMessageText
            });
            conversationHistory[currentChatId].push({
              role: "assistant",
              content: moderationResponse
            });
          }, 300);
          return;
        }

        // Append user message to chat
        appendMessage("user", userMessageText);

        // Add message to chat history
        if (!chats[currentChatId].messages) {
          chats[currentChatId].messages = [];
        }
        chats[currentChatId].messages.push({
          sender: "user",
          content: userMessageText
        });

        // Add to conversation history for continuity
        if (!conversationHistory[currentChatId]) {
          conversationHistory[currentChatId] = [];
        }
        conversationHistory[currentChatId].push({
          role: "user",
          content: userMessageText
        });

        // Check for identity questions and provide canned response
        if (isIdentityQuestion(userMessageText)) {
          // Provide standard identity response
          const identityResponse = getIdentityResponse(userMessageText);
          setTimeout(() => {
            console.log("Responding with identity response:", identityResponse);
            appendMessage("bot", identityResponse);

            // Store in conversation history
            conversationHistory[currentChatId].push({
              role: "assistant",
              content: identityResponse
            });
          }, 300);
          return;
        }

        // Check for greeting messages
        if (isGreeting(userMessageText)) {
          // Provide greeting response
          const greetingResponse = getGreetingResponse();
          setTimeout(() => {
            console.log("Responding with greeting response:", greetingResponse);
            appendMessage("bot", greetingResponse);

            // Store in conversation history
            conversationHistory[currentChatId].push({
              role: "assistant",
              content: greetingResponse
            });
          }, 300);
          return;
        }

        // Detect if this is a math question and use the math model
        let selectedModel = activeModel;
        if (isMathQuestion(userMessageText)) {
          console.log("Detected math question, using DeepSeek Math model");
          selectedModel = "mathModel";
        } else if (isLegalDocument) {
          console.log("Using LegalMind model for legal document analysis");
          selectedModel = "legalMind";
        }
        
        // Show typing indicator with a slight delay
        const typingIndicator = setTimeout(() => {
          // Get current model name - always show LegalMind in UI regardless of actual model
          const displayModelName = "LegalMind";
          let modelName = displayModelName;
          
          // Create thinking message with model info and data attribute for animation
          const thinkingMessage = `<span data-thinking="true">Thinking...</span>`;
          appendHtmlMessage("bot", thinkingMessage);
          
          // Reference to the thinking message to remove it later
          const thinkingMsg = document.querySelector(".message.bot:last-child");

          // Prepare conversation history for context
          let conversationContext = "";
          if (conversationHistory[currentChatId] && conversationHistory[currentChatId].length > 0) {
            // Check if this appears to be a continuation question
            const isContinuation = isContinuationQuestion(userMessageText, chats[currentChatId].messages);

            // Get more context for continuations, otherwise use standard context length
            const contextLength = isContinuation ? 15 : 10;

            // Get recent messages for context, more if it's a continuation
            const recentMessages = conversationHistory[currentChatId].slice(-contextLength);

            for (const msg of recentMessages) {
              if (msg.role === "user") {
                conversationContext += "User: " + msg.content + "\n";
              } else if (msg.role === "assistant") {
                conversationContext += "Assistant: " + msg.content + "\n";
              }
            }

            console.log("Is continuation question:", isContinuation);
          }

          // Add the current query
          let fullPrompt = "You are LegalMind, a helpful assistant. Please respond to this query:\n" +
            conversationContext +
            "User: " + userMessageText + "\nAssistant:";

          // If using the math model, use a specialized prompt
          if (selectedModel === "mathModel") {
            fullPrompt = "You are LegalMind, a helpful assistant specialized in solving mathematical problems. Focus on providing clear, step-by-step solutions for math questions. For other questions, respond normally.\n" +
              conversationContext +
              "User: " + userMessageText + "\nAssistant:";
          }

          // If we're using the DeepSeek model, use its recommended format
          const currentEndpointInfo = getCurrentEndpointInfo(selectedModel);
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek")) {
            // DeepSeek format with current date
            const today = new Date();
            const formattedDate = today.toLocaleDateString('en-US', {
              month: 'long',
              day: 'numeric',
              weekday: 'long'
            });

            fullPrompt = `DeepSeek Chat\n${formattedDate}\n\n` +
              conversationContext +
              "User: " + userMessageText + "\nAssistant:";
            console.log("Using DeepSeek model with specialized prompt format");
          }

          console.log("Sending prompt:", fullPrompt);

          // Get document context if applicable
          const documentContext = getDocumentContext(userMessageText);
          let finalPrompt = fullPrompt;

          // Check if there are uploaded documents
          const hasDocuments = Object.keys(uploadedDocuments).length > 0;

          // Always include document context if available, regardless of the query
          if (hasDocuments) {
            if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek")) {
              finalPrompt =
                `DeepSeek Chat\n${formattedDate}\n\n` +
                "Document(s) uploaded by user:" +
                documentContext +
                "\n\n" + conversationContext +
                "User: " + userMessageText + "\n" +
                "Always analyze the document(s) in your response. Include a section titled 'Document Summary' with key points, and a section titled 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness.\n" +
                "Assistant:";
            } else {
              finalPrompt =
                "You are LegalMind, a legal assistant that specializes in document analysis.\n\n" +
                "User has uploaded the following document(s):" +
                documentContext +
                "\n\n" + conversationContext +
                "User: " + userMessageText + "\n" +
                "Always analyze the document(s) in your response. Include a section titled 'Document Summary' with key points, and a section titled 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness.\n" +
                "Assistant:";
            }

            console.log("Sending prompt with document context (length: " + finalPrompt.length + " chars)");
          }

          // Connect to the Hugging Face endpoint
          console.log("Making API request to:", modelConfig[selectedModel].endpoints[modelConfig[selectedModel].currentEndpointIndex]);

          // Prepare API request parameters
          let requestParams = {
            max_new_tokens: 1024,
            temperature: 0.7,
            top_p: 0.95,
            do_sample: true,
            return_full_text: false
          };

          // Use DeepSeek's recommended parameters if using the DeepSeek model
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek")) {
            requestParams = {
              max_new_tokens: 1024,
              temperature: 0.3,  // DeepSeek recommends 0.3
              top_p: 0.8,
              do_sample: true
            };
          }

          // Use dynamic timeout based on measured response time (default to 15s if not measured)
          const timeoutDuration = modelConfig[selectedModel].timeout || 15000;

          // Create a timeout promise that will reject after the configured timeout
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error(`API request timed out after ${timeoutDuration / 1000} seconds`));
            }, timeoutDuration);
          });

          // Race between the fetch request and the timeout
          Promise.race([
            fetch(modelConfig[selectedModel].endpoints[modelConfig[selectedModel].currentEndpointIndex], {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${modelConfig[selectedModel].authTokens[modelConfig[selectedModel].currentTokenIndex]}`
              },
              body: JSON.stringify({
                inputs: finalPrompt,
                parameters: requestParams
              })
            }),
            timeoutPromise
          ])
            .then(response => {
              console.log("API Response Status:", response.status);
              console.log("API Response Headers:", [...response.headers.entries()]);

              // Add a verification message to the console
              console.log("API REQUEST SENT SUCCESSFULLY - Waiting for response from: " + modelConfig[selectedModel].endpoints[modelConfig[selectedModel].currentEndpointIndex]);

              if (!response.ok) {
                console.error("API Error:", response.status, response.statusText);
                // Try to get more error details
                return response.text().then(text => {
                  console.error("API Error Details:", text);
                  throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
                });
              }
              return response.json();
            })
            .then(data => {
              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }

              // Log complete response data for debugging
              console.log("Complete API Response:", JSON.stringify(data));

              // Add bot response from the API
              let botResponse = ""; // Empty default

              // Specific handling for Mistral model
              if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                botResponse = data[0].generated_text.trim();
                console.log("Using array[0].generated_text format");
              } else if (data && data.generated_text) {
                botResponse = data.generated_text.trim();
                console.log("Using data.generated_text format");
              } else if (typeof data === 'string') {
                botResponse = data.trim();
                console.log("Using string format");
              } else if (data && data.choices && data.choices.length > 0) {
                // Handle OpenAI-like format
                botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
                console.log("Using OpenAI-like format");
              } else {
                console.warn("Unexpected API response format:", data);
                botResponse = "I apologize, but I received an unexpected response format. Please try again with your question.";
              }

              // If we are using the DeepSeek model, check response for any non-English part and format
              if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek") && botResponse) {
                // Remove any "Assistant:" prefix that might be in the response
                botResponse = botResponse.replace(/^Assistant:\s*/i, '');

                // If response starts with Chinese characters, try to find the first English part
                if (/^[\u4e00-\u9fa5]/.test(botResponse)) {
                  const englishPart = botResponse.match(/[a-zA-Z]/);
                  if (englishPart && englishPart.index > 0) {
                    botResponse = botResponse.substring(englishPart.index);
                  }
                }
              }

              // Safety check for empty responses
              if (!botResponse) {
                botResponse = "I apologize, but I received an empty response. Please try asking your question again.";
              }

              // Add to chat history
              chats[currentChatId].messages.push({
                sender: "bot",
                content: botResponse
              });

              // Store in conversation history for continuity
              conversationHistory[currentChatId].push({
                role: "assistant",
                content: botResponse
              });

              // Detect if this is a document analysis response
              const isDocumentAnalysis = botResponse.includes('Document Summary') &&
                botResponse.includes('Document Improvement Suggestions');

              appendMessage("bot", botResponse);

              // For document analysis responses, add action buttons
              if (isDocumentAnalysis && Object.keys(uploadedDocuments).length > 0) {
                // Get the most recently uploaded document
                const documentNames = Object.keys(uploadedDocuments);
                const latestDocument = documentNames[documentNames.length - 1];

                if (latestDocument) {
                  // Find the last bot message element
                  const chatBox = document.getElementById('chatBox');
                  const botMessages = chatBox.querySelectorAll('.message.bot');
                  if (botMessages.length > 0) {
                    const lastBotMessage = botMessages[botMessages.length - 1];

                    // Add action buttons to the message
                    addDocumentActionButtons(lastBotMessage, latestDocument);
                  }
                }
              }
            })
            .catch(error => {
              console.error("Error connecting to LegalMind API:", error);
              console.error("Full error details:", {
                message: error.message,
                stack: error.stack,
                endpoint: modelConfig[selectedModel].endpoints[modelConfig[selectedModel].currentEndpointIndex]
              });

              // Specific handling for timeout errors
              if (error.message.includes('timed out')) {
                console.log("API request timed out - automatically trying next endpoint");
                showNotification("Getting response, please wait...", "warning");

                // Automatically try the next endpoint or token
                if (tryNextEndpointOrToken(selectedModel)) {
                  const endpointInfo = getCurrentEndpointInfo(selectedModel);
                  console.log(`Switching to endpoint ${endpointInfo.endpointIndex} after timeout`);

                  // Remove the thinking message if it exists
                  if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                  }

                  // Retry with new endpoint/token (after a short delay)
                  setTimeout(() => sendMessage(), 1000);
                  return;
                }
              }

              // Try alternative endpoint or token for other errors
              if (tryNextEndpointOrToken(selectedModel)) {
                const endpointInfo = getCurrentEndpointInfo(selectedModel);
                console.log(`Switching to endpoint ${endpointInfo.endpointIndex} after error`);

                // Remove the thinking message if it exists
                if (thinkingMsg && thinkingMsg.parentNode) {
                  thinkingMsg.parentNode.removeChild(thinkingMsg);
                }

                // Retry with new endpoint/token (after a short delay)
                setTimeout(() => sendMessage(), 1000);
                return;
              }

              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }

              // Check if it's an authorization error
              let errorMessage;
              if (error.message.includes("401") || error.message.includes("unauthorized")) {
                errorMessage = "Authentication error: Please check your API token.";
                showNotification("API Token error. Please update your authentication token.", "error");
              } else if (error.message.includes("429")) {
                errorMessage = "Rate limit exceeded. Please try again later.";
                showNotification("Too many requests. Please wait a moment.", "warning");
              } else if (error.message.includes("CORS") || error.message.includes("Failed to fetch")) {
                errorMessage = "Network error: CORS or connectivity issue. Please check your network settings or try the Test API Connection button.";
                showNotification("Network connectivity issue. Try the Test API Connection button.", "error");
              } else if (error.message.includes('timed out')) {
                errorMessage = "The model took too long to respond. I've tried all available models but none responded in time.";
                showNotification("All models timed out. Please try again later.", "error");
              } else {
                errorMessage = "I'm having trouble connecting to my knowledge base right now. Please try again later.";
                showNotification("Connection error to LegalMind API", "error");
              }

              // Fallback response in case of error
              appendMessage("bot", errorMessage);
            });

        }, 300);
      } else if (!currentChatId) {
        // If no chat is active, create one and then send
        addNewChat();
        // Delay sending to ensure chat is created
        setTimeout(() => sendMessage(), 100);
      }
    }

    // Add bot message
    function addBotMessage(text) {
      const botMsg = { sender: "bot", text: text };
      chats[currentChatId].push(botMsg);
      appendMessage("bot", text);
    }

    // Toggle dark mode
    function toggleDarkMode() {
      const isDarkMode = document.body.classList.toggle("dark-mode");
      const darkModeIcon = document.getElementById('darkModeIcon');
      const darkModeText = document.getElementById('darkModeText');

      if (isDarkMode) {
        localStorage.setItem('darkMode', 'enabled');
        if (darkModeIcon) {
          darkModeIcon.classList.remove('fa-moon');
          darkModeIcon.classList.add('fa-sun');
          darkModeText.textContent = 'Light Mode';
        }
      } else {
        localStorage.setItem('darkMode', 'disabled');
        if (darkModeIcon) {
          darkModeIcon.classList.remove('fa-sun');
          darkModeIcon.classList.add('fa-moon');
          darkModeText.textContent = 'Dark Mode';
        }
      }
    }

    function togglePlansDropdown(event) {
      event.preventDefault();
      const dropdown = document.getElementById("plansDropdown");
      dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";

      // Close other dropdowns
      document.getElementById("modelsDropdown").style.display = "none";
    }

    function toggleModelsDropdown(event) {
      event.preventDefault();
      const dropdown = document.getElementById("modelsDropdown");
      dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";

      // Close other dropdowns
      document.getElementById("plansDropdown").style.display = "none";
    }

    // Profile menu toggle and settings functionality
    document.addEventListener('DOMContentLoaded', function () {
      // Check for saved dark mode preference
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').checked = true;
      }

      // Profile menu toggle - fix for both mobile and desktop
      const profilePic = document.getElementById('profilePicNav');
      const profileMenu = document.getElementById('profileMenu');

      if (profilePic && profileMenu) {
        profilePic.addEventListener('click', function (e) {
          e.stopPropagation();
          profileMenu.classList.toggle('active');
        });
      }

      // Settings button
      const settingsButton = document.getElementById('settingsButton');
      const profileMainMenu = document.getElementById('profileMainMenu');
      const settingsPanel = document.getElementById('settingsPanel');

      if (settingsButton && profileMainMenu && settingsPanel) {
        settingsButton.addEventListener('click', function () {
          profileMainMenu.style.display = 'none';
          settingsPanel.classList.add('active');
        });
      }

      // Back to menu button
      const backToMenu = document.getElementById('backToMenu');
      if (backToMenu && profileMainMenu && settingsPanel) {
        backToMenu.addEventListener('click', function () {
          profileMainMenu.style.display = 'flex';
          settingsPanel.classList.remove('active');
        });
      }

      // Close profile menu when clicking outside
      document.addEventListener('click', function (event) {
        if (profileMenu && profileMenu.classList.contains('active')) {
          if (!event.target.closest('.nav-profile') && !event.target.closest('.profile-menu')) {
            profileMenu.classList.remove('active');
            // Reset to main menu view when closing
            if (profileMainMenu && settingsPanel) {
              profileMainMenu.style.display = 'flex';
              settingsPanel.classList.remove('active');
            }
          }
        }
      });
    });

    // Update the toggleSidebar function to properly handle document preview visibility
    function toggleSidebar() {
      const sidebar = document.querySelector('.sidebar');
      const documentsPreview = document.querySelector('.documents-preview');

      if (sidebar) {
        sidebar.classList.toggle('collapsed');

        if (sidebar.classList.contains('collapsed')) {
          if (documentsPreview) {
            documentsPreview.style.display = 'none';
          }
        } else {
          if (documentsPreview) {
            documentsPreview.style.display = 'flex';
            const documentPreviews = document.getElementById('documentPreviews');
            if (documentPreviews) {
              documentPreviews.style.display = 'block';
            }
          }
        }
      }
    }

    function closeMobileMenu() {
      document.getElementById('mobileMenu').classList.remove('active');
      document.getElementById('mobileMenuOverlay').classList.remove('active');
    }

    function toggleDocumentPreview() {
      // For simplicity in mobile version, just toggle sidebar visibility
      const sidebar = document.querySelector('.sidebar');

      if (window.innerWidth <= 992) {
        // On mobile, show the sidebar which contains document preview
        if (sidebar.style.display === 'none' || sidebar.style.display === '') {
          sidebar.style.display = 'flex';
          sidebar.classList.remove('collapsed');

          // Make sure documents preview is visible
          const documentsPreview = document.querySelector('.documents-preview');
          if (documentsPreview) {
            documentsPreview.style.display = 'flex';
            const documentPreviews = document.getElementById('documentPreviews');
            if (documentPreviews) {
              documentPreviews.style.display = 'block';
            }
          }
        } else {
          sidebar.style.display = 'none';
        }
      } else {
        // On desktop, toggle collapsed state
        sidebar.classList.toggle('collapsed');

        if (sidebar.classList.contains('collapsed')) {
          const documentsPreview = document.querySelector('.documents-preview');
          if (documentsPreview) {
            documentsPreview.style.display = 'none';
          }
        } else {
          const documentsPreview = document.querySelector('.documents-preview');
          if (documentsPreview) {
            documentsPreview.style.display = 'flex';
            const documentPreviews = document.getElementById('documentPreviews');
            if (documentPreviews) {
              documentPreviews.style.display = 'block';
            }
          }
        }
      }

      closeMobileMenu();
    }

    // Function to update mobile chats list
    function updateMobileChats() {
      const todayContainer = document.getElementById('mobileTodayChats');
      const previousContainer = document.getElementById('mobilePreviousChats');

      // Clear containers
      todayContainer.innerHTML = '';
      previousContainer.innerHTML = '';

      // Get all chats from the sidebar chat list
      const chatList = document.getElementById('chatList');
      const chatItems = chatList.querySelectorAll('li');

      if (chatItems.length === 0) {
        // Add empty state message
        todayContainer.innerHTML = '<div class="mobile-chat-item">No recent chats</div>';
        return;
      }

      // For demo, we'll add all chats to "Today" section
      // In a real app, you would separate by date
      chatItems.forEach((item, index) => {
        const chatId = item.getAttribute('data-chat-id');
        const chatName = item.querySelector('span').textContent;
        const isActive = item.classList.contains('active');

        const mobileItem = document.createElement('div');
        mobileItem.className = 'mobile-chat-item' + (isActive ? ' active' : '');
        mobileItem.setAttribute('data-chat-id', chatId);

        // Create chat info and delete button
        mobileItem.innerHTML = `
          <div class="chat-info">
            <i class="fas fa-message"></i>
            <span>${chatName}</span>
          </div>
          <button class="delete-chat" aria-label="Delete chat">
            <i class="fas fa-times"></i>
          </button>
        `;

        // Add click event handler for the chat item
        const chatInfo = mobileItem.querySelector('.chat-info');
        chatInfo.addEventListener('click', function () {
          // Remove active class from all mobile chat items
          document.querySelectorAll('.mobile-chat-item').forEach(item => {
            item.classList.remove('active');
          });

          // Add active class to clicked item
          mobileItem.classList.add('active');

          // Update main chat list
          const chatItem = document.querySelector(`#chatList li[data-chat-id="${chatId}"]`);
          if (chatItem) {
            document.querySelectorAll('#chatList li').forEach(item => {
              item.classList.remove('active');
            });
            chatItem.classList.add('active');
          }

          // Load the chat
          loadChat(chatId, chatName);

          // Close mobile menu
          closeMobileMenu();
        });

        // Add delete button functionality
        const deleteBtn = mobileItem.querySelector('.delete-chat');
        deleteBtn.addEventListener('click', function (event) {
          event.stopPropagation();

          // Delete from main chat list
          const chatItem = document.querySelector(`#chatList li[data-chat-id="${chatId}"]`);
          if (chatItem) {
            const deleteEvent = new MouseEvent('click', {
              bubbles: true,
              cancelable: true,
              view: window
            });

            const mainDeleteButton = chatItem.querySelector('.delete-chat');
            if (mainDeleteButton) {
              mainDeleteButton.dispatchEvent(deleteEvent);
            }
          }
        });

        // Add to appropriate container based on index (just for demo)
        if (index < 2) {
          todayContainer.appendChild(mobileItem);
        } else {
          previousContainer.appendChild(mobileItem);
        }
      });

      // If no previous chats, add empty state
      if (previousContainer.children.length === 0) {
        previousContainer.innerHTML = '<div class="mobile-chat-item" style="opacity:0.6">No previous chats</div>';
      }
    }

    // Add event listener to close sidebar
    document.addEventListener('DOMContentLoaded', function () {
      const sidebarHeader = document.querySelector('.sidebar .chat-header');

      if (sidebarHeader) {
        sidebarHeader.addEventListener('click', function (e) {
          // Check if clicked on the X icon (after pseudo-element)
          const rect = sidebarHeader.getBoundingClientRect();
          const isClickAfter = e.clientX > rect.x + rect.width - 30;

          if (isClickAfter && window.innerWidth <= 992) {
            const sidebar = document.querySelector('.sidebar');
            sidebar.style.display = 'none';
          }
        });
      }
    });

    // Mobile menu interaction improvements
    document.addEventListener('DOMContentLoaded', function () {
      const menuToggle = document.getElementById('mobileMenuToggle');
      const mobileMenu = document.getElementById('mobileMenu');
      const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');

      // Improved touch handling for mobile menu
      if (menuToggle && mobileMenu && mobileMenuOverlay) {
        // Add touch ripple effect
        menuToggle.addEventListener('touchstart', function () {
          this.classList.add('touch-active');
        });

        menuToggle.addEventListener('touchend', function () {
          this.classList.remove('touch-active');
          setTimeout(() => {
            mobileMenu.classList.add('active');
            mobileMenuOverlay.classList.add('active');
            updateMobileChats();
          }, 50);
        });

        // Add swipe to close functionality
        let startX = 0;
        mobileMenu.addEventListener('touchstart', function (e) {
          startX = e.touches[0].clientX;
        }, { passive: true });

        mobileMenu.addEventListener('touchmove', function (e) {
          if (startX > 20) { // Only if started from left edge area
            let diffX = e.touches[0].clientX - startX;
            if (diffX < 0) {
              mobileMenu.style.transform = `translateX(${diffX}px)`;
            }
          }
        }, { passive: true });

        mobileMenu.addEventListener('touchend', function (e) {
          let diffX = e.changedTouches[0].clientX - startX;
          if (diffX < -50) { // Swipe threshold
            closeMobileMenu();
          }
          mobileMenu.style.transform = '';
        }, { passive: true });

        // Add vibration feedback on menu interactions
        function vibrateIfAvailable(duration) {
          if ('vibrate' in navigator) {
            navigator.vibrate(duration);
          }
        }

        const allButtons = mobileMenu.querySelectorAll('.mobile-menu-btn, .mobile-chat-item');
        allButtons.forEach(btn => {
          btn.addEventListener('touchstart', () => vibrateIfAvailable(20), { passive: true });
        });
      }
    });

    // Updated previewFile function to auto-analyze uploaded documents
    function previewFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Process document content for analysis
      processDocumentContent(file);

      // For mobile devices, just show the file in the chat as a message
      if (window.innerWidth <= 992) {
        if (currentChatId) {
          // Add a file upload message with icon based on file type
          let fileIcon = 'fa-file';
          if (file.name.endsWith('.pdf')) fileIcon = 'fa-file-pdf';
          else if (file.name.endsWith('.txt')) fileIcon = 'fa-file-alt';
          else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) fileIcon = 'fa-file-word';
          else if (file.type.startsWith('image/')) fileIcon = 'fa-file-image';

          const fileMessage = `
            <div class="file-upload">
              <i class="fas ${fileIcon}"></i>
              <span>${file.name}</span>
            </div>
          `;

          // Create and append the HTML message
          appendHtmlMessage("user", fileMessage);

          // Add a notification message about the automatic analysis
          const analysisNotification = `
            <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
              <strong> Document uploaded:</strong> ${file.name}
              <div style="margin-top: 5px;">Automatically analyzing content to provide a summary...</div>
              <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
            </div>
          `;
          appendHtmlMessage("bot", analysisNotification);

          // Auto-analyze the document after a short delay
          setTimeout(() => {
            autoAnalyzeDocument(file.name);
          }, 1500);
        }
        return;
      }

      // Original desktop behavior below...
      const filePreview = document.getElementById("documentPreviews");

      // Clear welcome message if it exists
      const welcomeMessage = filePreview.querySelector('.empty-preview-message');
      if (welcomeMessage) {
        filePreview.removeChild(welcomeMessage);
      }

      // Make sure the document previews container is visible
      filePreview.style.display = 'block';

      // Update toggle button icon if needed
      const toggleBtn = document.getElementById('documentsToggle');
      if (toggleBtn && toggleBtn.querySelector('i').classList.contains('fa-chevron-down')) {
        toggleBtn.querySelector('i').classList.remove('fa-chevron-down');
        toggleBtn.querySelector('i').classList.add('fa-chevron-up');
      }

      // Create file item element
      const fileItem = document.createElement('div');
      fileItem.classList.add('file-item');
      fileItem.setAttribute('data-filename', file.name);

      // Create file header
      const fileHeader = document.createElement('div');
      fileHeader.className = 'file-header';

      // Create file name container
      const fileNameContainer = document.createElement('div');
      fileNameContainer.className = 'file-name';

      // Create file icon
      const fileIcon = document.createElement('i');
      fileIcon.classList.add('fas');

      // Set appropriate icon based on file type
      if (file.name.endsWith('.pdf')) {
        fileIcon.classList.add('fa-file-pdf');
        fileIcon.classList.add('pdf-icon');
      } else if (file.name.endsWith('.txt')) {
        fileIcon.classList.add('fa-file-alt');
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        fileIcon.classList.add('fa-file-word');
      } else {
        fileIcon.classList.add('fa-file');
      }

      // Create filename span
      const fileName = document.createElement('span');
      fileName.textContent = file.name;

      // Add icon and filename to the name container
      fileNameContainer.appendChild(fileIcon);
      fileNameContainer.appendChild(fileName);

      // Create delete button
      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = '<i class="fas fa-times"></i>';
      closeBtn.classList.add("delete-file");
      closeBtn.setAttribute('aria-label', 'Remove file');

      closeBtn.addEventListener("click", function (e) {
        e.stopPropagation();
        filePreview.removeChild(fileItem);

        // If no more files, show welcome message
        if (filePreview.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          filePreview.appendChild(welcomeText);
        }
      });

      // Add name container and delete button to header
      fileHeader.appendChild(fileNameContainer);
      fileHeader.appendChild(closeBtn);

      // Add header to file item
      fileItem.appendChild(fileHeader);

      // Add file preview for images and PDFs
      const fileType = file.type.split('/')[0];

      if (fileType === 'image' || file.name.endsWith('.pdf')) {
        const reader = new FileReader();
        reader.onload = function () {
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container';

          if (fileType === 'image') {
            const img = document.createElement('img');
            img.src = reader.result;
            img.alt = file.name;
            previewContainer.appendChild(img);
          } else if (file.name.endsWith('.pdf')) {
            previewContainer.classList.add('pdf-preview');
            const obj = document.createElement('object');
            obj.data = reader.result;
            obj.type = 'application/pdf';
            obj.width = '100%';
            obj.height = '200px';
            previewContainer.appendChild(obj);
          }

          fileItem.appendChild(previewContainer);
        };
        reader.readAsDataURL(file);
      }

      filePreview.appendChild(fileItem);

      // Force document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      previewSection.style.display = 'block';
      previewSection.style.visibility = 'visible';
      previewSection.style.opacity = '1';

      // If it's a chat context, add a message about the upload
      if (currentChatId) {
        // Add a file upload message with icon based on file type
        let fileIcon = 'fa-file';
        if (file.name.endsWith('.pdf')) fileIcon = 'fa-file-pdf';
        else if (file.name.endsWith('.txt')) fileIcon = 'fa-file-alt';
        else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) fileIcon = 'fa-file-word';
        else if (file.type.startsWith('image/')) fileIcon = 'fa-file-image';

        const fileMessage = `
          <div class="file-upload">
            <i class="fas ${fileIcon}"></i>
            <span>${file.name}</span>
          </div>
        `;

        appendHtmlMessage("user", fileMessage);

        // Auto-analyze the document after a short delay
        setTimeout(() => {
          autoAnalyzeDocument(file.name);
        }, 1500);
      }
    }

    // Function to automatically analyze a document after upload
    function autoAnalyzeDocument(filename) {
      if (!currentChatId) return;

      // Wait until the document is processed and available
      function checkAndAnalyze() {
        if (uploadedDocuments[filename]) {
          // Determine document type for customized analysis
          const fileType = getFileType(filename);

          // Customize analysis message based on file type
          let analysisMessage = `Please analyze the document ${filename} I just uploaded. Provide a summary and suggestions for improvement.`;

          // Add the message to chat history
          if (!chats[currentChatId].messages) {
            chats[currentChatId].messages = [];
          }

          chats[currentChatId].messages.push({
            sender: "user",
            content: analysisMessage
          });

          // Append a message saying the document is being analyzed
          appendMessage("bot", `I'm analyzing ${filename}. Here's what I found:`);

          // Create a thinking message
          const thinkingMsg = document.querySelector(".message.bot:last-child");

          // Get document context
          const documentContext = getDocumentContext(analysisMessage);

          // Prepare the prompt based on which model is active and file type
          let analysisPrompt;
          const today = new Date();
          const formattedDate = today.toLocaleDateString('en-US', {
            month: 'long',
            day: 'numeric',
            weekday: 'long'
          });

          // Customize prompt based on file type
          let fileTypePrompt = "";
          if (fileType === "pdf" || fileType === "docx" || fileType === "doc") {
            fileTypePrompt = "For this legal document: Evaluate its legal soundness, identify potential loopholes, suggest stronger legal language, and note any missing clauses that should be included.";
          } else if (fileType === "txt") {
            fileTypePrompt = "For this text document: Focus on organization, clarity, and structural improvements. Check for inconsistent terminology and logical flow.";
          } else if (fileType === "image") {
            fileTypePrompt = "For this OCR-extracted text: Note any potential errors in text recognition, evaluate the document structure, and suggest improvements to both content and formatting.";
          }

          if (modelConfig[activeModel].usingFallbackModel) {
            analysisPrompt =
              `DeepSeek Chat\n${formattedDate}\n\n` +
              "Document(s) uploaded by user:" +
              documentContext +
              "\n\nUser: Please analyze this document in detail and provide feedback.\n" +
              `${fileTypePrompt}\n` +
              "Always include these sections in your response:\n" +
              "1. 'Document Summary' with key points\n" +
              "2. 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness\n" +
              "3. 'Next Steps' with 2-3 recommendations on what the user should do next with this document\n" +
              "Assistant:";
          } else {
            analysisPrompt =
              "You are LegalMind, a legal assistant that specializes in document analysis.\n\n" +
              "User has uploaded the following document(s):" +
              documentContext +
              "\n\nUser: Please analyze this document in detail and provide feedback.\n" +
              `${fileTypePrompt}\n` +
              "Always include these sections in your response:\n" +
              "1. 'Document Summary' with key points\n" +
              "2. 'Document Improvement Suggestions' with 3-5 specific, actionable points on how to improve the document's clarity, precision, and effectiveness\n" +
              "3. 'Next Steps' with 2-3 recommendations on what the user should do next with this document\n" +
              "Assistant:";
          }

          // Prepare API request parameters
          let requestParams = {
            max_new_tokens: 1024,
            temperature: 0.7,
            top_p: 0.95,
            do_sample: true,
            return_full_text: false
          };

          // Use DeepSeek's recommended parameters if using the DeepSeek model
          if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek")) {
            requestParams = {
              max_new_tokens: 1024,
              temperature: 0.3,  // DeepSeek recommends 0.3
              top_p: 0.8,
              do_sample: true
            };
          }

          // Create a timeout promise that will reject after 15 seconds
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
              reject(new Error('API request timed out after 15 seconds'));
            }, 15000); // 15 seconds timeout
          });

          // Race between the fetch request and the timeout
          Promise.race([
            fetch(modelConfig[activeModel].endpoints[modelConfig[activeModel].currentEndpointIndex], {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${modelConfig[activeModel].authTokens[modelConfig[activeModel].currentTokenIndex]}`
              },
              body: JSON.stringify({
                inputs: analysisPrompt,
                parameters: requestParams
              })
            }),
            timeoutPromise
          ])
            .then(response => {
              if (!response.ok) {
                return response.text().then(text => {
                  throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
                });
              }
              return response.json();
            })
            .then(data => {
              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }

              // Add bot response from the API
              let botResponse = ""; // Empty default

              // Specific handling for Mistral model
              if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                botResponse = data[0].generated_text.trim();
              } else if (data && data.generated_text) {
                botResponse = data.generated_text.trim();
              } else if (typeof data === 'string') {
                botResponse = data.trim();
              } else if (data && data.choices && data.choices.length > 0) {
                // Handle OpenAI-like format
                botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
              } else {
                botResponse = "I apologize, but I received an unexpected response format. Please try asking directly about the document.";
              }

              // If we are using the DeepSeek model, check response for any non-English part and format
              if (currentEndpointInfo && currentEndpointInfo.endpoint.includes("deepseek") && botResponse) {
                // Remove any "Assistant:" prefix that might be in the response
                botResponse = botResponse.replace(/^Assistant:\s*/i, '');

                // If response starts with Chinese characters, try to find the first English part
                if (/^[\u4e00-\u9fa5]/.test(botResponse)) {
                  const englishPart = botResponse.match(/[a-zA-Z]/);
                  if (englishPart && englishPart.index > 0) {
                    botResponse = botResponse.substring(englishPart.index);
                  }
                }
              }

              // Safety check for empty responses
              if (!botResponse) {
                botResponse = "I apologize, but I couldn't analyze the document properly. Please ask me specific questions about it.";
              }

              appendMessage("bot", botResponse);
            })
            .catch(error => {
              console.error("Error analyzing document:", error);

              // Remove the thinking message if it exists
              if (thinkingMsg && thinkingMsg.parentNode) {
                thinkingMsg.parentNode.removeChild(thinkingMsg);
              }

              appendMessage("bot", "I had trouble analyzing this document. Please ask me specific questions about it, and I'll do my best to answer.");
            });
        } else {
          // If document isn't available yet, wait and check again
          setTimeout(checkAndAnalyze, 500);
        }
      }

      checkAndAnalyze();
    }

    // Helper function to determine file type for customized analysis
    function getFileType(filename) {
      if (filename.endsWith('.pdf')) return "pdf";
      if (filename.endsWith('.docx') || filename.endsWith('.doc')) return "doc";
      if (filename.endsWith('.txt')) return "txt";
      if (filename.match(/\.(jpg|jpeg|png|gif)$/i)) return "image";
      return "other";
    }

    // Simple scroll-to-bottom button handler
    document.addEventListener('DOMContentLoaded', function () {
      const chatBox = document.getElementById('chatBox');
      const scrollBottomBtn = document.getElementById('scrollBottomBtn');

      if (!chatBox || !scrollBottomBtn) return;

      // Simple scroll position check
      chatBox.addEventListener('scroll', function () {
        // Show button when not at bottom (with small threshold)
        const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;

        if (isAtBottom) {
          scrollBottomBtn.classList.remove('visible');
        } else {
          scrollBottomBtn.classList.add('visible');
        }
      });

      // Simple click handler for scroll button
      scrollBottomBtn.addEventListener('click', function () {
        chatBox.scrollTo({
          top: chatBox.scrollHeight,
          behavior: 'smooth'
        });
      });
    });

    // Function to test API connection
    function testAPIConnection() {
      const model = modelConfig.legalMind;
      const endpoint = model.endpoints[model.currentEndpointIndex];
      const token = model.authTokens[model.currentTokenIndex];

      console.log("Testing API connection to:", endpoint);
      console.log("Using token index:", model.currentTokenIndex);

      // Show testing notification
      showNotification(`Testing API connection to endpoint ${model.currentEndpointIndex}...`, "info");

      // Check if token appears valid
      if (!token || !token.startsWith('hf_') || token.length < 10) {
        console.error("API Token appears invalid:", token);
        showNotification("API token appears invalid. Check console for details.", "error");
        return;
      }

      // Create a timeout promise that will reject after 15 seconds
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('API request timed out after 15 seconds'));
        }, 15000); // 15 seconds timeout
      });

      // Race between the fetch request and the timeout
      Promise.race([
        // Make a simple test request
        fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({
            inputs: "Hello, can you give me a very brief response to test the connection?",
            parameters: {
              max_new_tokens: 50,
              temperature: 0.7,
              top_p: 0.95,
              do_sample: true,
              return_full_text: false
            }
          })
        }),
        timeoutPromise
      ])
        .then(response => {
          console.log("Test API Status:", response.status);
          console.log("Test API Headers:", [...response.headers.entries()]);

          if (!response.ok) {
            return response.text().then(text => {
              console.error("Test API Error Details:", text);
              showNotification(`API connection failed (${response.status}): ${response.statusText}`, "error");

              // Try next endpoint or token
              if (tryNextEndpointOrToken("legalMind")) {
                setTimeout(testAPIConnection, 1000);
              }

              return null;
            });
          }
          return response.json();
        })
        .then(data => {
          if (data) {
            console.log("Test API Success:", data);

            // Display the actual response in the notification
            let responseText = "";
            if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
              responseText = data[0].generated_text.substring(0, 50); // First 50 chars
            } else if (data && data.generated_text) {
              responseText = data.generated_text.substring(0, 50);
            } else {
              responseText = JSON.stringify(data).substring(0, 50);
            }

            showNotification(`API connection successful! Response: "${responseText}..."`, "success");

            // Also append result to chat if a chat is active
            if (currentChatId) {
              let successMessage = `API Test Result: Connection successful! Using endpoint ${model.currentEndpointIndex} and token ${model.currentTokenIndex}.`;

              // If we're using the DeepSeek model, indicate this in the message
              if (model.currentEndpointIndex === 0) {
                successMessage = "API Test Result: Connection successful using DeepSeek model. This model should provide reliable responses.";
              }

              appendMessage("bot", successMessage);
            }
          }
        })
        .catch(error => {
          console.error("Test API Error:", error);

          // Specific handling for timeout errors
          if (error.message.includes('timed out')) {
            console.log("Test API request timed out - trying next endpoint");
            showNotification("Test API connection timed out. Trying next model...", "warning");

            // Try next endpoint or token
            if (tryNextEndpointOrToken("legalMind")) {
              setTimeout(testAPIConnection, 1000);
            } else {
              showNotification("All models timed out during testing. Please try again later.", "error");
            }
            return;
          }

          showNotification("API connection error: " + error.message, "error");

          // Try next endpoint or token for other errors
          if (tryNextEndpointOrToken("legalMind")) {
            setTimeout(testAPIConnection, 1000);
          }
        });
    }

    // Add a button to test the connection - button removed per user request
    document.addEventListener('DOMContentLoaded', function () {
      // No buttons added to UI
    });

    // Add buttons to test the connection and wake up the endpoint - buttons removed per user request
    document.addEventListener('DOMContentLoaded', function () {
      // No buttons added to UI
    });

    // Function to process document content
    function processDocumentContent(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const content = e.target.result;
        
        // Store the document content
        if (!uploadedDocuments[file.name]) {
          uploadedDocuments[file.name] = {};
        }
        uploadedDocuments[file.name].content = content;
        
        // Detect if this is a legal document
        isLegalDocument = detectLegalDocument(content);
        
        if (isLegalDocument) {
          console.log(`Document detected as legal document: ${file.name}`);
          // Switch active model to LegalMind for legal documents
          activeModel = "legalMind";
        }
        
        console.log(`Processed document: ${file.name}, Content length: ${content.length} characters`);
      };
      
      if (file.type.startsWith('text/')) {
        reader.readAsText(file);
      } else if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
        // Handle PDF files using PDF.js
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const typedArray = new Uint8Array(this.result);
          
          pdfjsLib.getDocument(typedArray).promise.then(function(pdf) {
            let textContent = '';
            
            // Get all pages
            const pagePromises = [];
            for (let i = 1; i <= pdf.numPages; i++) {
              pagePromises.push(
                pdf.getPage(i).then(function(page) {
                  return page.getTextContent().then(function(content) {
                    return content.items.map(item => item.str).join(' ');
                  });
                })
              );
            }
            
            // Combine text from all pages
            Promise.all(pagePromises).then(function(pagesText) {
              textContent = pagesText.join('\n\n');
              
              // Store the extracted text
              if (!uploadedDocuments[file.name]) {
                uploadedDocuments[file.name] = {};
              }
              uploadedDocuments[file.name].content = textContent;
              
              // Detect if this is a legal document
              isLegalDocument = detectLegalDocument(textContent);
              
              if (isLegalDocument) {
                console.log(`PDF detected as legal document: ${file.name}`);
                // Switch active model to LegalMind for legal documents
                activeModel = "legalMind";
              }
              
              console.log(`Processed PDF: ${file.name}, Content length: ${textContent.length} characters`);
            });
          });
        };
        fileReader.readAsArrayBuffer(file);
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        // For Word documents, store as placeholder and we'll handle separately
        if (!uploadedDocuments[file.name]) {
          uploadedDocuments[file.name] = {};
        }
        uploadedDocuments[file.name].content = `Document: ${file.name} (Word document - contents not fully extracted)`;
        
        // Assume Word documents might be legal documents
        isLegalDocument = true;
        activeModel = "legalMind";
        
        console.log(`Processed Word document: ${file.name} (assumed as legal document)`);
      }
    }
    
    // Function to detect if content is likely a legal document
    function detectLegalDocument(content) {
      if (!content) return false;
      
      // Convert to lowercase for case-insensitive matching
      const lowerContent = content.toLowerCase();
      
      // List of legal terms to check for
      const legalTerms = [
        'agreement', 'contract', 'legally', 'clause', 'terms and conditions', 
        'hereinafter', 'party', 'parties', 'whereas', 'shall', 'provision',
        'pursuant to', 'covenant', 'liability', 'indemnity', 'jurisdiction',
        'law', 'legal', 'attorney', 'court', 'rights', 'obligations',
        'defendant', 'plaintiff', 'judgment', 'tort', 'statute', 'regulation'
      ];
      
      // Check for common legal document headers
      const legalHeaders = [
        'terms of service', 'privacy policy', 'end user license', 
        'non-disclosure', 'employment agreement', 'lease agreement',
        'confidentiality agreement', 'terms of use'
      ];
      
      // Count how many legal terms appear in the document
      let legalTermCount = 0;
      legalTerms.forEach(term => {
        if (lowerContent.includes(term)) {
          legalTermCount++;
        }
      });
      
      // Check for legal headers
      const hasLegalHeader = legalHeaders.some(header => lowerContent.includes(header));
      
      // If the document has a legal header or contains multiple legal terms, consider it a legal document
      return hasLegalHeader || legalTermCount >= 3;
    }

    // Function to get document summary for the prompt
    function getDocumentSummary() {
      let summary = "";

      // Add a list of available documents
      const documentList = Object.keys(uploadedDocuments);
      if (documentList.length > 0) {
        summary += "\n\nAvailable documents:\n";
        documentList.forEach(filename => {
          summary += `- ${filename}\n`;
        });
      }

      return summary;
    }

    // Function to get document context for the prompt
    function getDocumentContext(messageText) {
      // Look for document references in the message
      const documentList = Object.keys(uploadedDocuments);
      let context = "";

      if (documentList.length === 0) {
        return context; // No documents uploaded
      }

      // Always include document context by default
      // Check if we need to include all documents or specific ones
      const messageLower = messageText.toLowerCase();
      const mentionedDocuments = documentList.filter(filename =>
        messageLower.includes(filename.toLowerCase())
      );

      const documentsToInclude = mentionedDocuments.length > 0 ?
        mentionedDocuments : documentList;

      // Add relevant document content with clear delimiters
      documentsToInclude.forEach(filename => {
        let docContent = uploadedDocuments[filename];

        // Truncate very large documents (limit to ~10,000 chars)
        if (docContent.length > 10000) {
          docContent = docContent.substring(0, 10000) +
            "\n\n[Document content truncated due to length. This is only a portion of the full document.]";
        }

        context += `\n\n--- DOCUMENT: ${filename} ---\n`;
        context += docContent;
        context += "\n--- END OF DOCUMENT ---\n\n";
      });

      return context;
    }

    // Helper function to get current endpoint info
    function getCurrentEndpointInfo(modelKey) {
      if (!modelConfig[modelKey]) return null;

      const config = modelConfig[modelKey];
      return {
        endpoint: config.endpoints[config.currentEndpointIndex],
        endpointIndex: config.currentEndpointIndex,
        token: config.authTokens[config.currentTokenIndex],
        tokenIndex: config.currentTokenIndex
      };
    }

    // Function to try the next endpoint or token
    function tryNextEndpointOrToken(modelKey) {
      if (!modelConfig[modelKey]) return false;

      const config = modelConfig[modelKey];
      const currentEndpoint = config.endpoints[config.currentEndpointIndex];
      const currentToken = config.authTokens[config.currentTokenIndex];

      // Try next endpoint first
      config.currentEndpointIndex = (config.currentEndpointIndex + 1) % config.endpoints.length;
      const newEndpoint = config.endpoints[config.currentEndpointIndex];

      console.log(`Switching from endpoint ${currentEndpoint} to ${newEndpoint}`);

      // Generic notification that doesn't reveal model details
      showNotification("Getting response, please wait...", "info");

      // If we've cycled through all endpoints, try the next token
      if (config.currentEndpointIndex === 0) {
        const prevToken = config.authTokens[config.currentTokenIndex];
        config.currentTokenIndex = (config.currentTokenIndex + 1) % config.authTokens.length;
        console.log(`Switching from token ${prevToken} to ${config.authTokens[config.currentTokenIndex]}`);

        showNotification("Trying alternative API connection...", "info");

        // If we've cycled through all tokens, return false to indicate we've tried everything
        if (config.currentTokenIndex === 0) {
          showNotification("All available connections attempted without success. Please try again later.", "error");
          return false;
        }
      }

      return true;
    }

    // Function to wake up a scaled-to-zero endpoint
    function wakeUpEndpoint() {
      const model = modelConfig.legalMind;
      // Force using the original AWS endpoint which is scaled to zero (now at index 3)
      model.currentEndpointIndex = 3; // Updated index for the AWS endpoint
      model.currentTokenIndex = 0;

      const endpoint = model.endpoints[3]; // Use the correct index for the AWS endpoint
      const token = model.authTokens[0];

      console.log("Attempting to wake up endpoint:", endpoint);
      showNotification("Attempting to wake up endpoint...", "info");

      // Create a timeout promise that will reject after 15 seconds
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Wake up request timed out after 15 seconds'));
        }, 15000); // 15 seconds timeout
      });

      // Race between the fetch request and the timeout
      Promise.race([
        // Make a simple test request to wake it up
        fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`
          },
          body: JSON.stringify({
            inputs: "Wake up",
            parameters: {
              max_new_tokens: 10,
              temperature: 0.7,
              do_sample: true
            }
          })
        }),
        timeoutPromise
      ])
        .then(response => {
          console.log("Wake up status:", response.status);

          if (!response.ok) {
            return response.text().then(text => {
              console.error("Wake up details:", text);

              if (text.includes("scaled to zero") || response.status === 503) {
                showNotification("Endpoint is scaled to zero. It may take a few minutes to wake up.", "warning");
                if (currentChatId) {
                  appendMessage("bot", "The endpoint is currently inactive (scaled to zero). I've sent a wake-up request. It may take 1-2 minutes to start. Please try again shortly.");
                }
              } else {
                showNotification(`Wake up request failed: ${response.status}`, "error");
              }
              return null;
            });
          }

          showNotification("Endpoint is waking up! Try your request again in a moment.", "success");
          if (currentChatId) {
            appendMessage("bot", "The endpoint is waking up! Please try your request again in about 30 seconds.");
          }
          return response.json();
        })
        .catch(error => {
          console.error("Wake up error:", error);

          // Specific handling for timeout errors
          if (error.message.includes('timed out')) {
            showNotification("Wake up request timed out. The endpoint may be unavailable.", "warning");
            if (currentChatId) {
              appendMessage("bot", "The wake up request timed out. The endpoint appears to be unavailable. I'll automatically try alternative models for your requests.");
            }
            return;
          }

          showNotification("Error sending wake up request: " + error.message, "error");
        });
    }

    // Function to check if message is a greeting
    function isGreeting(text) {
      const greetings = [
        "hello", "hi", "hey", "greetings", "good morning", "good afternoon",
        "good evening", "howdy", "how are you", "nice to meet you"
      ];

      const lowerText = text.toLowerCase();
      return greetings.some(greeting => lowerText.includes(greeting)) && text.length < 30;
    }

    // Function to detect math questions
    function isMathQuestion(text) {
      // Keywords and patterns that indicate math questions
      const mathKeywords = [
        "solve", "calculate", "compute", "equation", "math", "formula",
        "derivative", "integral", "theorem", "algebra", "calculus",
        "trigonometry", "pythagorean", "probability", "statistics",
        "mean", "median", "mode", "standard deviation", "variance"
      ];

      // Math symbols regex
      const mathSymbols = /[\+\-\*\/\^\=\<\>\(\)\[\]\{\}\.\,0-9]/g;

      // Check for question containing numbers and math operators
      const hasNumbers = /\d+/.test(text);
      const hasOperators = /[\+\-\*\/\=]/.test(text);

      // Check for presence of math keywords
      const lowerText = text.toLowerCase();
      const hasMathKeywords = mathKeywords.some(keyword => lowerText.includes(keyword));

      // Calculate the ratio of math symbols to text length
      const mathSymbolCount = (text.match(mathSymbols) || []).length;
      const mathSymbolRatio = mathSymbolCount / text.length;

      // Conditions for determining a math question
      const isMathHeavy = mathSymbolRatio > 0.15; // If more than 15% of chars are math symbols
      const isSimpleMathQuestion = hasNumbers && hasOperators;

      return hasMathKeywords || isMathHeavy || isSimpleMathQuestion;
    }

    // Function to get a greeting response
    function getGreetingResponse() {
      return "Hello! I'm LegalMind, your AI legal assistant. I specialize in analyzing legal documents and providing insights. To get the most out of our conversation, please upload your document using the paperclip icon or images with text using the camera icon. I can read and analyze the content, provide a summary, and suggest improvements.";
    }

    // Function to process image and extract text using OCR
    function processImage(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Check if it's actually an image
      if (!file.type.startsWith('image/')) {
        showNotification("Please select a valid image file (PNG, JPG, JPEG)", "error");
        return;
      }

      showNotification("Processing image: " + file.name, "info");

      // For mobile devices, show the image in the chat
      if (window.innerWidth <= 992) {
        if (currentChatId) {
          // Add a file upload message with camera icon
          const fileMessage = `
            <div class="file-upload">
              <i class="fas fa-camera"></i>
              <span>${file.name}</span>
            </div>
          `;

          // Create and append the HTML message
          appendHtmlMessage("user", fileMessage);

          // Add a notification message about the automatic OCR processing
          const ocrNotification = `
            <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
              <strong> Image uploaded:</strong> ${file.name}
              <div style="margin-top: 5px;">Extracting text with OCR and analyzing content...</div>
              <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
            </div>
          `;
          appendHtmlMessage("bot", ocrNotification);
        }
      }

      // Desktop and mobile: Process the image with OCR
      const reader = new FileReader();
      reader.onload = function (e) {
        const imageUrl = e.target.result;

        // Add a loading message
        let ocrLoadingMsg;
        if (currentChatId) {
          appendMessage("bot", "Reading text from image...");
          ocrLoadingMsg = document.querySelector(".message.bot:last-child");
        }

        // Process with Tesseract.js
        Tesseract.recognize(
          imageUrl,
          'eng', // English language
          {
            logger: info => {
              console.log(info);
              if (info.status === 'recognizing text' && info.progress < 1) {
                // Update the loading message with progress
                if (ocrLoadingMsg) {
                  ocrLoadingMsg.textContent = `Reading text from image... ${Math.round(info.progress * 100)}%`;
                }
              }
            }
          }
        ).then(({ data: { text } }) => {
          console.log("Extracted text from image:", text);

          // Remove the loading message
          if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
            ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
          }

          if (!text || text.trim() === '') {
            showNotification("No text could be detected in the image", "warning");
            appendMessage("bot", "I couldn't detect any text in this image. Please try with a clearer image or upload a text document instead.");
            return;
          }

          // Store the extracted text in uploadedDocuments
          uploadedDocuments[file.name] = text;
          showNotification("Image text extracted successfully", "success");

          // Add the extracted text to the document preview panel
          const filePreview = document.getElementById("documentPreviews");

          // Clear welcome message if it exists
          const welcomeMessage = filePreview.querySelector('.empty-preview-message');
          if (welcomeMessage) {
            filePreview.removeChild(welcomeMessage);
          }

          // Create file item element for the document preview
          const fileItem = document.createElement('div');
          fileItem.classList.add('file-item');
          fileItem.setAttribute('data-filename', file.name);

          // Create file header
          const fileHeader = document.createElement('div');
          fileHeader.className = 'file-header';

          // Create file name container
          const fileNameContainer = document.createElement('div');
          fileNameContainer.className = 'file-name';

          // Create file icon (camera for images)
          const fileIcon = document.createElement('i');
          fileIcon.classList.add('fas', 'fa-camera');

          // Create filename span
          const fileName = document.createElement('span');
          fileName.textContent = `${file.name} (OCR text)`;

          // Add icon and filename to the name container
          fileNameContainer.appendChild(fileIcon);
          fileNameContainer.appendChild(fileName);

          // Create delete button
          const closeBtn = document.createElement("button");
          closeBtn.innerHTML = '<i class="fas fa-times"></i>';
          closeBtn.classList.add("delete-file");
          closeBtn.setAttribute('aria-label', 'Remove file');

          closeBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            filePreview.removeChild(fileItem);

            // If no more files, show welcome message
            if (filePreview.children.length === 0) {
              const welcomeText = document.createElement('p');
              welcomeText.className = 'empty-preview-message';
              welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
              filePreview.appendChild(welcomeText);
            }
          });

          // Add name container and delete button to header
          fileHeader.appendChild(fileNameContainer);
          fileHeader.appendChild(closeBtn);

          // Add header to file item
          fileItem.appendChild(fileHeader);

          // Create a text preview for the OCR content
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container ocr-preview';

          // Add a textarea with the OCR text - using CSS classes instead of inline styles
          const textPreview = document.createElement('textarea');
          textPreview.readOnly = true;
          textPreview.value = text;

          previewContainer.appendChild(textPreview);
          fileItem.appendChild(previewContainer);

          filePreview.appendChild(fileItem);

          // Force document preview section visible
          const previewSection = document.querySelector('.documents-preview');
          previewSection.style.display = 'block';
          previewSection.style.visibility = 'visible';
          previewSection.style.opacity = '1';

          // Now auto-analyze the extracted text with a prominent notification
          if (currentChatId) {
            // Replace the loading message with a notification about analysis
            if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
              ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
            }

            // Add an OCR completion notification
            const analysisNotification = `
              <div style="padding: 10px; background-color: var(--light-bg); border-left: 4px solid var(--accent-color); border-radius: 4px; margin-top: 10px; margin-bottom: 10px;">
                <strong> OCR completed:</strong> Successfully extracted text from ${file.name}
                <div style="margin-top: 5px;">Now analyzing the content to provide a summary...</div>
                <div class="typing-indicator" style="margin-top: 8px;"><span></span><span></span><span></span></div>
              </div>
            `;
            appendHtmlMessage("bot", analysisNotification);
          }

          setTimeout(() => {
            autoAnalyzeDocument(file.name);
          }, 1000);
        }).catch(error => {
          console.error("OCR Error:", error);
          showNotification("Error processing image text", "error");

          // Remove the loading message
          if (ocrLoadingMsg && ocrLoadingMsg.parentNode) {
            ocrLoadingMsg.parentNode.removeChild(ocrLoadingMsg);
          }

          if (currentChatId) {
            appendMessage("bot", "I encountered an error processing the text in this image. Please try again with a clearer image or upload a text document instead.");
          }
        });
      };

      reader.onerror = function () {
        console.error("Error reading image file");
        showNotification("Error processing image", "error");
      };

      reader.readAsDataURL(file);
    }

    // Function to connect to all endpoints when the website opens
    function connectToAllEndpoints() {
      if (connectingEndpoints) return; // Prevent multiple simultaneous connections
      connectingEndpoints = true;

      console.log("Connecting to all model endpoints in the background...");

      // Function to test connection to a specific model and measure response time
      function testModelConnection(modelKey) {
        const model = modelConfig[modelKey];
        if (!model) return Promise.resolve();

        // Try each endpoint for this model
        let testPromises = [];

        model.endpoints.forEach((endpoint, endpointIndex) => {
          const token = model.authTokens[model.currentTokenIndex]; // Use model's specific token

          // Create a promise for this endpoint
          const testPromise = new Promise((resolve) => {
            console.log(`Testing connection to ${modelKey} endpoint ${endpointIndex}: ${endpoint}`);

            const startTime = Date.now();

            // Make a simple test request with 15-second timeout
            Promise.race([
              fetch(endpoint, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${token}`
                },
                body: JSON.stringify({
                  inputs: "Hello, can you respond briefly to test connection?",
                  parameters: {
                    max_new_tokens: 10,
                    temperature: 0.7,
                    do_sample: true,
                    return_full_text: false
                  }
                })
              }),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
            ])
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
              })
              .then(data => {
                // Calculate response time
                const responseTime = Date.now() - startTime;
                console.log(` ${modelKey} endpoint ${endpointIndex} responded in ${responseTime}ms`);

                // Store the response time
                model.responseTime = responseTime;

                // If this is faster than current endpoint and under 15 seconds, use it
                if (responseTime < 15000) {
                  resolve({
                    modelKey,
                    endpointIndex,
                    responseTime,
                    success: true
                  });
                } else {
                  resolve({
                    modelKey,
                    endpointIndex,
                    responseTime,
                    success: false
                  });
                }
              })
              .catch(error => {
                console.log(` ${modelKey} endpoint ${endpointIndex} failed: ${error.message}`);
                resolve({
                  modelKey,
                  endpointIndex,
                  responseTime: 20000, // High value for failed connections
                  success: false
                });
              });
          });

          testPromises.push(testPromise);
        });

        return Promise.all(testPromises);
      }

      // Test all models in parallel
      Promise.all([
        testModelConnection("legalMind"),
        testModelConnection("mathModel"),
        testModelConnection("mistralModel"),
        testModelConnection("deepseekModel")
      ])
        .then(results => {
          // Flatten results
          const allResults = results.flat();

          // Find fastest responding endpoint for each model type
          const successfulResults = allResults.filter(r => r && r.success);
          
          if (successfulResults.length > 0) {
            // Set timeouts based on measured response times
            for (const key in modelConfig) {
              if (modelConfig[key].responseTime && modelConfig[key].responseTime < 15000) {
                // Set timeout to response time + 3 seconds buffer (or minimum 15 sec)
                // For LegalMind with legal documents, use the specific longer timeout
                if (key === "legalMind") {
                  modelConfig[key].timeout = modelConfig[key].legalDocTimeout || 20000;
                  console.log(`Setting ${key} timeout to ${modelConfig[key].timeout}ms for legal documents`);
                } else {
                  const timeout = Math.max(modelConfig[key].responseTime + 3000, 15000);
                  modelConfig[key].timeout = timeout;
                  console.log(`Setting ${key} timeout to ${timeout}ms`);
                }
              } else {
                // Default timeout
                modelConfig[key].timeout = key === "legalMind" ? 20000 : 15000;
              }
            }
            
            // Find the fastest model for general use (not math or legal specific)
            const generalModels = successfulResults.filter(r => 
              r.modelKey !== "mathModel" && r.modelKey !== "legalMind");
            
            if (generalModels.length > 0) {
              // Sort by response time
              generalModels.sort((a, b) => a.responseTime - b.responseTime);
              const fastestGeneralModel = generalModels[0];
              
              // Set the default active model to the fastest general model
              activeModel = fastestGeneralModel.modelKey;
              console.log(`Setting fastest general model as default: ${activeModel} (${modelConfig[activeModel].responseTime}ms)`);
            }
          }

          connectingEndpoints = false;
          
          // Display model response times in the console
          displayModelResponseTimes();
        })
        .catch(error => {
          console.error("Error testing endpoints:", error);
          connectingEndpoints = false;
        });
    }

    // Function to handle file upload
    function handleFileUpload(event) {
      const files = event.target.files;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        processUploadedFile(file);
      }
      // Reset the file input
      event.target.value = null;
    }

    // Document action buttons: applies to the document analysis response
    function addDocumentActionButtons(responseElement, documentName) {
      if (!responseElement || !documentName) return;

      // Check if document exists in uploadedDocuments
      if (!uploadedDocuments[documentName]) {
        console.warn("Cannot add action buttons: Document not found in uploadedDocuments:", documentName);
        return;
      }

      // Create a container for the buttons
      const actionContainer = document.createElement('div');
      actionContainer.className = 'document-action-buttons';

      // Create Apply Suggestions button
      const applySuggestionsBtn = document.createElement('button');
      applySuggestionsBtn.className = 'btn document-action-btn';
      applySuggestionsBtn.innerHTML = '<i class="fas fa-magic"></i> Apply Suggestions';
      applySuggestionsBtn.title = 'Automatically apply the suggested improvements';

      // Create Download Updated button
      const downloadBtn = document.createElement('button');
      downloadBtn.className = 'btn document-action-btn';
      downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download Updated';
      downloadBtn.title = 'Download the document with applied suggestions';
      downloadBtn.disabled = true; // Initially disabled until suggestions are applied

      // Event handler for Apply Suggestions button
      applySuggestionsBtn.addEventListener('click', () => {
        // Extract suggestions from the bot response
        const botResponse = responseElement.textContent;
        const documentContent = uploadedDocuments[documentName].content;

        // Show processing message
        showNotification('Processing document suggestions...', 'info');

        // Implement the suggestions in the document content
        applyDocumentSuggestions(documentName, documentContent, botResponse).then(updatedContent => {
          if (updatedContent) {
            // Store the updated content in uploadedDocuments
            uploadedDocuments[documentName].updatedContent = updatedContent;

            // Preview the updated content
            showUpdatedDocumentPreview(documentName, updatedContent);

            // Enable download button
            downloadBtn.disabled = false;

            showNotification('Suggestions applied successfully!', 'success');
          } else {
            showNotification('Failed to apply suggestions.', 'error');
          }
        });
      });

      // Event handler for Download Updated button
      downloadBtn.addEventListener('click', () => {
        if (uploadedDocuments[documentName].updatedContent) {
          downloadUpdatedDocument(documentName, uploadedDocuments[documentName].updatedContent);
        } else {
          showNotification('No updated content available.', 'error');
        }
      });

      // Add buttons to container
      actionContainer.appendChild(applySuggestionsBtn);
      actionContainer.appendChild(downloadBtn);

      // Append container to the response element
      responseElement.appendChild(document.createElement('br'));
      responseElement.appendChild(actionContainer);
    }

    // Function to apply document suggestions
    async function applyDocumentSuggestions(documentName, originalContent, botResponse) {
      // Create a thinking message to show progress
      appendHtmlMessage("bot", `<span data-thinking="true">Applying suggestions to ${documentName}...</span>`);
      const thinkingMsg = document.querySelector(".message.bot:last-child");

      try {
        // Get document type (text, PDF, etc.)
        const fileType = getFileType(documentName);

        // Extract the "Document Improvement Suggestions" section
        const suggestionsMatch = botResponse.match(/Document Improvement Suggestions[:\s]*([\s\S]*?)(?:\n\n|\n##|\n#|$)/i);

        if (!suggestionsMatch) {
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }
          appendMessage("bot", "I couldn't find any improvement suggestions in the analysis. Please try again or ask for specific improvements.");
          return null;
        }

        const improvementSuggestions = suggestionsMatch[1].trim();

        // For text-based documents, we can directly modify the content
        if (fileType === "txt" || fileType === "other") {
          // For simple text docs, apply changes directly
          let updatedContent = originalContent;

          // Extract each numbered suggestion
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            // Try to identify what to change based on the suggestion
            // This is a simple implementation - in reality you would use more sophisticated NLP
            const changeMatch = suggestion.match(/(replace|change|update|add|remove|delete|improve)\s+["']([^"']+)["']\s+(to|with)\s+["']([^"']+)["']/i);

            if (changeMatch) {
              const [fullMatch, action, oldText, connector, newText] = changeMatch;

              if (action.toLowerCase().includes('replace') ||
                action.toLowerCase().includes('change') ||
                action.toLowerCase().includes('update')) {
                updatedContent = updatedContent.replace(new RegExp(escapeRegExp(oldText), 'g'), newText);
              } else if (action.toLowerCase().includes('add')) {
                // For add, we try to find a logical place to add the content
                // This is simplified - real implementation would be more context-aware
                updatedContent += `\n${newText}`;
              } else if (action.toLowerCase().includes('remove') ||
                action.toLowerCase().includes('delete')) {
                updatedContent = updatedContent.replace(new RegExp(escapeRegExp(oldText), 'g'), '');
              }
            }
          }

          // Remove the thinking message
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          const diffSummary = generateDiffSummary(originalContent, updatedContent);
          appendMessage("bot", `I've applied the suggestions to ${documentName}.\n\n**Changes made:**\n${diffSummary}\n\nYou can now download the updated document using the "Download Updated" button.`);

          return updatedContent;
        } else if (fileType === "pdf" || fileType === "doc" || fileType === "docx") {
          // For PDF/DOC, we return the original text with a note about limitations
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          appendMessage("bot", `I've identified the suggestions for ${documentName}, but direct editing of ${fileType.toUpperCase()} files is limited. I'll generate a text version with the suggested improvements that you can download and reference while updating your original document.`);

          // Prepare a text version with the suggestions implemented
          const textContent = originalContent;
          let updatedContent = `# Improved version of ${documentName}\n\n`;
          updatedContent += `## Original Content:\n${textContent}\n\n`;
          updatedContent += `## Improvement Suggestions:\n${improvementSuggestions}\n\n`;
          updatedContent += `## Suggested Revised Version:\n`;

          // Try to implement each suggestion to create a revised version
          let revisedContent = textContent;
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            updatedContent += `\n- ${suggestion.trim()}`;
          }

          return updatedContent;
        } else if (fileType === "image") {
          // For images with OCR text, return the extracted text with suggestions
          if (thinkingMsg && thinkingMsg.parentNode) {
            thinkingMsg.parentNode.removeChild(thinkingMsg);
          }

          appendMessage("bot", `I've identified suggestions for the text in this image, but I can only provide a text version with improvements, not modify the original image.`);

          // Create an improved text version
          let updatedContent = `# Improved text from image ${documentName}\n\n`;
          updatedContent += `## Original OCR Content:\n${originalContent}\n\n`;
          updatedContent += `## Improvement Suggestions:\n${improvementSuggestions}\n\n`;
          updatedContent += `## Suggested Revised Version:\n`;

          // Try to implement the suggestions
          let revisedContent = originalContent;
          const suggestionItems = improvementSuggestions.split(/\d+\.\s+/).filter(item => item.trim().length > 0);

          for (const suggestion of suggestionItems) {
            updatedContent += `\n- ${suggestion.trim()}`;
          }

          return updatedContent;
        }

        return null;
      } catch (error) {
        console.error("Error applying document suggestions:", error);
        if (thinkingMsg && thinkingMsg.parentNode) {
          thinkingMsg.parentNode.removeChild(thinkingMsg);
        }
        appendMessage("bot", "I encountered an error while applying the suggestions. Please try again or ask for specific improvements.");
        return null;
      }
    }

    // Function to show preview of updated document
    function showUpdatedDocumentPreview(documentName, updatedContent) {
      // Find or create a document preview container
      const documentPreviews = document.getElementById('documentPreviews');
      if (!documentPreviews) return;

      // Create a preview panel
      const previewPanel = document.createElement('div');
      previewPanel.className = 'document-preview-panel';
      previewPanel.innerHTML = `
        <div class="preview-header">
          <div class="preview-title"><i class="fas fa-file-alt"></i> Updated: ${documentName}</div>
          <button class="preview-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="preview-content">
          <textarea readonly>${updatedContent}</textarea>
        </div>
      `;

      // Add close button functionality
      const closeBtn = previewPanel.querySelector('.preview-close-btn');
      closeBtn.addEventListener('click', () => {
        documentPreviews.removeChild(previewPanel);
      });

      // Add to preview area
      documentPreviews.appendChild(previewPanel);

      // Make document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      if (previewSection) {
        previewSection.style.display = 'block';
      }
    }

    // Function to download the updated document
    function downloadUpdatedDocument(documentName, updatedContent) {
      // Create a blob with the updated content
      const blob = new Blob([updatedContent], { type: 'text/plain' });

      // Create a download link
      const downloadLink = document.createElement('a');
      downloadLink.href = URL.createObjectURL(blob);

      // Add "updated" to the filename
      const fileNameParts = documentName.split('.');
      const extension = fileNameParts.pop();
      const baseName = fileNameParts.join('.');
      downloadLink.download = `${baseName}_updated.txt`;

      // Trigger download
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);

      // Clean up
      URL.revokeObjectURL(downloadLink.href);

      showNotification('Document downloaded successfully!', 'success');
    }

    // Helper function to escape special characters for RegExp
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Helper function to generate a summary of changes
    function generateDiffSummary(originalText, updatedText) {
      // Simple diff summary - count additions and removals
      const originalWords = originalText.split(/\s+/).filter(w => w.length > 0);
      const updatedWords = updatedText.split(/\s+/).filter(w => w.length > 0);

      const originalChars = originalText.length;
      const updatedChars = updatedText.length;

      return `- Word count: ${originalWords.length}  ${updatedWords.length} (${updatedWords.length - originalWords.length > 0 ? '+' : ''}${updatedWords.length - originalWords.length})
- Character count: ${originalChars}  ${updatedChars} (${updatedChars - originalChars > 0 ? '+' : ''}${updatedChars - originalChars})`;
    }

    // Function to process uploaded file
    function processUploadedFile(file) {
      // Process document content for analysis
      processDocumentContent(file);

      // Create file preview in the document preview area
      const filePreview = document.getElementById("documentPreviews");
      if (!filePreview) return;

      // Clear welcome message if it exists
      const welcomeMessage = filePreview.querySelector('.empty-preview-message');
      if (welcomeMessage) {
        filePreview.removeChild(welcomeMessage);
      }

      // Make sure the document previews container is visible
      filePreview.style.display = 'block';

      // Create file item element
      const fileItem = document.createElement('div');
      fileItem.classList.add('file-item');
      fileItem.setAttribute('data-filename', file.name);

      // Create file header
      const fileHeader = document.createElement('div');
      fileHeader.className = 'file-header';

      // Create file name container
      const fileNameContainer = document.createElement('div');
      fileNameContainer.className = 'file-name';

      // Create file icon
      const fileIcon = document.createElement('i');
      fileIcon.className = 'fas';

      // Set icon based on file type
      if (file.name.endsWith('.pdf')) {
        fileIcon.classList.add('fa-file-pdf');
      } else if (file.name.endsWith('.txt')) {
        fileIcon.classList.add('fa-file-alt');
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        fileIcon.classList.add('fa-file-word');
      } else if (file.type.startsWith('image/')) {
        fileIcon.classList.add('fa-file-image');
      } else {
        fileIcon.classList.add('fa-file');
      }

      // Create filename span
      const fileName = document.createElement('span');
      fileName.textContent = file.name;

      // Add icon and filename to the name container
      fileNameContainer.appendChild(fileIcon);
      fileNameContainer.appendChild(fileName);

      // Create delete button
      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = '<i class="fas fa-times"></i>';
      closeBtn.classList.add("delete-file");
      closeBtn.setAttribute('aria-label', 'Remove file');

      closeBtn.addEventListener("click", function (e) {
        e.stopPropagation();
        filePreview.removeChild(fileItem);

        // If no more files, show welcome message
        if (filePreview.children.length === 0) {
          const welcomeText = document.createElement('p');
          welcomeText.className = 'empty-preview-message';
          welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
          filePreview.appendChild(welcomeText);
        }

        // Remove from uploadedDocuments
        if (uploadedDocuments[file.name]) {
          delete uploadedDocuments[file.name];
        }
      });

      // Add name container and delete button to header
      fileHeader.appendChild(fileNameContainer);
      fileHeader.appendChild(closeBtn);

      // Add header to file item
      fileItem.appendChild(fileHeader);

      // Add file preview for images and PDFs
      const fileType = file.type.split('/')[0];

      if (fileType === 'image' || file.name.endsWith('.pdf')) {
        const reader = new FileReader();
        reader.onload = function () {
          const previewContainer = document.createElement('div');
          previewContainer.className = 'file-preview-container';

          if (fileType === 'image') {
            const img = document.createElement('img');
            img.src = reader.result;
            img.alt = file.name;
            previewContainer.appendChild(img);
          } else if (file.name.endsWith('.pdf')) {
            previewContainer.classList.add('pdf-preview');
            const obj = document.createElement('object');
            obj.data = reader.result;
            obj.type = 'application/pdf';
            obj.width = '100%';
            obj.height = '200px';
            previewContainer.appendChild(obj);
          }

          fileItem.appendChild(previewContainer);
        };
        reader.readAsDataURL(file);
      }

      filePreview.appendChild(fileItem);

      // Force document preview section visible
      const previewSection = document.querySelector('.documents-preview');
      if (previewSection) {
        previewSection.style.display = 'block';
        previewSection.style.visibility = 'visible';
        previewSection.style.opacity = '1';
      }

      // If it's a chat context, add a message about the upload
      if (currentChatId) {
        // Add a file upload message with icon based on file type
        let fileIcon = 'fa-file';
        if (file.name.endsWith('.pdf')) fileIcon = 'fa-file-pdf';
        else if (file.name.endsWith('.txt')) fileIcon = 'fa-file-alt';
        else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) fileIcon = 'fa-file-word';
        else if (file.type.startsWith('image/')) fileIcon = 'fa-file-image';

        const fileMessage = `
          <div class="file-upload">
            <i class="fas ${fileIcon}"></i>
            <span>${file.name}</span>
          </div>
        `;

        appendHtmlMessage("user", fileMessage);

        // Auto-analyze the document after a short delay
        setTimeout(() => {
          autoAnalyzeDocument(file.name);
        }, 1500);
      }
    }

    // Function to display all model response times
    function displayModelResponseTimes() {
      console.log("=== MODEL RESPONSE TIMES ===");
      
      for (const modelKey in modelConfig) {
        console.log(`\n${modelKey.toUpperCase()}:`);
        console.log(`- Model Name: ${modelConfig[modelKey].name}`);
        console.log(`- Overall Response Time: ${modelConfig[modelKey].responseTime || 'Not measured'} ms`);
        
        // Set timeout to 20 seconds for LegalMind
        if (modelKey === 'legalMind') {
          modelConfig[modelKey].timeout = 20000; // 20 seconds for LegalMind
          console.log(`- Timeout Setting: 20000 ms (fixed 20 second timeout for legal processing)`);
        } else {
          // For other models, calculate based on response time
          if (modelConfig[modelKey].responseTime) {
            modelConfig[modelKey].timeout = Math.max(modelConfig[modelKey].responseTime + 3000, 15000);
          }
          console.log(`- Timeout Setting: ${modelConfig[modelKey].timeout || 15000} ms`);
        }
        
        console.log('\nEndpoints:');
        modelConfig[modelKey].endpoints.forEach((endpoint, index) => {
          // Extract endpoint name from URL
          const endpointName = endpoint.includes('/') ? 
            endpoint.split('/').slice(-2).join('/') : 
            endpoint;
          
          // Add an indicator for the currently active endpoint
          const isActive = index === modelConfig[modelKey].currentEndpointIndex ? ' [ACTIVE]' : '';
          
          console.log(`${index+1}. ${endpointName}${isActive}`);
        });
        
        console.log('\nAuth Tokens:');
        modelConfig[modelKey].authTokens.forEach((token, index) => {
          // Mask token for security, showing only first few and last few characters
          const maskedToken = token.substring(0, 5) + '...' + token.substring(token.length - 4);
          
          // Add an indicator for the currently active token
          const isActive = index === modelConfig[modelKey].currentTokenIndex ? ' [ACTIVE]' : '';
          
          console.log(`${index+1}. ${maskedToken}${isActive}`);
        });
      }
      
      console.log("\n=== MODEL TEST RECOMMENDATIONS ===");
      // Recommend the faster model
      let fastestModel = null;
      let fastestTime = Infinity;
      
      for (const modelKey in modelConfig) {
        if (modelConfig[modelKey].responseTime && modelConfig[modelKey].responseTime < fastestTime) {
          fastestModel = modelKey;
          fastestTime = modelConfig[modelKey].responseTime;
        }
      }
      
      if (fastestModel) {
        console.log(`\nFastest model: ${fastestModel.toUpperCase()} (${fastestTime} ms)`);
        
        // For display purposes only - the actual timeouts are set above
        const recommendedTimeout = fastestModel === 'legalMind' ? 
          20000 : Math.max(fastestTime + 3000, 15000);
        console.log(`Recommended timeout: ${recommendedTimeout} ms`);
      } else {
        console.log("\nNo response time measurements available. Please connect to endpoints first.");
      }
    }
    
    // Make this function globally accessible for direct console access
    window.showModelResponseTimes = function() {
      displayModelResponseTimes();
      return "Model response times have been logged to the console. Check the console output for details.";
    };

  </script>
</body>

</html>