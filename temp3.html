<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0 ,maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="LegalMind - AI-powered legal document assistant">
    <title>LegalMind Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add PDF.js library for PDF processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <!-- Add Tesseract.js for OCR (image text recognition) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.3/dist/tesseract.min.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    
    <!-- Custom CSS for chat input fixes -->
    <link rel="stylesheet" href="fixed_chat_input.css">

    <!-- Model display fix script -->
    <script src="fix-model-display.js"></script>

    <!-- Initialize Firebase -->
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB9TKLmKIVO7-YWKv1iORqnax0sru249sY",
            authDomain: "legalmind-users.firebaseapp.com",
            projectId: "legalmind-users",
            storageBucket: "legalmind-users.firebaseapp.com",
            messagingSenderId: "321034025311",
            appId: "1:321034025311:web:d8a01ac0c02d5b152b1eea"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        
        // Set persistence to LOCAL for better auth state persistence
        firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
            .then(() => {
                console.log("Firebase persistence set to LOCAL");
            })
            .catch((error) => {
                console.error("Error setting persistence:", error);
            });
    </script>

    <!-- OCR Styles -->
    <style>
        .file-preview-container.ocr-preview {
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            background-color: var(--light-bg);
            border-radius: 5px;
            margin-top: 10px;
        }

        .file-preview-container.ocr-preview textarea {
            width: 100%;
            height: 150px;
            resize: none;
            font-family: monospace;
            font-size: 12px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--main-bg);
            color: var(--text-color);
        }

        .dark-mode .file-preview-container.ocr-preview {
            background-color: var(--sidebar-bg);
        }

        .dark-mode .file-preview-container.ocr-preview textarea {
            background-color: var(--main-bg);
            border-color: var(--dark-border-color);
        }

        /* Scrollbar for OCR Preview */
        .file-preview-container.ocr-preview::-webkit-scrollbar {
            width: 8px;
        }

        .file-preview-container.ocr-preview::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }

        .file-preview-container.ocr-preview::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        .file-preview-container.ocr-preview::-webkit-scrollbar-thumb:hover {
            background-color: var(--scrollbar-thumb-hover);
        }

        /* Updated animated thinking indicator styles */
        .thinking-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #e9ecef;
            border-radius: 15px;
            margin: 10px 0;
            max-width: 80%;
            margin-left: 0;
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
        }

        .thinking-dot {
            width: 6px;
            height: 6px;
            background: #6c757d;
            border-radius: 50%;
            animation: thinking 1.4s infinite ease-in-out;
        }

        .thinking-dot:nth-child(1) { animation-delay: 0s; }
        .thinking-dot:nth-child(2) { animation-delay: 0.2s; }
        .thinking-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes thinking {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        body.dark-mode .thinking-container {
            background: #2d3748;
        }

        body.dark-mode .thinking-dot {
            background: #cbd5e0;
        }

        .thinking-header {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .thinking-brain-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, #007bff, #6b47fb);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            animation: pulseGlow 2s infinite;
            box-shadow: 0 0 20px rgba(0, 123, 255, 0.3);
        }

        .thinking-status {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .thinking-status span {
            font-weight: 500;
            color: var(--primary-color);
        }

        .thinking-progress {
            width: 200px;
            height: 4px;
            background: rgba(0, 123, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .thinking-progress-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 30%;
            background: linear-gradient(90deg, #007bff, #6b47fb);
            border-radius: 2px;
            animation: progressMove 2s infinite ease-in-out;
        }

        .thinking-steps {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-left: 60px;
        }

        .thinking-step {
            display: flex;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transform: translateY(10px);
            color: var(--text-color);
            font-size: 0.95rem;
        }

        .thinking-step i {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 123, 255, 0.1);
            border-radius: 50%;
            color: var(--primary-color);
        }

        .thinking-step.active {
            animation: stepFadeIn 0.4s forwards ease-out;
        }

        @keyframes pulseGlow {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 0 rgba(0, 123, 255, 0.2);
            }
        }

        @keyframes progressMove {
            0% {
                transform: translateX(-100%);
            }
            50% {
                transform: translateX(100%);
            }
            100% {
                transform: translateX(300%);
            }
        }

        @keyframes stepFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Dark mode support */
        body.dark-mode .thinking-container {
            background: var(--dark-surface);
            border-color: rgba(255, 255, 255, 0.1);
        }

        body.dark-mode .thinking-step {
            color: var(--dark-text);
        }

        body.dark-mode .thinking-step i {
            background: rgba(255, 255, 255, 0.1);
        }

        body.dark-mode .thinking-steps {
            color: var(--dark-text);
        }
    </style>

    <style>
        /* CSS Variables for theming */
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --success-color: #28a745;
            --success-hover: #218838;
            --danger-color: #dc3545;
            --light-bg: #f8f9fa;
            --dark-bg: #121212;
            --light-surface: #ffffff;
            --dark-surface: #1e1e1e;
            --light-text: #212529;
            --dark-text: #f8f9fa;
            --light-border: #dee2e6;
            --dark-border: #444;
            --box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            --dark-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            --transition: all 0.3s ease;
            --border-radius-sm: 8px;
            --border-radius-md: 12px;
            --border-radius-lg: 16px;
            --border-radius-xl: 24px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--light-bg);
            color: var(--light-text);
            transition: var(--transition);
            overflow-x: hidden;
        }

        body.dark-mode {
            background-color: var(--dark-bg);
            color: var(--dark-text);
        }

        .dashboard {
            display: flex;
            width: 100%;
            height: 100vh;
            border-radius: var(--border-radius-lg);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
        }

        body.dark-mode .dashboard {
            box-shadow: var(--dark-box-shadow);
        }

        /* Left Sidebar with improved padding */
        .sidebar {
            position: relative;
            display: flex;
            flex-direction: column;
            width: 300px;
            height: 100%;
            background-color: var(--bg-color-surface);
            overflow-y: auto;
            transition: all 0.3s ease;
            padding: 15px 12px 0;
        }

        body.dark-mode .sidebar {
            background: var(--dark-surface);
            border-right: 1px solid var(--dark-border);
        }

        .chat-header {
            margin-bottom: var(--spacing-lg);
            padding-left: 5px;
            display: flex;
            align-items: center;
        }

        .chat-header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(90deg, var(--primary-color), #6b47fb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .new-chat {
            width: 100%;
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            cursor: pointer;
            border: none;
            border-radius: var(--border-radius-md);
            background: var(--primary-color);
            color: white;
            transition: var(--transition);
            font-size: 0.95rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-sm);
        }

        .new-chat:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
        }

        .new-chat i {
            margin-right: var(--spacing-xs);
        }

        .chat-list {
            padding: 0;
            overflow-y: auto;
            margin-bottom: var(--spacing-lg);
            flex-grow: 1;
        }

        .chat-list li {
            list-style: none;
            padding: var(--spacing-md);
            margin: var(--spacing-xs) 0;
            background-color: var(--light-bg);
            border-radius: var(--border-radius-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
            cursor: pointer;
            font-weight: 500;
        }

        .chat-list li:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        .chat-list li.active {
            background-color: rgba(0, 123, 255, 0.2);
            border-left: 3px solid var(--primary-color);
        }

        body.dark-mode .chat-list li {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .chat-list li:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        body.dark-mode .chat-list li.active {
            background: rgba(0, 123, 255, 0.3);
        }

        .chat-list li .delete-chat {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 0.9rem;
            color: var(--danger-color);
            opacity: 0.7;
            transition: var(--transition);
        }

        .chat-list li .delete-chat:hover {
            opacity: 1;
        }

        /* Document Preview section with fixed styling */
        .documents-preview {
            position: relative;
            display: flex;
            flex-direction: column;
            margin: 15px 10px;
            background: var(--light-surface);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--light-border);
            padding: var(--spacing-md);
            box-shadow: var(--box-shadow);
            z-index: 5;
            max-height: none;
        }

        body.dark-mode .documents-preview {
            background: var(--dark-surface);
            border-color: var(--dark-border);
            box-shadow: var(--dark-box-shadow);
        }

        .documents-preview h3 {
            margin-bottom: var(--spacing-md);
            font-size: 1rem;
            font-weight: 600;
            color: var(--light-text);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        body.dark-mode .documents-preview h3 {
            color: var(--dark-text);
        }

        #documentPreviews {
            flex: 1;
            min-height: 50px;
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
        }

        .file-item {
            display: flex;
            flex-direction: column;
            background: var(--light-surface);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--light-border);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: var(--transition);
            overflow: hidden;
            margin-bottom: var(--spacing-md);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border-bottom: 1px solid var(--light-border);
            min-height: 40px;
        }

        .file-name-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            flex: 1;
            min-width: 0; /* Enable text truncation */
            margin-right: 8px; /* Space for delete button */
            position: relative;
        }

        .file-name-container i {
            flex-shrink: 0;
            color: #555;
            font-size: 1rem;
        }

        .file-name-container span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px; /* Limit width to ensure delete button visibility */
            transition: all 0.3s ease;
        }

        /* Show full name on hover with tooltip-like effect */
        .file-name-container:hover span {
            position: absolute;
            z-index: 10;
            background: var(--light-surface);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--light-border);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            max-width: none;
            white-space: normal;
            word-break: break-all;
            top: 100%;
            left: 0;
        }

        .delete-file {
            flex-shrink: 0;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 0.85rem;
            color: var(--danger-color);
            opacity: 0.7;
            transition: var(--transition);
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-file:hover {
            opacity: 1;
            background: rgba(220, 53, 69, 0.1);
        }

        body.dark-mode .file-name-container i {
            color: #ddd;
        }

        body.dark-mode .file-name-container:hover span {
            background: var(--dark-surface);
            border-color: var(--dark-border);
        }

        body.dark-mode .delete-file:hover {
            background: rgba(220, 53, 69, 0.2);
        }

        /* PDF specific styling to match screenshot */
        .pdf-icon {
            color: #e74c3c;
        }

        .pdf-preview {
            height: 200px;
            overflow: hidden;
        }

        body.dark-mode .pdf-preview {
            background: #2a2a2a;
        }

        /* Chat Section */
        .chat-section {
            flex: 1;
            padding: var(--spacing-lg);
            display: flex;
            flex-direction: column;
            background-color: var(--light-surface);
            transition: var(--transition);
            position: relative;
            height: 100vh;
            overflow: hidden;
        }

        body.dark-mode .chat-section {
            background-color: var(--dark-surface);
        }

        /* Navigation Bar Styles */
        .chat-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--light-bg);
            padding: var(--spacing-md) var(--spacing-lg);
            box-shadow: var(--box-shadow);
            margin-bottom: var(--spacing-md);
            border-radius: var(--border-radius-md);
            transition: var(--transition);
            position: relative;
            z-index: 10;
        }

        body.dark-mode .chat-nav {
            background-color: rgba(255, 255, 255, 0.05);
            box-shadow: var(--dark-box-shadow);
        }

        /* Nav Left: Menu Toggle + LegalMind.Space */
        .nav-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--light-text);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .menu-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .menu-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        body.dark-mode .menu-toggle {
            color: var(--dark-text);
        }

        .nav-brand {
            font-weight: 700;
            font-size: 1.2rem;
            background: linear-gradient(90deg, var(--primary-color), #6b47fb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Nav Right: Dropdowns, Contact Us, and Profile */
        .nav-right {
            display: flex;
            align-items: center;
            gap: var(--spacing-xl);
        }

        .nav-links {
            display: flex;
            gap: var(--spacing-xl);
            font-weight: 500;
            align-items: center;
        }

        .nav-links a {
            text-decoration: none;
            color: var(--light-text);
            cursor: pointer;
            transition: var(--transition);
        }

        .nav-links a:hover {
            color: var(--primary-color);
        }

        body.dark-mode .nav-links a {
            color: var(--dark-text);
        }

        /* Dropdown Styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: var(--light-surface);
            min-width: 180px;
            box-shadow: var(--box-shadow);
            border-radius: var(--border-radius-md);
            z-index: 1;
            overflow: hidden;
            transition: var(--transition);
        }

        body.dark-mode .dropdown-content {
            background-color: var(--dark-surface);
            box-shadow: var(--dark-box-shadow);
        }

        .dropdown-content a {
            color: var(--light-text);
            padding: var(--spacing-md);
            text-decoration: none;
            display: block;
            transition: var(--transition);
        }

        body.dark-mode .dropdown-content a {
            color: var(--dark-text);
        }

        .dropdown-content a:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        body.dark-mode .dropdown-content a:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* Profile Menu Styles */
        .nav-profile {
            position: relative;
        }

        .nav-profile img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--light-border);
            object-fit: cover;
            transition: var(--transition);
        }

        .profile-menu {
            display: none;
            position: absolute;
            right: 0;
            top: 50px;
            background: var(--light-surface);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow);
            width: 280px;
            transition: var(--transition);
            z-index: 1000;
        }

        .profile-menu.active {
            display: flex;
            flex-direction: column;
        }

        .profile-menu-header {
            display: flex;
            flex-direction: column;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--light-border);
        }

        body.dark-mode .profile-menu-header {
            border-color: var(--dark-border);
        }

        .profile-menu-header .user-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }

        .profile-menu-header .user-plan {
            color: #6c757d;
            font-size: 0.9rem;
        }

        body.dark-mode .profile-menu-header .user-plan {
            color: #adb5bd;
        }

        .profile-menu-actions {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .profile-menu-btn {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            border: none;
            background: var(--light-bg);
            color: var(--light-text);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        body.dark-mode .profile-menu-btn {
            background: rgba(255, 255, 255, 0.05);
            color: var(--dark-text);
        }

        .profile-menu-btn:hover {
            background: rgba(0, 123, 255, 0.1);
            transform: translateY(-2px);
        }

        .profile-menu-btn.logout {
            background-color: rgba(220, 53, 69, 0.1);
            color: var(--danger-color);
        }

        .profile-menu-btn.logout:hover {
            background-color: var(--danger-color);
            color: white;
        }

        /* Settings Panel */
        .settings-panel {
            display: none;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .settings-panel.active {
            display: flex;
        }

        .settings-section {
            background: var(--light-bg);
            border-radius: var(--border-radius-md);
            padding: var(--spacing-md);
            border: 1px solid var(--light-border);
        }

        body.dark-mode .settings-section {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--dark-border);
        }

        .settings-section-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
            font-weight: 500;
        }

        .back-to-menu {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-md);
            color: var(--primary-color);
            background: none;
            border: none;
            padding: 0;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .back-to-menu:hover {
            text-decoration: underline;
        }

        /* Dark mode toggle enhanced */
        .switch {
            display: flex;
            align-items: center;
            margin-top: var(--spacing-xs);
            cursor: pointer;
        }

        .switch input {
            appearance: none;
            width: 44px;
            height: 22px;
            background: #ccc;
            border-radius: 11px;
            position: relative;
            transition: var(--transition);
            cursor: pointer;
            margin-right: var(--spacing-md);
        }

        .switch input:checked {
            background: var(--primary-color);
        }

        .switch input::before {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            transition: var(--transition);
        }

        .switch input:checked::before {
            transform: translateX(22px);
        }

        /* File upload */
        .profile-menu input[type="file"] {
            margin-top: var(--spacing-md);
            display: block;
            width: 100%;
            border-radius: var(--border-radius-md);
            padding: var(--spacing-sm);
            border: 1px solid var(--light-border);
            font-size: 0.9rem;
        }

        body.dark-mode .profile-menu input[type="file"] {
            border-color: var(--dark-border);
            color: var(--dark-text);
            background: rgba(255, 255, 255, 0.05);
        }

        .profile-menu #uploadedFileName {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: var(--spacing-xs);
        }

        body.dark-mode .profile-menu #uploadedFileName {
            color: #adb5bd;
        }

        /* Chat Box with padding adjustments for welcome message */
        .chat-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border: 1px solid var(--light-border);
            /* Update padding to accommodate the sticky welcome message */
            padding: 0 var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
            background-color: var(--light-bg);
            border-radius: var(--border-radius-lg);
            transition: var(--transition);
            margin-bottom: var(--spacing-md);
            position: relative;
            scroll-behavior: smooth;
        }

        /* Add margin to first message to create space after welcome message */
        .chat-box>.message:first-of-type {
            margin-top: var(--spacing-lg);
        }

        body.dark-mode .chat-box {
            background: rgba(255, 255, 255, 0.02);
            border-color: var(--dark-border);
        }

        /* Add padding after welcome message for better spacing */
        .chat-box>.message:first-of-type {
            margin-top: var(--spacing-lg);
        }

        /* Chat Input Styles */
        .chat-input {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            padding: 0 15px;
            margin: 0;
            z-index: 20;
            background: var(--light-surface);
        }

        body.dark-mode .chat-input {
            background: var(--dark-surface);
        }

        .input-container {
            width: 100%;
            border-radius: 30px;
            background-color: var(--light-surface);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
            padding: 2px;
            display: flex;
            align-items: center;
            border: 1px solid var(--light-border);
            transition: all 0.3s ease;
            position: relative;
        }

        body.dark-mode .input-container {
            background-color: var(--dark-surface);
            border-color: var(--dark-border);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
        }

        .input-container:focus-within {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            border-color: var(--primary-color);
        }

        #messageInput {
            flex: 1;
            height: 50px;
            font-size: 16px;
            padding: 12px 50px;
            border: none;
            background: transparent;
            width: 100%;
            color: var(--light-text);
        }

        body.dark-mode #messageInput {
            color: var(--dark-text);
        }

        #messageInput::placeholder {
            color: #6c757d;
            opacity: 0.7;
        }

        body.dark-mode #messageInput::placeholder {
            color: #adb5bd;
        }

        .attach-btn, .image-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            cursor: pointer;
            transition: var(--transition);
        }

        .image-btn {
            left: 25px;
        }

        .attach-btn {
            left: 55px;
        }

        .attach-btn:hover, .image-btn:hover {
            color: var(--primary-color);
        }

        #sendBtn {
            width: 36px;
            height: 36px;
            padding: 0;
            right: 8px;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
        }

        #sendBtn:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }

        #sendBtn i {
            font-size: 0.9rem;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .chat-input {
                padding: 0 10px;
                bottom: 5px;
            }

            .input-container {
                padding: 1px;
            }

            #messageInput {
                height: 45px;
                font-size: 15px;
                padding: 10px 45px;
            }

            .attach-btn, .image-btn {
                width: 35px;
                height: 35px;
            }

            #sendBtn {
                width: 32px;
                height: 32px;
            }
        }

        /* Add margin to first message to create space after welcome message */
        .chat-box>.message:first-of-type {
            margin-top: var(--spacing-lg);
        }

        body.dark-mode .chat-box {
            background: rgba(255, 255, 255, 0.02);
            border-color: var(--dark-border);
        }

        /* Add padding after welcome message for better spacing */
        .chat-box>.message:first-of-type {
            margin-top: var(--spacing-lg);
        }

        /* Chat Input */
        .chat-input {
            display: flex;
            margin-top: var(--spacing-md);
            gap: var(--spacing-md);
            position: relative;
        }

        .input-container {
            position: relative;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .chat-input input {
            flex: 1;
            width: 100%;
            padding: var(--spacing-md) var(--spacing-lg);
            padding-left: 40px;
            padding-right: 50px;
            border: 1px solid var(--light-border);
            border-radius: 30px;
            font-size: 1rem;
            background-color: var(--light-surface);
            color: var(--light-text);
            transition: var(--transition);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .chat-input input {
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--dark-text);
            border-color: var(--dark-border);
        }

        .chat-input input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        .attach-btn {
            position: absolute;
            right: 55px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
            font-size: 1.2rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2.3;
        }

        .attach-btn:hover {
            color: var(--primary-color);
        }

        body.dark-mode .attach-btn {
            color: #adb5bd;
        }

        .image-btn {
            position: absolute;
            right: 95px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
            font-size: 1.2rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .image-btn:hover {
            color: var(--primary-color);
        }

        body.dark-mode .image-btn {
            color: #adb5bd;
        }

        #sendBtn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 8px;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2.3;
            transition: all 0.2s ease;
        }

        #sendBtn:hover {
            transform: translateY(-50%) scale(1.1);
        }

        /* Chat Messages */
        .message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            font-size: 0.9rem;  /* Added smaller font size */
            line-height: 1.4;   /* Added appropriate line height */
        }

        .message.user {
            background: #007bff;
            color: white;
            margin-left: auto;
            font-size: 0.9rem;  /* Consistent font size for user messages */
        }

        .message.bot {
            background: #e9ecef;
            color: #212529;
            margin-right: auto;
            font-size: 0.9rem;  /* Consistent font size for bot messages */
        }

        body.dark-mode .message.bot {
            background: #2d3748;
            color: #e2e8f0;
        }

        /* Welcome Message with fixed positioning */
        .welcome-message {
            text-align: center;
            padding: 20px;
            background-color: var(--light-bg);
            border-bottom: 1px solid var(--light-border);
            margin-bottom: 0;
            position: relative;
            width: 100%;
            border-top-left-radius: var(--border-radius-lg);
            border-top-right-radius: var(--border-radius-lg);
            transition: var(--transition);
        }

        body.dark-mode .welcome-message {
            background-color: var(--dark-bg);
            border-color: var(--dark-border);
        }

        .welcome-message.hidden {
            display: none;
        }

        .welcome-message h2 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 600;
            background: linear-gradient(90deg, var(--primary-color), #6b47fb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: var(--spacing-xs);
        }

        .welcome-message p {
            margin-top: var(--spacing-xs);
            font-size: 1.1rem;
            color: #6c757d;
        }

        body.dark-mode .welcome-message p {
            color: #ddd;
        }

        .welcome-message .model-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            background: #f2f5f9;
            display: inline-block;
            padding: 4px 10px;
            border-radius: 15px;
        }

        .welcome-message .model-info .fas {
            color: #4CAF50;
            margin-right: 5px;
        }

        .welcome-message .model-info .model-id {
            color: #888;
            font-size: 12px;
        }

        body.dark-mode .welcome-message .model-info {
            background: #2d3748;
            color: #cbd5e0;
        }

        body.dark-mode .welcome-message .model-info .model-id {
            color: #a0aec0;
        }

        /* Responsive adjustments for sidebar */
        @media (max-width: 992px) {
            .dashboard {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 990;
                background-color: var(--light-surface);
                display: none;
                flex-direction: column;
                width: 100%;
                height: 100vh;
                overflow-y: auto;
                padding: 15px;
            }

            body.dark-mode .sidebar {
                background-color: var(--dark-surface);
            }

            .sidebar .chat-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .sidebar .chat-header:after {
                content: "\f00d";
                font-family: "Font Awesome 5 Free";
                font-weight: 900;
                font-size: 1.2rem;
                cursor: pointer;
                color: var(--light-text);
            }

            body.dark-mode .sidebar .chat-header:after {
                color: var(--dark-text);
            }

            .documents-preview {
                margin-top: 15px;
                flex: 1;
                max-height: none;
            }

            #documentPreviews {
                max-height: none;
                flex: 1;
                overflow-y: auto;
            }

            .chat-section {
                padding: var(--spacing-md);
                height: 100vh !important;
            }

            .nav-links {
                display: none;
            }

            .nav-right {
                gap: var(--spacing-md);
            }

            .menu-toggle {
                display: block;
                position: relative;
                background: none;
                border: none;
                font-size: 1.5rem;
                color: var(--light-text);
                cursor: pointer;
                transition: var(--transition);
            }

            body.dark-mode .menu-toggle {
                color: var(--dark-text);
            }

            .chat-box {
                max-height: calc(100vh - 140px) !important;
            }

            /* Fixed document preview visibility */
            .sidebar.collapsed .documents-preview {
                display: none !important;
            }

            .sidebar:not(.collapsed) .documents-preview {
                display: flex !important;
                max-height: none;
                overflow: visible;
                margin-bottom: var(--spacing-md);
            }

            /* Ensure toggle button is always visible */
            .documents-toggle {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
                height: 35px;
                border-radius: 0;
                position: relative;
                bottom: 0;
                margin-top: 0;
                z-index: 100;
            }

            .documents-preview {
                position: relative;
                max-height: none;
                border: 1px solid var(--light-border);
                margin: 20px 15px;
                border-radius: var(--border-radius-md);
                overflow: hidden;
            }

            #documentPreviews {
                max-height: 200px;
                padding: 8px;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                padding: 10px 8px 0;
            }

            .message {
                max-width: 85%;
            }

            .profile-menu {
                width: 260px;
                right: -10px;
                padding: var(--spacing-md);
            }

            .documents-preview {
                margin: 15px 10px;
                padding: 12px;
            }

            #documentPreviews {
                max-height: 150px;
                padding: 5px;
            }

            .documents-toggle {
                height: 30px;
            }

            .profile-pic-section {
                padding: var(--spacing-sm);
            }

            .profile-preview {
                width: 60px;
                height: 60px;
            }

            .chat-input {
                display: grid;
                grid-template-columns: 40px 1fr;
                grid-template-rows: auto auto;
                gap: var(--spacing-sm);
            }

            .attach-btn {
                position: relative;
                grid-row: 2;
                grid-column: 1;
                transform: none;
                top: auto;
                left: auto;
                height: 100%;
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: var(--light-bg);
                border-radius: var(--border-radius-md);
                border: 1px solid var(--light-border);
            }

            body.dark-mode .attach-btn {
                background: rgba(255, 255, 255, 0.05);
                border-color: var(--dark-border);
            }

            .chat-input input {
                grid-row: 2;
                grid-column: 2;
                padding-left: var(--spacing-md);
            }

            #sendBtn {
                grid-row: 3;
                grid-column: 1 / span 2;
                width: 100%;
                margin-top: var(--spacing-xs);
            }

            .chat-nav {
                flex-wrap: wrap;
            }

            .nav-profile img {
                width: 35px;
                height: 35px;
            }
        }

        @media (max-width: 576px) {
            .sidebar {
                padding: 10px 5px 0;
            }

            .chat-nav {
                padding: var(--spacing-sm) var(--spacing-md);
            }

            .nav-left {
                font-size: 1rem;
            }

            .chat-section {
                padding: var(--spacing-md);
            }

            .welcome-message h2 {
                font-size: 1.5rem;
            }

            .welcome-message p {
                font-size: 1rem;
            }

            .chat-box {
                padding: var(--spacing-md);
            }

            .message {
                max-width: 90%;
                padding: var(--spacing-sm) var(--spacing-md);
            }

            #currentChat {
                font-size: 0.8rem;
            }

            .chat-header h1 {
                font-size: 1.3rem;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                padding: 8px 5px 0;
            }

            .documents-preview {
                margin: 10px 5px;
                padding: 10px;
            }

            .message {
                max-width: 95%;
            }

            .chat-nav {
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .nav-left {
                font-size: 0.9rem;
            }

            .nav-profile img {
                width: 30px;
                height: 30px;
            }

            .profile-menu {
                width: 240px;
                right: -15px;
                padding: var(--spacing-md);
            }
        }

        /* Enhanced mobile menu styling */
        .mobile-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 85%;
            max-width: 320px;
            height: 100vh;
            background-color: var(--light-surface);
            z-index: 999;
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: var(--dark-box-shadow);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        body.dark-mode .mobile-menu {
            background-color: var(--dark-surface);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mobile-menu.active {
            transform: translateX(0);
        }

        .mobile-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(2px);
        }

        .mobile-menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Refined mobile menu header */
        .mobile-menu-header {
            padding: var(--spacing-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            border-bottom: 1px solid var(--light-border);
            position: sticky;
            top: 0;
            background-color: var(--light-surface);
            z-index: 2;
        }

        body.dark-mode .mobile-menu-header {
            border-color: var(--dark-border);
            background-color: var(--dark-surface);
        }

        .mobile-menu-header h1 {
            font-size: 1.5rem;
            margin: 0;
            background: linear-gradient(90deg, var(--primary-color), #6b47fb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .mobile-menu-content {
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            overflow-y: auto;
        }

        /* Enhanced mobile menu buttons */
        .mobile-menu-btn {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: 12px var(--spacing-lg);
            border-radius: 10px;
            background: none;
            border: none;
            color: var(--light-text);
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .mobile-menu-btn::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0;
            background-color: rgba(0, 123, 255, 0.1);
            transition: width 0.2s ease;
            z-index: -1;
            border-radius: 10px;
        }

        .mobile-menu-btn:active {
            transform: scale(0.98);
        }

        .mobile-menu-btn:hover::after {
            width: 100%;
        }

        body.dark-mode .mobile-menu-btn {
            color: var(--dark-text);
        }

        body.dark-mode .mobile-menu-btn::after {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .mobile-menu-btn.new-chat-btn {
            background: var(--primary-color);
            color: white;
            font-weight: 500;
            margin-bottom: var(--spacing-md);
            box-shadow: 0 4px 6px rgba(0, 123, 255, 0.2);
        }

        .mobile-menu-btn.new-chat-btn:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 123, 255, 0.3);
        }

        .mobile-menu-btn.new-chat-btn:active {
            transform: translateY(0);
        }

        /* Improved section headers */
        .mobile-section-header {
            font-size: 0.85rem;
            font-weight: 600;
            color: #6c757d;
            padding: 14px var(--spacing-lg) 8px;
            margin-top: var(--spacing-md);
            position: sticky;
            top: 71px;
            background-color: var(--light-surface);
            z-index: 1;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        body.dark-mode .mobile-section-header {
            color: #adb5bd;
            background-color: var(--dark-surface);
        }

        /* Enhanced chat items */
        .mobile-chat-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-sm);
            padding: 10px var(--spacing-md);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .mobile-chat-item .chat-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex: 1;
            overflow: hidden;
        }

        .mobile-chat-item .delete-chat {
            background: none;
            border: none;
            color: var(--danger-color);
            opacity: 0.7;
            font-size: 0.85rem;
            padding: 5px;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .mobile-chat-item .delete-chat:hover {
            opacity: 1;
        }

        .mobile-chat-item i {
            color: #6c757d;
            font-size: 0.9rem;
            width: 20px;
            text-align: center;
        }

        body.dark-mode .mobile-chat-item i {
            color: #adb5bd;
        }

        .mobile-chat-item span {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mobile-chat-item::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0;
            background-color: rgba(0, 123, 255, 0.1);
            transition: width 0.2s ease;
            z-index: -1;
            border-radius: 10px;
        }

        .mobile-chat-item:hover::after {
            width: 100%;
        }

        .mobile-chat-item.active {
            background-color: rgba(0, 123, 255, 0.15);
            font-weight: 500;
        }

        .mobile-chat-item.active i {
            color: var(--primary-color);
        }

        body.dark-mode .mobile-chat-item.active {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Better menu button animation */
        .menu-toggle {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--light-text);
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .menu-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .menu-toggle:active {
            transform: scale(0.95);
        }

        /* Model dropdown styling */
        .model-dropdown {
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        /* Mobile responsiveness */
        @media (max-width: 992px) {
            .menu-toggle {
                display: block;
            }

            .nav-left {
                gap: var(--spacing-sm);
            }

            .dashboard {
                height: 100vh;
                overflow: hidden;
            }

            .sidebar {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .chat-section {
                padding: var(--spacing-md) var(--spacing-md);
            }

            .chat-nav {
                padding: var(--spacing-sm) var(--spacing-md);
                margin-bottom: var(--spacing-sm);
            }

            .chat-box {
                padding: var(--spacing-md);
            }
        }

        @media (max-width: 576px) {
            .chat-section {
                padding: var(--spacing-sm);
            }

            .chat-nav {
                padding: var(--spacing-sm);
                margin-bottom: var(--spacing-sm);
            }
        }

        @media (max-width: 480px) {
            .nav-brand {
                font-size: 1rem;
            }

            .model-dropdown i {
                font-size: 0.7rem !important;
            }
        }

        @media (max-width: 992px) {

            /* Remove document preview button from mobile menu */
            .mobile-menu-btn[onclick*="toggleDocumentPreview"] {
                display: none;
            }

            /* Use full screen height for chat section on mobile */
            .chat-section {
                height: 100vh !important;
                max-height: none !important;
                padding-bottom: 10px;
            }

            /* Fix chat box height to utilize full screen */
            .chat-box {
                max-height: calc(100vh - 120px) !important;
                margin-bottom: 10px;
            }

            /* Hide document preview section entirely on mobile */
            .documents-preview,
            .sidebar .documents-preview,
            .sidebar:not(.collapsed) .documents-preview {
                display: none !important;
            }

            /* Hide document-related toggle buttons */
            .documents-toggle {
                display: none !important;
            }
        }

        /* File upload message styling in chat */
        .file-upload {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            margin: 5px 0;
        }

        body.dark-mode .file-upload {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .file-upload i {
            font-size: 1.2rem;
            color: var(--primary-color);
        }

        .file-upload span {
            font-size: 0.95rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        @media (max-width: 768px) {
            .chat-input {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 8px;
                position: relative;
            }

            .input-container {
                flex: 1;
                position: relative;
            }


            .attach-btn {
                position: absolute;
                left: 12px;
                top: 50%;
                transform: translateY(-50%);
                height: auto;
                width: auto;
                background: transparent;
                border: none;
                z-index: 2;
            }


            .image-btn {
                position: absolute;
                left: 40px;
                top: 50%;
                transform: translateY(-50%);
                height: auto;
                width: auto;
                background: transparent;
                border: none;
                z-index: 2;
            }


            #sendBtn {
                right: 8px;
                font-size: 1.2rem;
            }
        }

        /* Scroll to bottom button */
        .scroll-bottom-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.3s ease;
            z-index: 10;
            border: none;
        }

        .scroll-bottom-btn.visible {
            opacity: 1;
            transform: scale(1);
        }

        .scroll-bottom-btn:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }

        .scroll-bottom-btn:active {
            transform: scale(0.95);
        }

        /* Mobile-specific adjustments for chat input */
        @media (max-width: 768px) {
            .chat-input {
                display: flex;
                flex-direction: row;
                position: relative;
                margin-top: var(--spacing-sm);
                margin-bottom: var(--spacing-sm);
            }

            .input-container {
                flex: 1;
                display: flex;
                align-items: center;
                position: relative;
            }

            .chat-input input {
                width: 100%;
                padding: 12px 40px;
                border-radius: 24px;
                font-size: 1rem;
            }

            .attach-btn {
                position: absolute;
                left: 12px;
                top: 50%;
                transform: translateY(-50%);
                background: transparent;
                border: none;
                color: #6c757d;
                z-index: 2;
            }

            .image-btn {
                position: absolute;
                left: 40px;
                top: 50%;
                transform: translateY(-50%);
                background: transparent;
                border: none;
                color: #6c757d;
                z-index: 2;
            }

            #sendBtn {
                position: absolute;
                right: 12px;
                top: 50%;
                transform: translateY(-50%);
                background: none;
                border: none;
                color: var(--primary-color);
                font-size: 1.2rem;
                z-index: 2;
            }

            /* Ensure chat box fills available space */
            .chat-box {
                max-height: calc(100vh - 170px);
            }
        }

        /* Further mobile refinements */
        @media (max-width: 576px) {
            .chat-input {
                margin-top: 6px;
                margin-bottom: 6px;
            }

            .chat-input input {
                padding: 10px 38px;
                font-size: 0.95rem;
            }

            #sendBtn,
            .attach-btn {
                font-size: 1.1rem;
            }

            #sendBtn {
                width: 32px;
                height: 32px;
                padding: 0;
                right: 8px;
                background-color: var(--primary-color);
                color: white;
                border-radius: 50%;
            }

            #sendBtn i {
                font-size: 0.85rem;
            }
        }

        /* Small mobile screens */
        @media (max-width: 480px) {
            .chat-input {
                margin-top: 4px;
                margin-bottom: 4px;
            }

            .chat-input input {
                padding: 9px 36px;
                font-size: 0.9rem;
            }

            #sendBtn,
            .attach-btn {
                font-size: 1rem;
            }

            #sendBtn {
                width: 28px;
                height: 28px;
                padding: 0;
                right: 8px;
                background-color: var(--primary-color);
                color: white;
                border-radius: 50%;
            }

            #sendBtn i {
                font-size: 0.85rem;
            }
        }

        /* Mobile-specific adjustments for chat input */
        @media (max-width: 992px) {
            .chat-section {
                position: relative;
                display: flex;
                flex-direction: column;
                height: fit-content !important;
                min-height: 100vh;
                padding-bottom: 80px !important;
                /* Space for input */
            }

            .chat-box {
                flex: 1;
                height: calc(100vh - 180px) !important;
                margin-bottom: 5px;
            }

            .chat-input {
                position: fixed;
                bottom: 10px;
                left: 0;
                right: 0;
                padding: 0 15px;
                margin: 0;
                z-index: 20;
                background: var(--light-surface);
            }

            body.dark-mode .chat-input {
                background: var(--dark-surface);
            }

            .input-container {
                width: 100%;
                border-radius: 30px;
                background-color: var(--light-surface);
                box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
                padding: 2px;
                display: flex;
                align-items: center;
                border: 1px solid var(--light-border);
                transition: all 0.3s ease;
                position: relative;
            }

            body.dark-mode .input-container {
                background-color: var(--dark-surface);
                border-color: var(--dark-border);
                box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
            }

            .attach-btn {
                position: absolute;
                left: 55px;
                top: 50%;
                transform: translateY(-50%);
                display: flex;
                align-items: center;
                justify-content: center;
                width: 40px;
                height: 40px;
                padding: 0;
                margin: 0;
            }

            .image-btn {
                position: absolute;
                left: 25px;
                top: 50%;
                transform: translateY(-50%);
                display: flex;
                align-items: center;
                justify-content: center;
                width: 40px;
                height: 40px;
                padding: 0;
                margin: 0;
            }

            .chat-input input {
                height: 50px;
                font-size: 16px;
                padding: 12px 50px;
                border: none;
                background: transparent;
                width: 100%;
            }

            #sendBtn {
                width: 36px;
                height: 36px;
                padding: 0;
                right: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: var(--primary-color);
                color: white;
                border-radius: 50%;
            }

            #sendBtn i {
                font-size: 0.9rem;
            }

            body.dark-mode #sendBtn {
                background-color: var(--primary-color);
            }
        }

        /* Additional mobile refinements */
        @media (max-width: 576px) {
            .chat-section {
                height: fit-content !important;
                min-height: 100vh;
            }

            .chat-box {
                height: calc(100vh - 160px) !important;
            }

            .attach-btn {
                width: 35px;
                height: 35px;
            }

            .image-btn {
                width: 35px;
                height: 35px;
                right: 85px;
            }

        }

        /* Small mobile screens */
        @media (max-width: 480px) {
            .chat-section {
                padding: var(--spacing-sm);
            }

            .chat-box {
                height: calc(100vh - 150px) !important;
            }

            .attach-btn {
                width: 32px;
                height: 32px;
            }

            .image-btn {
                width: 32px;
                height: 32px;
                right: 85px;
            }

        }

        /* Interactive effects for mobile inputs */
        @media (max-width: 992px) {

            /* Input animation when focused */
            .input-container:focus-within {
                transform: translateY(-2px);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                border-color: var(--primary-color);
            }

            /* Message animations */
            .message {
                transition: transform 0.2s ease, opacity 0.2s ease;
            }

            .message.user {
                animation: messageSlideInRight 0.3s ease forwards;
            }

            .message.bot {
                animation: messageSlideInLeft 0.3s ease forwards;
            }

            @keyframes messageSlideInRight {
                from {
                    opacity: 0;
                    transform: translateX(30px);
                }

                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }

            @keyframes messageSlideInLeft {
                from {
                    opacity: 0;
                    transform: translateX(-30px);
                }

                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }

            /* Send button ripple effect */
            #sendBtn::after {
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                border-radius: 50%;
                background-color: rgba(255, 255, 255, 0.4);
                transform: scale(0);
                transition: transform 0.3s ease-out;
            }

            #sendBtn:active::after {
                transform: scale(2);
                opacity: 0;
                transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            }

            /* Attach button ripple effect */
            .attach-btn::after {
                content: '';
                position: absolute;
                width: 30px;
                height: 30px;
                border-radius: 50%;
                background-color: rgba(0, 0, 0, 0.1);
                transform: scale(0);
                left: 50%;
                top: 50%;
                margin-left: -15px;
                margin-top: -15px;
            }

            .attach-btn:active::after {
                transform: scale(1);
                opacity: 0;
                transition: transform 0.2s ease-out, opacity 0.2s ease-out;
            }

            /* Input placeholder animation */
            @keyframes placeholderPulse {
                0% {
                    opacity: 0.6;
                }

                50% {
                    opacity: 1;
                }

                100% {
                    opacity: 0.6;
                }
            }

            .chat-input input::placeholder {
                animation: placeholderPulse 2s infinite;
            }

            /* Make sure input is always visible */
            .chat-section {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Smooth scrolling on iOS */
            }
        }

        /* Touch-specific styling for active elements */
        .touch-active {
            transform: scale(0.96) !important;
            opacity: 0.8;
            transition: transform 0.1s ease, opacity 0.1s ease;
        }

        #sendBtn.touch-active {
            background-color: var(--primary-hover);
        }

        .attach-btn.touch-active {
            color: var(--primary-color);
        }

        /* Ensure iOS Safari specific improvements */
        @supports (-webkit-touch-callout: none) {
            .chat-input input {
                font-size: 16px;
                /* Prevents iOS zoom on focus */
            }

            .chat-section {
                padding-bottom: 85px !important;
                /* Extra room for iOS virtual keyboard */
            }
        }

        /* Active model in dropdown */
        .dropdown-content a.active-model {
            background-color: #e8f4ff;
            color: #007bff;
            position: relative;
        }

        .dropdown-content a.active-model::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        body.dark-mode .dropdown-content a.active-model {
            background-color: #1a3554;
            color: #60a5fa;
        }

        /* Notification system */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            background-color: #f8f9fa;
            color: #333;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            z-index: 9999;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
            max-width: 300px;
            word-wrap: break-word;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .notification.info {
            background-color: #e7f2fd;
            border-left: 4px solid #2196F3;
        }

        .notification.success {
            background-color: #e8f6e9;
            border-left: 4px solid #4CAF50;
        }

        .notification.warning {
            background-color: #fff8e6;
            border-left: 4px solid #FF9800;
        }

        .notification.error {
            background-color: #fdeded;
            border-left: 4px solid #F44336;
        }

        body.dark-mode .notification {
            background-color: #2d3748;
            color: #e2e8f0;
        }

        body.dark-mode .notification.info {
            background-color: #1a365d;
            border-left: 4px solid #4299e1;
        }

        body.dark-mode .notification.success {
            background-color: #1c4532;
            border-left: 4px solid #48bb78;
        }

        body.dark-mode .notification.warning {
            background-color: #744210;
            border-left: 4px solid #ed8936;
        }

        body.dark-mode .notification.error {
            background-color: #742a2a;
            border-left: 4px solid #f56565;
        }

        /* Test API button */
        .test-api-btn,
        .wake-up-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: var(--border-radius-sm);
            margin-top: 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .test-api-btn:hover,
        .wake-up-btn:hover {
            background-color: var(--primary-hover);
        }

        .test-api-btn i,
        .wake-up-btn i {
            margin-right: 6px;
        }

        .wake-up-btn {
            background-color: #28a745;
        }

        .wake-up-btn:hover {
            background-color: #218838;
        }

        body.dark-mode .test-api-btn {
            background-color: #2d3748;
        }

        body.dark-mode .test-api-btn:hover {
            background-color: #4a5568;
        }

        body.dark-mode .wake-up-btn {
            background-color: #1e7e34;
        }

        body.dark-mode .wake-up-btn:hover {
            background-color: #155724;
        }

        .chat-input .image-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 12px;
            color: #888;
            cursor: pointer;
            transition: var(--transition);
        }

        .chat-input .image-btn:hover {
            color: var(--primary-color);
        }

        /* Premium Models Dropdown Styles */
        .nav-brand-link {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .premium-models {
            min-width: 220px;
        }

        .dropdown-header {
            padding: 12px 16px;
            font-weight: 600;
            color: var(--primary-color);
            border-bottom: 1px solid var(--light-border);
        }

        .dropdown-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--light-border);
        }

        .model-badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 12px;
            margin-left: 8px;
        }

        .upgrade-link {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--primary-color);
            font-weight: 500;
            text-decoration: none;
        }

        .upgrade-link:hover {
            text-decoration: underline;
        }

        body.dark-mode .dropdown-header,
        body.dark-mode .dropdown-footer {
            border-color: var(--dark-border);
        }

        /* Add these styles in the CSS section */
        
        /* Message input styles */
        .input-container {
            display: flex;
            background: var(--light-surface);
            border-radius: var(--border-radius-lg);
            padding: 4px;
            margin: 10px;
            box-shadow: var(--box-shadow);
            transition: box-shadow 0.3s ease;
        }
        
        .input-container:focus-within {
            box-shadow: 0 0 0 2px var(--primary-color);
        }
        
        .input-controls {
            display: flex;
            align-items: flex-end;
            width: 100%;
            gap: 8px;
        }
        
        .attachment-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--light-text);
            background: transparent;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: 8px;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        .attachment-btn:hover {
            color: var(--primary-color);
        }
        
        .message-input-wrapper {
            flex: 1;
            position: relative;
        }
        
        #messageInput {
            width: 100%;
            background: transparent;
            border: none;
            padding: 12px 8px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: none;
            max-height: 120px;
            overflow-y: auto;
            outline: none;
        }
        
        #messageInput::placeholder {
            color: var(--light-text);
            opacity: 0.7;
        }
        
        #sendBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            width: 36px;
            height: 36px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #sendBtn:hover {
            background-color: var(--primary-dark);
        }
        
        .d-none {
            display: none;
        }

        /* Update attachment button and send button styles */
        .attachment-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--light-text);
            background: transparent;
            border: none;
            border-radius: 50%;
            padding: 12px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 42px;
            height: 42px;
        }

        .attachment-btn:hover {
            color: var(--primary-color);
            background-color: rgba(0, 123, 255, 0.1);
        }

        #sendBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 42px;
            height: 42px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        #sendBtn:hover {
            background-color: #0056b3; /* Darker blue */
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Updated premium dropdown styles */
        .premium-models {
            min-width: 240px;
            padding: 0;
        }

        .dropdown-header {
            padding: 12px 16px;
            font-weight: 600;
            color: var(--dark-text);
            background-color: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .premium-models a {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            font-size: 0.95rem;
        }

        .model-star {
            color: #ffc107;
            margin-right: 8px;
            font-size: 1rem;
        }

        .model-name {
            flex: 1;
            font-weight: 500;
        }

        .premium-label {
            background-color: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .dropdown-divider {
            height: 1px;
            background-color: #e9ecef;
            margin: 0;
        }

        .upgrade-link {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 16px;
            background-color: #f8f9fa;
            color: var(--primary-dark);
            text-align: center;
            font-weight: 600;
            border-top: 1px solid #e9ecef;
        }

        .crown-icon {
            color: #ffc107;
            margin-right: 8px;
        }

        /* Updated model selection dropdown styles */
        .models-menu {
            min-width: 240px;
            padding: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .models-menu .dropdown-header {
            padding: 12px 16px;
            font-weight: 600;
            color: #1a1a1a;
            border-bottom: 1px solid #e9ecef;
        }

        .models-menu a {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #1a1a1a;
            text-decoration: none;
            transition: background-color 0.2s;
        }

        .models-menu a:hover {
            background-color: #f8f9fa;
        }

        .model-star {
            margin-right: 12px;
            font-size: 1.1rem;
        }

        .model-name {
            flex: 1;
            font-weight: 500;
        }

        .dropdown-divider {
            height: 1px;
            background-color: #e9ecef;
            margin: 0;
        }

        .upgrade-link {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #1a1a1a;
            font-weight: 600;
            background-color: #f8f9fa;
        }

        .crown-icon {
            margin-right: 12px;
            font-size: 1.1rem;
        }

        /* Dark mode support */
        body.dark-mode .models-menu {
            background: #2d3748;
            border-color: #4a5568;
        }

        body.dark-mode .models-menu .dropdown-header {
            color: #e2e8f0;
            border-color: #4a5568;
        }

        body.dark-mode .models-menu a {
            color: #e2e8f0;
        }

        body.dark-mode .models-menu a:hover {
            background-color: #4a5568;
        }

        body.dark-mode .dropdown-divider {
            background-color: #4a5568;
        }

        body.dark-mode .upgrade-link {
            background-color: #2d3748;
            color: #e2e8f0;
        }

        /* Add dropdown show class */
        .models-menu.show {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Add styles for document changes review UI */
        .changes-review {
            background: var(--light-surface);
            border: 1px solid var(--light-border);
            border-radius: var(--border-radius-md);
            margin: 15px 0;
            overflow: hidden;
        }

        body.dark-mode .changes-review {
            background: var(--dark-surface);
            border-color: var(--dark-border);
        }

        .changes-header {
            padding: 12px 15px;
            border-bottom: 1px solid var(--light-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--light-bg);
        }

        body.dark-mode .changes-header {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--dark-border);
        }

        .changes-title {
            font-weight: 600;
            font-size: 1rem;
            color: var(--light-text);
        }

        body.dark-mode .changes-title {
            color: var(--dark-text);
        }

        .changes-actions {
            display: flex;
            gap: 8px;
        }

        .changes-action-btn {
            padding: 6px 12px;
            border-radius: 4px;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .accept-btn {
            background: var(--success-color);
            color: white;
        }

        .accept-btn:hover {
            background: var(--success-hover);
        }

        .reject-btn {
            background: var(--danger-color);
            color: white;
        }

        .reject-btn:hover {
            background: var(--danger-hover);
        }

        .changes-content {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .diff-view {
            font-family: monospace;
            white-space: pre-wrap;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .diff-line {
            display: flex;
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .diff-line.removed {
            background: rgba(220, 53, 69, 0.1);
            color: var(--danger-color);
        }

        .diff-line.added {
            background: rgba(40, 167, 69, 0.1);
            color: var(--success-color);
        }

        body.dark-mode .diff-line.removed {
            background: rgba(220, 53, 69, 0.2);
        }

        body.dark-mode .diff-line.added {
            background: rgba(40, 167, 69, 0.2);
        }

        .diff-marker {
            width: 20px;
            user-select: none;
        }

        .changes-summary {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--light-border);
        }

        body.dark-mode .changes-summary {
            border-color: var(--dark-border);
        }

        .change-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
            font-size: 0.9rem;
        }

        .change-item i {
            width: 16px;
            text-align: center;
        }
    </style>

    <script>
        // Add haptic feedback for mobile interactions
        document.addEventListener('DOMContentLoaded', function () {
            // Haptic feedback function
            function vibrateOnTouch(duration = 20) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(duration);
                }
            }

            // Add haptic feedback to send button
            const sendBtn = document.getElementById('sendBtn');
            if (sendBtn) {
                sendBtn.addEventListener('touchstart', function () {
                    vibrateOnTouch(20);
                    this.classList.add('touch-active');
                }, { passive: true });

                sendBtn.addEventListener('touchend', function () {
                    this.classList.remove('touch-active');
                }, { passive: true });
            }

            // Add haptic feedback to attach button
            const attachBtn = document.querySelector('.attach-btn');
            if (attachBtn) {
                attachBtn.addEventListener('touchstart', function () {
                    vibrateOnTouch(15);
                    this.classList.add('touch-active');
                }, { passive: true });

                attachBtn.addEventListener('touchend', function () {
                    this.classList.remove('touch-active');
                }, { passive: true });
            }

            // Improve message input focus handling
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                // Auto focus input when chat loads on mobile
                // but only if a chat is already selected
                if (window.innerWidth <= 992 && currentChatId) {
                    setTimeout(() => {
                        // Scroll to ensure input is visible without forcing focus
                        const chatSection = document.querySelector('.chat-section');
                        if (chatSection) {
                            chatSection.scrollIntoView({ behavior: 'smooth', block: 'end' });
                        }
                    }, 300);
                }

                // Add haptic feedback when typing
                messageInput.addEventListener('keydown', function () {
                    if (window.innerWidth <= 992) {
                        vibrateOnTouch(5); // Very subtle vibration
                    }
                }, { passive: true });
            }
        });
    </script>

    <!-- Add document processing scripts -->
    <script>
        // Document Processing Functions
        async function processDocument(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        // Store document content
                        uploadedDocuments[file.name] = {
                            content: e.target.result,
                            original: e.target.result
                        };
                        
                        // Automatically generate summary
                        setTimeout(() => {
                            const summary = `Here's a summary of your document "${file.name}":
                            
-  **Document Analysis**
- Document type: ${file.name.split('.').pop().toUpperCase()}
- Content preview available
                            
-  **Suggestions**:
1. Review legal terminology for accuracy
2. Check for missing clauses
3. Ensure proper formatting
                            
Would you like me to implement any of these suggestions?`;
                            
                            appendMessage("bot", summary);
                            
                            // Add download button
                            addDownloadButton(file.name);
                        }, 1000);
                        
                        resolve();
            } catch (error) {
                        console.error("Error processing document:", error);
                        reject(error);
                    }
                };
                
                reader.onerror = function() {
                    reject(new Error("Error reading file"));
                };
                
                if (file.type === "text/plain" || 
                    file.name.endsWith('.txt') || 
                    file.name.endsWith('.md')) {
                    reader.readAsText(file);
                } else {
                    reader.readAsDataURL(file);
                }
            });
        }
        
        // Add download button to file preview
        function addDownloadButton(fileName) {
            const fileItems = document.querySelectorAll('.file-item');
            let fileItem = null;
            
            for (const item of fileItems) {
                const nameEl = item.querySelector('.file-name-container span');
                if (nameEl && nameEl.textContent === fileName) {
                    fileItem = item;
                    break;
                }
            }
            
            if (!fileItem) return;
            
            // Create download button container if not exists
            if (!fileItem.querySelector('.file-actions')) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'file-actions';
                actionsDiv.style.cssText = 'display:flex; padding:8px; gap:8px; border-top:1px solid #eee';
                
                // Original download button
                const origBtn = document.createElement('button');
                origBtn.innerHTML = '<i class="fas fa-download"></i> Download';
                origBtn.style.cssText = 'background:#f8f9fa; border:1px solid #dee2e6; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; gap:4px';
                origBtn.onclick = () => downloadDocument(fileName);
                
                // Modified download button (hidden initially)
                const modBtn = document.createElement('button');
                modBtn.innerHTML = '<i class="fas fa-download"></i> Modified';
                modBtn.style.cssText = 'background:#007bff; color:white; border:1px solid #007bff; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:0.8rem; display:none; align-items:center; gap:4px';
                modBtn.onclick = () => downloadDocument(fileName, true);
                modBtn.id = `mod-btn-${fileName.replace(/[^a-zA-Z0-9]/g, '')}`;
                
                actionsDiv.appendChild(origBtn);
                actionsDiv.appendChild(modBtn);
                fileItem.appendChild(actionsDiv);
            }
        }
        
        // Download document function
        function downloadDocument(fileName, modified = false) {
            if (!uploadedDocuments[fileName]) return;
            
            const content = modified ? uploadedDocuments[fileName].modified : uploadedDocuments[fileName].original;
            if (!content) return;
            
            const element = document.createElement('a');
            
            if (content.startsWith('data:')) {
                element.href = content;
            } else {
                const blob = new Blob([content], {type: 'text/plain'});
                element.href = URL.createObjectURL(blob);
            }
            
            if (modified) {
                const parts = fileName.split('.');
                const ext = parts.pop();
                element.download = `${parts.join('.')}-modified.${ext}`;
            } else {
                element.download = fileName;
            }
            
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }
        
        // Intercept send message to handle document modification requests
        const originalSendMessage = window.sendMessage || function(){};
        window.sendMessage = function() {
            const messageInput = document.getElementById("messageInput");
            const message = messageInput.value.trim();
            
            if (message) {
                appendMessage("user", message);
                messageInput.value = "";
                
                // Check if this is a modification request
                if (message.toLowerCase().includes('implement') || 
                    message.toLowerCase().includes('modify') || 
                    message.toLowerCase().includes('change') || 
                    message.toLowerCase().includes('update') || 
                    message.toLowerCase().includes('fix')) {
                    
                    // Get the most recent document
                    const docs = Object.keys(uploadedDocuments);
                    if (docs.length > 0) {
                        const fileName = docs[docs.length - 1];
                        
                        // Show loading
                        showTypingIndicator();
                        
                        setTimeout(() => {
                            hideTypingIndicator();
                            
                            // Create modified version
                            const original = uploadedDocuments[fileName].original;
                            if (typeof original === 'string') {
                                // Make basic modifications for text files
                                const modified = original
                                    .replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/g, (m, p1, p2, p3) => {
                                        return `${p1.padStart(2, '0')}/${p2.padStart(2, '0')}/${p3.length === 2 ? '20' + p3 : p3}`;
                                    })
                                    .replace(/(?:^|\s)i(?=\s|$)/g, ' I');
                                
                                // Store modified version
                                uploadedDocuments[fileName].modified = modified;
                                
                                // Show success message
                                appendMessage("bot", ` Changes accepted! You can now download the modified version of "${fileName}".`);
                                
                                // Show modified download button
                                const modBtn = document.getElementById(`mod-btn-${fileName.replace(/[^a-zA-Z0-9]/g, '')}`);
                                if (modBtn) {
                                    modBtn.style.display = 'flex';
                                }
                            }
                        }, 2000);
                        
                        return;
                    }
                }
                
                // Continue with original sending behavior
                if (typeof originalSendMessage === 'function') {
                    originalSendMessage();
                }
            }
        };

        // PDF Processing
        async function extractTextFromPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let fullText = '';
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items
                    .map(item => item.str)
                    .join(' ');
                fullText += pageText + '\n\n';
            }
            
            return fullText;
        }

        // Image Processing with improved OCR
        async function extractTextFromImage(file) {
            // Show progress in chat
            const progressMessage = addMessage('bot', 'Processing image... This might take a moment.');
            
            try {
                // Configure Tesseract with better options
                const worker = await Tesseract.createWorker({
                    logger: progress => {
                        // Update progress message
                        if (progress.status === 'recognizing text') {
                            progressMessage.textContent = `Processing image... ${Math.round(progress.progress * 100)}%`;
                        }
                    }
                });

                // Set language and improve recognition
                await worker.loadLanguage('eng');
                await worker.initialize('eng');
                await worker.setParameters({
                    tessedit_ocr_engine_mode: Tesseract.PSM.AUTO_OSD,
                    preserve_interword_spaces: '1',
                });

                // Perform OCR
                const result = await worker.recognize(file);
                await worker.terminate();

                // Remove progress message
                progressMessage.remove();
                
                return result.data.text;
            } catch (error) {
                throw new Error('OCR processing failed: ' + error.message);
            }
        }

        // TXT file processing
        async function extractTextFromTXT(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error('Failed to read text file'));
                reader.readAsText(file);
            });
        }

        // DOCX file processing
        async function extractTextFromDOCX(file) {
            // Note: This is a placeholder. For actual DOCX processing,
            // you would need to include mammoth.js or similar library
            throw new Error('DOCX processing not implemented');
        }

        // UI Feedback Functions
        function showProcessingIndicator(fileName) {
            const processingDiv = document.createElement('div');
            processingDiv.id = 'processingIndicator';
            processingDiv.className = 'processing-indicator';
            processingDiv.innerHTML = `
                <div class="processing-spinner"></div>
                <div class="processing-text">
                    <span>Processing ${fileName}</span>
                    <div class="processing-dots">
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                </div>
            `;
            document.body.appendChild(processingDiv);
        }

        function hideProcessingIndicator() {
            const indicator = document.getElementById('processingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        function showDocumentPreview(fileName, text) {
            const preview = document.createElement('div');
            preview.className = 'document-preview';
            preview.innerHTML = `
                <div class="preview-header">
                    <i class="fas fa-file-alt"></i>
                    <span>${fileName}</span>
                </div>
                <div class="preview-content">
                    <pre>${text.substring(0, 200)}${text.length > 200 ? '...' : ''}</pre>
                </div>
            `;
            
            const previewsContainer = document.getElementById('documentPreviews');
            previewsContainer.appendChild(preview);
        }
    </script>

    <!-- Add processing indicator styles -->
    <style>
        .processing-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--light-surface);
            padding: 20px;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--box-shadow);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1000;
        }

        body.dark-mode .processing-indicator {
            background: var(--dark-surface);
            box-shadow: var(--dark-box-shadow);
        }

        .processing-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid var(--primary-color);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .processing-text {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .processing-dots {
            display: flex;
            gap: 4px;
        }

        .processing-dots .dot {
            width: 4px;
            height: 4px;
            background: var(--primary-color);
            border-radius: 50%;
            animation: dot-pulse 1.5s infinite;
        }

        .processing-dots .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .processing-dots .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes dot-pulse {
            0%, 100% {
                opacity: 0.2;
            }
            50% {
                opacity: 1;
            }
        }

        .document-preview {
            background: var(--light-surface);
            border: 1px solid var(--light-border);
            border-radius: var(--border-radius-md);
            margin-bottom: 10px;
            overflow: hidden;
        }

        body.dark-mode .document-preview {
            background: var(--dark-surface);
            border-color: var(--dark-border);
        }

        .preview-header {
            padding: 10px;
            background: rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .preview-content {
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .preview-content pre {
            margin: 0;
            white-space: pre-wrap;
            font-size: 0.9em;
            font-family: monospace;
        }
    </style>

    <!-- Add drag and drop zone -->
    <div class="drag-drop-overlay" id="dragDropOverlay">
        <div class="drag-drop-content">
            <div class="drag-drop-icon">
                <i class="fas fa-cloud-upload-alt"></i>
            </div>
            <h3>Drop your files here</h3>
            <p>PDF, Images, or Text files</p>
        </div>
    </div>

    <style>
        /* Drag and Drop Styles */
        .drag-drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 123, 255, 0.15);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .drag-drop-overlay.active {
            display: flex;
            opacity: 1;
        }

        .drag-drop-content {
            background: var(--light-surface);
            padding: 40px;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--box-shadow);
            text-align: center;
            transform: translateY(20px);
            transition: transform 0.3s ease;
            border: 3px dashed var(--primary-color);
        }

        body.dark-mode .drag-drop-content {
            background: var(--dark-surface);
            box-shadow: var(--dark-box-shadow);
        }

        .drag-drop-overlay.active .drag-drop-content {
            transform: translateY(0);
        }

        .drag-drop-icon {
            font-size: 48px;
            color: var(--primary-color);
            margin-bottom: 20px;
            animation: float 2s ease-in-out infinite;
        }

        .drag-drop-content h3 {
            margin: 0 0 10px;
            color: var(--primary-color);
        }

        .drag-drop-content p {
            margin: 0;
            color: #666;
        }

        body.dark-mode .drag-drop-content p {
            color: #aaa;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        /* File Upload Animation */
        .file-upload-animation {
            position: fixed;
            width: 40px;
            height: 40px;
            background: var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            pointer-events: none;
            z-index: 9999;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
    </style>

    <script>
        // Drag and Drop Functionality
        document.addEventListener('DOMContentLoaded', function() {
            const dropOverlay = document.getElementById('dragDropOverlay');
            const chatBox = document.getElementById('chatBox');

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            // Handle drag enter
            document.body.addEventListener('dragenter', function(e) {
                if (e.dataTransfer.types.includes('Files')) {
                    dropOverlay.classList.add('active');
                }
            });

            // Handle drag leave
            dropOverlay.addEventListener('dragleave', function(e) {
                if (e.target === dropOverlay) {
                    dropOverlay.classList.remove('active');
                }
            });

            // Handle drop
            dropOverlay.addEventListener('drop', async function(e) {
                dropOverlay.classList.remove('active');
                const files = Array.from(e.dataTransfer.files);
                
                for (const file of files) {
                    // Create upload animation
                    const animation = createUploadAnimation(e.clientX, e.clientY);
                    
                    try {
                        // Show preview first
                        previewFile({ target: { files: [file] } });
                        
                        // Then process the document
                        await processDocument(file);
                        completeUploadAnimation(animation, true);
                    } catch (error) {
                        completeUploadAnimation(animation, false);
                        console.error('Error processing file:', error);
                        showNotification(`Error processing ${file.name}`, "error");
                    }
                }
            });

            // Upload Animation Functions
            function createUploadAnimation(startX, startY) {
                const animation = document.createElement('div');
                animation.className = 'file-upload-animation';
                animation.innerHTML = '<i class="fas fa-file"></i>';
                animation.style.left = startX + 'px';
                animation.style.top = startY + 'px';
                document.body.appendChild(animation);

                // Animate to chat input
                requestAnimationFrame(() => {
                    const chatInput = document.querySelector('.chat-input');
                    const inputRect = chatInput.getBoundingClientRect();
                    animation.style.left = (inputRect.left + inputRect.width - 50) + 'px';
                    animation.style.top = (inputRect.top + inputRect.height/2) + 'px';
                });

                return animation;
            }

            function completeUploadAnimation(animation, success) {
                // Change icon based on success/failure
                animation.innerHTML = `<i class="fas fa-${success ? 'check' : 'times'}"></i>`;
                animation.style.background = success ? 'var(--success-color)' : 'var(--danger-color)';

                // Fade out and remove
                setTimeout(() => {
                    animation.style.opacity = '0';
                    setTimeout(() => animation.remove(), 300);
                }, 500);
            }
        });
    </script>

    <!-- Add styles for the selected model info -->
    <style>
        .selected-model-info {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #666;
            padding-left: 2px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .selected-model-info.hidden {
            display: none;
        }
        
        .model-label {
            font-weight: 500;
        }
        
        #selectedModelName {
            color: var(--primary-color);
            font-weight: 500;
        }
        
        /* Style for active model in dropdown */
        .model-link.active-model {
            background-color: rgba(0, 123, 255, 0.1);
        }
        
        body.dark-mode .model-link.active-model {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .selected-model-info {
            color: #aaa;
        }
    </style>

    <!-- Add this style to ensure model names appear on one line -->
    <style>
        .models-menu {
            min-width: 240px; /* Increase minimum width to fit longer model names */
        }

        .models-menu .model-link {
            display: flex;
            align-items: center;
            white-space: nowrap; /* Prevent line breaks in model names */
        }

        .models-menu .model-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>

    <style>
        .thinking-animation-container {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(245,247,250,0.9));
            backdrop-filter: blur(8px);
            border-radius: 16px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(235,235,235,0.5);
            max-width: 90%;
        }

        body.dark-mode .thinking-animation-container {
            background: linear-gradient(135deg, rgba(40,44,52,0.95), rgba(30,34,42,0.9));
            border: 1px solid rgba(60,60,60,0.5);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .thinking-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 16px;
        }

        .thinking-logo {
            width: 38px;
            height: 38px;
            border-radius: 12px;
            background: linear-gradient(135deg, #0062e6, #33a6ff);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,98,230,0.3);
        }

        body.dark-mode .thinking-logo {
            box-shadow: 0 4px 15px rgba(0,98,230,0.5);
        }

        .thinking-status {
            flex: 1;
        }

        .thinking-title {
            font-weight: 600;
            font-size: 16px;
            color: #1a1a1a;
            margin-bottom: 5px;
        }

        body.dark-mode .thinking-title {
            color: #f0f0f0;
        }

        .thinking-subtitle {
            font-size: 13px;
            color: #666;
            display: flex;
            align-items: center;
        }

        body.dark-mode .thinking-subtitle {
            color: #aaa;
        }

        .thinking-pulse {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }

        .thinking-pulse-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: #0062e6;
            animation: pulseDot 1.5s infinite;
        }

        .thinking-pulse-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-pulse-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulseDot {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.8); opacity: 1; }
        }

        .thinking-process {
            margin-top: 15px;
        }

        .thinking-bar {
            height: 4px;
            background-color: #eaecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        body.dark-mode .thinking-bar {
            background-color: #3a3a3a;
        }

        .thinking-progress {
            height: 100%;
            width: 30%;
            background: linear-gradient(90deg, #0062e6, #33a6ff);
            border-radius: 4px;
            animation: progressBar 2.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(0,98,230,0.5);
        }

        body.dark-mode .thinking-progress {
            box-shadow: 0 0 10px rgba(0,98,230,0.7);
        }

        @keyframes progressBar {
            0% { width: 0%; opacity: 0.8; }
            25% { width: 35%; opacity: 1; }
            50% { width: 70%; opacity: 0.8; }
            75% { width: 85%; opacity: 1; }
            90% { width: 90%; opacity: 0.8; }
            100% { width: 100%; opacity: 0; }
        }

        .thinking-steps {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .thinking-step {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            opacity: 0;
            transform: translateY(10px);
            animation-fill-mode: forwards;
            color: #333;
        }

        body.dark-mode .thinking-step {
            color: #ddd;
        }

        .thinking-step-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: rgba(0,98,230,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0062e6;
        }

        body.dark-mode .thinking-step-icon {
            background-color: rgba(0,98,230,0.2);
        }

        .thinking-step.active {
            animation: fadeInStep 0.5s ease forwards;
        }

        @keyframes fadeInStep {
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>

<body>
    <div class="dashboard">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <div class="chat-header">
                <h1><i class="fas fa-scale-balanced"></i> LegalMind</h1>
            </div>

            <div id="currentChat"
                style="margin-bottom: var(--spacing-md); font-weight: 500; font-size: 0.9rem; color: #6c757d;">
                <span>Current Chat:</span> <span id="currentChatName">None</span>
            </div>

            <button class="new-chat" onclick="addNewChat()">
                <i class="fas fa-plus"></i> New Chat
            </button>

            <ul class="chat-list" id="chatList"></ul>

            <div class="documents-preview">
                <h3><i class="fas fa-file-alt"></i> Documents</h3>
                <div id="documentPreviews"></div>
                <button class="documents-toggle" id="documentsToggle">
                    <i class="fas fa-chevron-up"></i>
                </button>
            </div>
        </div>

        <!-- Chat Section -->
        <div class="chat-section">
            <!-- Navigation Bar -->
            <div class="chat-nav">
                <div class="nav-left">
                    <button class="menu-toggle" id="mobileMenuToggle" aria-label="Open menu">
                        <i class="fas fa-bars"></i>
                    </button>
                    <div class="model-dropdown">
                        <a href="#" onclick="toggleLogoDropdown(event)" class="nav-brand-link">
                        <span class="nav-brand">LegalMind</span>
                            <i class="fas fa-chevron-down"></i>
                        </a>
                        <div class="dropdown-content models-menu" id="logoDropdown">
                            <div class="dropdown-header">Model Selection</div>
                            <a href="#" onclick="selectModel('abbasgamer1', 'Legalmind(Abbasgamer1 5 B)')" class="model-link">
                                <span class="model-star"></span>
                                <span class="model-name">Legalmind(Abbasgamer1 5 B)</span>
                            </a>
                            <a href="#" onclick="selectModel('gemini-pro', 'Legalmind(Google Gemini Pro)')" class="model-link">
                                <span class="model-star"></span>
                                <span class="model-name">Legalmind(Google Gemini Pro)</span>
                            </a>
                            <a href="#" onclick="selectModel('mistral', 'Legalmind(Mistral 7 B)')" class="model-link">
                                <span class="model-star"></span>
                                <span class="model-name">Legalmind(Mistral 7 B)</span>
                            </a>
                            <div class="dropdown-divider"></div>
                            <a href="plans.html" class="upgrade-link">
                                <span>Upgrade to Premium</span>
                            </a>
                        </div>
                    </div>
                    <!-- Add selected model info display -->
                    <div id="selectedModelInfo" class="selected-model-info hidden">
                        <span class="model-label">Model selected:</span>
                        <span id="selectedModelName">Default</span>
                    </div>
                </div>

                <div class="nav-right">
                    <div class="nav-links">
                        <a href="services.html">
                            <i class="fas fa-cogs"></i> Services
                        </a>
                        
                        <a href="plans.html">
                            <i class="fas fa-crown"></i> Premium Plans
                        </a>

                        <a href="contact.html">
                            <i class="fas fa-envelope"></i> Contact Us
                        </a>
                    </div>

                    <div class="nav-profile">
                        <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile" id="profilePicNav" 
                             onclick="(function(e) { 
                                e.preventDefault(); 
                                e.stopPropagation(); 
                                var menu = document.getElementById('profileMenu'); 
                                var mainMenu = document.getElementById('profileMainMenu');
                                var settingsPanel = document.getElementById('settingsPanel');
                                if(menu.style.display === 'flex') { 
                                    menu.style.display = 'none'; 
                                } else { 
                                    menu.style.display = 'flex'; 
                                    menu.style.flexDirection = 'column';
                                    // Make sure main menu is visible and settings panel is hidden
                                    if(mainMenu) mainMenu.style.display = 'flex';
                                    if(settingsPanel) settingsPanel.classList.remove('active');
                                }
                             })(event);" />
                        <div class="profile-menu" id="profileMenu">
                            <div class="profile-menu-header">
                                <span class="user-name" id="profileUserName">User Name</span>
                                <span class="user-plan">Subscription: Basic</span>
                            </div>

                            <div class="profile-menu-actions" id="profileMainMenu">
                                <button class="profile-menu-btn" id="settingsButton" 
                                  onclick="(function(e) {
                                    e.preventDefault();
                                    var profileMainMenu = document.getElementById('profileMainMenu');
                                    var settingsPanel = document.getElementById('settingsPanel');
                                    if(profileMainMenu) profileMainMenu.style.display = 'none';
                                    if(settingsPanel) settingsPanel.classList.add('active');
                                  })(event);">
                                    <i class="fas fa-cog"></i> Settings
                                </button>
                                <button class="profile-menu-btn logout" id="logoutButton">
                                    <i class="fas fa-sign-out-alt"></i> Logout
                                </button>
                            </div>

                            <div class="settings-panel" id="settingsPanel">
                                <button class="back-to-menu" id="backToMenu"
                                  onclick="(function(e) {
                                    e.preventDefault();
                                    var profileMainMenu = document.getElementById('profileMainMenu');
                                    var settingsPanel = document.getElementById('settingsPanel');
                                    if(profileMainMenu) profileMainMenu.style.display = 'flex';
                                    if(settingsPanel) settingsPanel.classList.remove('active');
                                  })(event);">
                                    <i class="fas fa-arrow-left"></i> Back
                                </button>

                                <div class="settings-section">
                                    <div class="settings-section-header">
                                        <i class="fas fa-moon"></i> Appearance
                                    </div>
                                    <label class="switch">
                                        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
                                        <span>Dark Mode</span>
                                    </label>
                                </div>

                                <div class="settings-section">
                                    <div class="settings-section-header">
                                        <i class="fas fa-user"></i> Profile Picture
                                    </div>
                                    <div class="profile-pic-upload">
                                        <div class="profile-preview">
                                            <img src="https://ui-avatars.com/api/?name=User&background=random" alt="Profile Preview" id="profilePreview">
                                        </div>
                                        <label for="uploadProfile" class="upload-btn">
                                            <i class="fas fa-upload"></i> Choose File
                                        </label>
                                        <input type="file" id="uploadProfile" onchange="uploadProfilePicture(event)" accept="image/*" style="display: none;">
                                        <p id="uploadedFileName" class="file-name"></p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mobile Menu -->
            <div class="mobile-menu-overlay" id="mobileMenuOverlay"></div>
            <div class="mobile-menu" id="mobileMenu">
                <div class="mobile-menu-header">
                    <img src="https://ui-avatars.com/api/?name=Legal&background=0D8ABC&color=fff" width="30" height="30" alt="Logo" style="border-radius: 50%;">
                    <h1>LegalMind</h1>
                </div>
                <div class="mobile-menu-content">
                    <button class="mobile-menu-btn new-chat-btn" onclick="addNewChat(); closeMobileMenu();">
                        <i class="fas fa-plus"></i>
                        <span>New chat</span>
                    </button>

                    <div class="mobile-section-header">Today</div>
                    <div id="mobileTodayChats">
                        <!-- Today's chats will be populated here -->
                    </div>

                    <div class="mobile-section-header">Previous days</div>
                    <div id="mobilePreviousChats">
                        <!-- Previous chats will be populated here -->
                    </div>

                    <div class="mobile-section-header">Features</div>
                    <button class="mobile-menu-btn" onclick="toggleDocumentPreview(); closeMobileMenu();">
                        <i class="fas fa-file-alt"></i>
                        <span>Document Preview</span>
                    </button>
                    <button class="mobile-menu-btn" onclick="window.location.href='contact.html'">
                        <i class="fas fa-envelope"></i>
                        <span>Contact Us</span>
                    </button>
                </div>
            </div>

            <!-- Chat Box -->
            <div class="chat-box" id="chatBox">
                <div class="welcome-message">
                    <h2>Welcome to LegalMind</h2>
                    <p>Streamline your legal work with intelligent analysis, contract review, and expert guidance at your fingertips.</p>
                </div>
                <button class="scroll-bottom-btn" id="scrollBottomBtn" aria-label="Scroll to bottom">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>

            <!-- Chat Input -->
            <div class="chat-input">
                <div class="input-container">
                    <button class="attachment-btn" onclick="document.getElementById('fileInput').click()">
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <input type="file" id="fileInput" style="display: none" onchange="previewFile(event)">
                    
                    <div class="message-input-wrapper">
                        <textarea 
                            id="messageInput" 
                            placeholder="Type a message..." 
                            rows="1" 
                            onkeydown="if(event.keyCode == 13 && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
                            oninput="autoResize(this)">
                        </textarea>
                    </div>
                    
                    <button id="sendBtn" onclick="sendMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="auth.js" type="module"></script>
    <script>
        // Global storage for chat conversations and documents
        let chats = {};
        let currentChatId = null;
        let uploadedDocuments = {}; // Store document content by filename

        // Add conversation history storage
        const conversationHistory = {};

        // Model configuration
        const modelConfig = {
            legalMind: {
                name: "LegalMind",
                // Original endpoint is scaled to zero due to inactivity
                endpoints: [
                    "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2",
                    "https://api-inference.huggingface.co/models/google/gemini-pro",
                    "https://evktndrzhfjk0kzf.us-east-1.aws.endpoints.huggingface.cloud",
                    "https://api-inference.huggingface.co/models/Abbasgamer1/legalMind"
                    // Hidden fallback
                ],
                // Multiple API tokens to try as alternatives
                authTokens: [
                    "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",  // legalmindapi - WRITE
                    "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"   // Current token
                ],
                // Track which endpoint and token is currently being used
                currentEndpointIndex: 0,
                currentTokenIndex: 0,
                // Flag to indicate we're using the fallback model
                usingFallbackModel: false
            },
            // Add more models here if needed
        };

        // Current active model
        let activeModel = "legalMind";

        // Function to show a notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;

            // Add to body
            document.body.appendChild(notification);

            // Show with animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 3000);
            }, 6000);
        }

        // Function to set the active model
        function setActiveModel(modelKey) {
            if (modelConfig[modelKey]) {
                const previousModel = activeModel;
                activeModel = modelKey;

                // Update UI to indicate the active model
                const modelDropdown = document.getElementById("modelsDropdown");
                if (modelDropdown) {
                    const menuItems = modelDropdown.querySelectorAll('a');
                    menuItems.forEach(item => {
                        if (item.getAttribute('data-model') === modelKey) {
                            item.classList.add('active-model');
                        } else {
                            item.classList.remove('active-model');
                        }
                    });
                }

                // Update the model name in the dropdown header
                const currentModelDisplay = document.getElementById("currentModelDisplay");
                if (currentModelDisplay) {
                    currentModelDisplay.textContent = modelConfig[modelKey].name;
                }

                // Update the welcome message model name
                const welcomeModelName = document.getElementById("welcomeModelName");
                if (welcomeModelName) {
                    welcomeModelName.textContent = modelConfig[modelKey].name;
                }

                // Show notification if the model actually changed
                if (previousModel !== modelKey) {
                    showNotification(`Model changed to ${modelConfig[modelKey].name}`, 'success');
                }

                return true;
            }
            return false;
        }

        // Initialize dark mode from preferences
        document.addEventListener('DOMContentLoaded', function () {
            // Check for saved dark mode preference
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').checked = true;
                if (document.getElementById('darkModeIcon')) {
                    document.getElementById('darkModeIcon').classList.remove('fa-moon');
                    document.getElementById('darkModeIcon').classList.add('fa-sun');
                    document.getElementById('darkModeText').textContent = 'Light Mode';
                }
            }

            // Create a new chat if none exists
            if (!currentChatId) {
                // Check if there are any existing chats in the list
                const chatList = document.getElementById("chatList");
                if (chatList && chatList.children.length === 0) {
                    // If no chats exist, create a new one
                    addNewChat();
                } else if (chatList && chatList.children.length > 0) {
                    // If chats exist but none is selected, select the first one
                    const firstChat = chatList.children[0];
                    const chatId = firstChat.getAttribute("data-chat-id");
                    if (chatId) {
                        firstChat.classList.add('active');
                        loadChat(chatId);
                    }
                }
            }

            // Mobile menu handlers
            document.getElementById('mobileMenuToggle').addEventListener('click', function () {
                document.getElementById('mobileMenu').classList.add('active');
                document.getElementById('mobileMenuOverlay').classList.add('active');
                updateMobileChats();
            });

            document.getElementById('mobileMenuOverlay').addEventListener('click', closeMobileMenu);

            // Check screen width and adapt layout
            function checkScreenWidth() {
                const sidebar = document.querySelector('.sidebar');
                if (window.innerWidth <= 992 && sidebar) {
                    if (!sidebar.classList.contains('collapsed')) {
                        sidebar.classList.add('collapsed');
                    }
                }
            }

            // Initial check
            checkScreenWidth();

            // Listen for window resize
            window.addEventListener('resize', checkScreenWidth);

            // Fix mobile scrolling issues for chat box
            const chatBox = document.getElementById('chatBox');
            if (chatBox) {
                window.addEventListener('resize', function () {
                    if (window.innerWidth <= 992) {
                        chatBox.scrollTop = chatBox.scrollHeight;
                    }
                });

                // Handle welcome message visibility on scroll
                const welcomeMessage = document.querySelector('.welcome-message');

                if (welcomeMessage) {
                    // Show welcome message initially
                    welcomeMessage.classList.remove('hidden');

                    // Check on scroll
                    chatBox.addEventListener('scroll', function () {
                        if (chatBox.scrollTop > 10) {
                            welcomeMessage.classList.add('hidden');
                        } else {
                            welcomeMessage.classList.remove('hidden');
                        }
                    });
                }
            }

            // Make document preview fully visible on page load with enhanced visibility
            const previewSection = document.querySelector('.documents-preview');
            if (previewSection) {
                previewSection.style.display = 'block';
                previewSection.style.visibility = 'visible';
                previewSection.style.opacity = '1';
                previewSection.style.zIndex = '5';

                // Initialize preview area
                const documentPreviews = document.getElementById('documentPreviews');
                if (documentPreviews && documentPreviews.children.length === 0) {
                    const welcomeText = document.createElement('p');
                    welcomeText.className = 'empty-preview-message';
                    welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
                    documentPreviews.appendChild(welcomeText);
                }
            }

            // Simplified documents toggle functionality with forced visibility
            const documentsToggle = document.getElementById('documentsToggle');
            const documentPreviews = document.getElementById('documentPreviews');

            if (documentsToggle && documentPreviews) {
                // Make sure it starts visible
                documentPreviews.style.display = 'block';

                documentsToggle.addEventListener('click', function () {
                    if (documentPreviews.style.display === 'none') {
                        documentPreviews.style.display = 'block';
                        this.querySelector('i').classList.remove('fa-chevron-down');
                        this.querySelector('i').classList.add('fa-chevron-up');
                    } else {
                        documentPreviews.style.display = 'none';
                        this.querySelector('i').classList.remove('fa-chevron-up');
                        this.querySelector('i').classList.add('fa-chevron-down');
                    }
                });
            }

            // Add mobile menu button to toggle document visibility
            document.getElementById('toggleSidebarBtn').addEventListener('click', function () {
                toggleSidebar();
                document.getElementById('mobileMenu').classList.remove('active');
            });

            // Run immediately to warm up all endpoints as soon as page loads
            document.addEventListener('DOMContentLoaded', function() {
                console.log("Starting immediate endpoint warmup...");
                
                // Function to warm up all endpoints in sequence
                function warmupAllEndpoints(endpointIndex = 0) {
                    // Get the model configuration
                    const model = modelConfig.legalMind;
                    
                    // Check if endpointIndex is valid
                    if (endpointIndex >= model.endpoints.length) {
                        console.log("All endpoints have been warmed up!");
                        return;
                    }
                    
                    const endpoint = model.endpoints[endpointIndex];
                    const token = model.authTokens[0]; // Use first token for consistency
                    
                    console.log(`Warming up endpoint ${endpointIndex}: ${endpoint}`);
                    
                    // Make a minimal request to wake up the endpoint
                    fetch(endpoint, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${token}`
                        },
                        body: JSON.stringify({
                            inputs: "Hello",
                            parameters: {
                                max_new_tokens: 5,
                                temperature: 0.7,
                                do_sample: true,
                                return_full_text: false
                            }
                        })
                    })
                    .then(response => {
                        if (response.ok) {
                            console.log(`Endpoint ${endpointIndex} warmed up successfully!`);
                            showNotification(`Model ${endpointIndex+1} is ready`, "success");
                        } else {
                            console.log(`Endpoint ${endpointIndex} warming status: ${response.status}`);
                            if (response.status === 503) {
                                // Try again later if scaled to zero
                                setTimeout(() => warmupAllEndpoints(endpointIndex), 5000);
                                return;
                            }
                        }
                        
                        // Proceed to next endpoint
                        setTimeout(() => warmupAllEndpoints(endpointIndex + 1), 1000);
                    })
                    .catch(error => {
                        console.error(`Error warming up endpoint ${endpointIndex}:`, error);
                        // Continue to next endpoint
                        setTimeout(() => warmupAllEndpoints(endpointIndex + 1), 1000);
                    });
                }
                
                // Start warming up endpoints immediately
                warmupAllEndpoints(0);
            });
        });

        function addNewChat() {
            const chatList = document.getElementById("chatList");
            const chatId = "chat_" + Date.now();
            const chatName = "Chat " + (chatList.children.length + 1);

            // Initialize conversation history for new chat
            conversationHistory[chatId] = [];

            const chatItem = document.createElement("li");
            chatItem.setAttribute("data-chat-id", chatId);
            chatItem.innerHTML = `
        <span>${chatName}</span>
        <button class="delete-chat" onclick="deleteChat(event, this)" aria-label="Delete chat">
          <i class="fas fa-times"></i>
        </button>
      `;

            chatItem.addEventListener("click", function (e) {
                if (e.target.classList.contains("delete-chat") || e.target.closest('.delete-chat')) return;

                document.querySelectorAll('#chatList li').forEach(item => {
                    item.classList.remove('active');
                });

                this.classList.add('active');
                loadChat(chatId, chatName);

                // On mobile, collapse sidebar after selecting chat
                if (window.innerWidth <= 992) {
                    document.querySelector('.sidebar').classList.add('collapsed');
                }
            });

            chatList.appendChild(chatItem);
            chats[chatId] = [];
            loadChat(chatId, chatName);

            // Show the chat list after creating new chat
            const sidebar = document.querySelector('.sidebar');
            if (sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
            }

            // Update mobile menu after adding new chat
            setTimeout(updateMobileChats, 100);

            // Add initial welcome message
            setTimeout(() => {
                if (currentChatId === chatId) {
                    appendMessage("bot", " Welcome to LegalMind! I'm your AI legal assistant.\n\nI can help with legal document analysis, terminology questions, contract improvements, and general legal information.\n\nI'm designed to analyze complex legal language, identify key clauses, and provide insights into legal documents of various types.\n\nI can also help draft responses, suggest improvements to contracts, and explain legal concepts in plain language.\n\nUpload a document  or ask me a question.\n\nPopular questions you might ask:\n \"What should I include in an NDA?\"\n \"Explain force majeure clauses\"\n \"What's the difference between arbitration and litigation?\"\n \"Review this employment contract for potential issues\"\n \"Summarize the key points of this legal agreement\"");
                }
            }, 300);
        }

        // Automatically trigger a bot welcome message
        setTimeout(() => {
            if (currentChatId === chatId) {
                // Automatically trigger a welcome response
                const greetingResponse = getGreetingResponse();
                appendMessage("bot", greetingResponse);

                // Store in conversation history
                if (!conversationHistory[chatId]) {
                    conversationHistory[chatId] = [];
                }
                conversationHistory[chatId].push({
                    role: "assistant",
                    content: greetingResponse
                });
            }
        }, 300);

        function loadChat(chatId) {
            // Clear any existing thinking animations from previous chat
            clearThinkingAnimations();
            
            // Set current chat
            currentChatId = chatId;

            // Clear chat box
            const chatBox = document.getElementById("chatBox");
            chatBox.innerHTML = '';

            // Add welcome message at the top
            const welcomeMessage = document.createElement("div");
            welcomeMessage.className = "welcome-message";
            welcomeMessage.innerHTML = `
        <h2>Welcome to LegalMind</h2>
        <p>Streamline your legal work with intelligent analysis, contract review, and expert guidance at your fingertips.</p>
      `;
            chatBox.appendChild(welcomeMessage);

            // Add scroll to bottom button
            const scrollBtn = document.createElement("button");
            scrollBtn.className = "scroll-bottom-btn";
            scrollBtn.id = "scrollBottomBtn";
            scrollBtn.setAttribute("aria-label", "Scroll to bottom");
            scrollBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
            chatBox.appendChild(scrollBtn);

            // Update current chat name
            document.getElementById("currentChatName").textContent = chats[chatId]?.name || "New Chat";

            // Load messages for this chat and append them
            if (chats[chatId] && chats[chatId].messages) {
                chats[chatId].messages.forEach(msg => {
                    const msgDiv = document.createElement("div");
                    msgDiv.className = `message ${msg.sender}`;
                    
                    // Special handling for thinking messages
                    if (msg.type === "thinking") {
                        createThinkingAnimation(msgDiv);
                    } else if (msg.type === "html") {
                        msgDiv.innerHTML = msg.content;
                    } else {
                        msgDiv.textContent = msg.content;
                    }
                    
                    chatBox.appendChild(msgDiv);
                });
            }

            // Set active class for chat items
            document.querySelectorAll("#chatList li").forEach(item => {
                item.classList.remove("active");
                if (item.getAttribute("data-chat-id") === chatId) {
                    item.classList.add("active");
                }
            });

            // Setup scroll event for scroll button visibility
            chatBox.addEventListener('scroll', function() {
                const scrollBtn = document.getElementById('scrollBottomBtn');
                if (!scrollBtn) return;

                const isNearBottom = chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight < 100;
                scrollBtn.classList.toggle('visible', !isNearBottom);
            });

            // Add click handler for scroll button
            scrollBtn.addEventListener('click', () => {
                chatBox.scrollTo({
                    top: chatBox.scrollHeight,
                    behavior: 'smooth'
                });
            });
        }

        // Function to clear thinking animations
        function clearThinkingAnimations() {
            // Clear any existing thinking intervals
            const thinkingContainers = document.querySelectorAll('.thinking-container');
            thinkingContainers.forEach(container => {
                if (container.dataset.intervalId) {
                    clearInterval(parseInt(container.dataset.intervalId));
                }
            });
        }

        // Function to create thinking animation
        function createThinkingAnimation(container) {
            container.className = "message bot";
            const thinkingContainer = document.createElement("div");
            thinkingContainer.className = "thinking-container";
            
            // Add header with brain icon and status
            const thinkingHeader = document.createElement("div");
            thinkingHeader.className = "thinking-header";
            thinkingHeader.innerHTML = `
                <div class="thinking-brain-icon">
                    <i class="fas fa-brain"></i>
                </div>
                <div class="thinking-status">
                    <span>Processing your request</span>
                    <div class="thinking-progress">
                        <div class="thinking-progress-bar"></div>
                    </div>
                </div>
            `;
            
            // Add thinking steps
            const thinkingSteps = document.createElement("div");
            thinkingSteps.className = "thinking-steps";
            
            const steps = [
                { icon: 'fa-search', text: 'Analyzing your question...' },
                { icon: 'fa-database', text: 'Retrieving relevant information...' },
                { icon: 'fa-brain', text: 'Processing context...' },
                { icon: 'fa-pen', text: 'Formulating response...' }
            ];
            
            steps.forEach((step, index) => {
                const stepElement = document.createElement("div");
                stepElement.className = "thinking-step";
                stepElement.innerHTML = `
                    <i class="fas ${step.icon}"></i>
                    <span>${step.text}</span>
                `;
                
                setTimeout(() => {
                    thinkingSteps.appendChild(stepElement);
                    setTimeout(() => stepElement.classList.add('active'), 50);
                }, index * 1000);
            });
            
            thinkingContainer.appendChild(thinkingHeader);
            thinkingContainer.appendChild(thinkingSteps);
            container.appendChild(thinkingContainer);
        }

        function deleteChat(event, button) {
            event.stopPropagation();
            const chatItem = button.closest('li');
            const chatId = chatItem.getAttribute("data-chat-id");

            // Clean up conversation history
            if (conversationHistory[chatId]) {
                delete conversationHistory[chatId];
            }

            if (chats[chatId]) {
                delete chats[chatId];
            }
            chatItem.remove();

            if (currentChatId === chatId) {
                currentChatId = null;
                const chatBox = document.getElementById("chatBox");
                const welcomeMessage = document.querySelector('.welcome-message');

                if (welcomeMessage) {
                    chatBox.innerHTML = '';
                    welcomeMessage.classList.remove('hidden');
                    chatBox.appendChild(welcomeMessage);
                } else {
                    chatBox.innerHTML = '';
                }

                document.getElementById("currentChatName").textContent = "None";
            }

            // Update mobile menu after deleting chat
            setTimeout(updateMobileChats, 100);
        }

        // Improved appendMessage function with less intrusive scrolling
        window.appendMessage = function (sender, text) {
            const chatBox = document.getElementById('chatBox');
            if (!chatBox) return;

            const msgDiv = document.createElement("div");
            msgDiv.textContent = text;
            msgDiv.classList.add("message", sender);

            // Check if we're at the bottom before adding the message
            const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;

            // Append the message
            chatBox.appendChild(msgDiv);

            // Only auto-scroll if we were already at the bottom
            if (wasAtBottom) {
                // Use requestAnimationFrame for smoother scrolling
                requestAnimationFrame(() => {
                    chatBox.scrollTo({
                        top: chatBox.scrollHeight,
                        behavior: 'smooth'
                    });
                });
            } else {
                // Show scroll button if we're not at the bottom
                const scrollButton = document.getElementById('scrollBottomBtn');
                if (scrollButton) {
                    scrollButton.classList.add('visible');
                }
            }

            // Store in current chat if available
            if (currentChatId && chats[currentChatId]) {
                if (!chats[currentChatId].messages) {
                    chats[currentChatId].messages = [];
                }
                chats[currentChatId].messages.push({
                    type: 'text',
                    sender: sender,
                    content: text
                });
            }
        };

        // Updated appendHtmlMessage function with smoother scrolling
        window.appendHtmlMessage = function (sender, htmlContent) {
            const chatBox = document.getElementById('chatBox');
            if (!chatBox) return;

            const msgDiv = document.createElement("div");
            msgDiv.innerHTML = htmlContent;
            msgDiv.classList.add("message", sender);

            // Special handling for thinking messages
            if (htmlContent.includes('data-thinking="true"')) {
                // Create enhanced thinking container
                const thinkingContainer = document.createElement("div");
                thinkingContainer.className = "thinking-container";

                // Add header with brain icon and status
                const thinkingHeader = document.createElement("div");
                thinkingHeader.className = "thinking-header";
                thinkingHeader.innerHTML = `
                    <div class="thinking-brain-icon">
                        <i class="fas fa-brain"></i>
                    </div>
                    <div class="thinking-status">
                        <span>Processing your request</span>
                        <div class="thinking-progress">
                            <div class="thinking-progress-bar"></div>
                        </div>
                </div>
            `;

                // Add thinking steps container
                const thinkingSteps = document.createElement("div");
                thinkingSteps.className = "thinking-steps";

                // Define thinking steps
                const steps = [
                    { icon: 'fa-search', text: 'Analyzing your question...' },
                    { icon: 'fa-database', text: 'Retrieving relevant information...' },
                    { icon: 'fa-brain', text: 'Processing context...' },
                    { icon: 'fa-pen', text: 'Formulating response...' }
                ];

                // Add steps with delayed appearance
                steps.forEach((step, index) => {
                    const stepElement = document.createElement("div");
                    stepElement.className = "thinking-step";
                    stepElement.innerHTML = `
                        <i class="fas ${step.icon}"></i>
                        <span>${step.text}</span>
                    `;

                    // Add step with delay
                    setTimeout(() => {
                        thinkingSteps.appendChild(stepElement);
                        setTimeout(() => stepElement.classList.add('active'), 50);
                    }, index * 1000);
                });

                thinkingContainer.appendChild(thinkingHeader);
                thinkingContainer.appendChild(thinkingSteps);
                msgDiv.innerHTML = '';
                msgDiv.appendChild(thinkingContainer);

                // Store the steps container reference for later cleanup
                thinkingContainer.dataset.stepsContainer = thinkingSteps;
            }

            // Check if we're at the bottom before adding the message
            const wasAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;

            // Append the message
            chatBox.appendChild(msgDiv);

            // Only auto-scroll if we were already at the bottom
            if (wasAtBottom) {
                // Use requestAnimationFrame for smoother scrolling
                requestAnimationFrame(() => {
                    chatBox.scrollTo({
                        top: chatBox.scrollHeight,
                        behavior: 'smooth'
                    });
                });
            } else {
                // Show scroll button if we're not at the bottom
                const scrollButton = document.getElementById('scrollBottomBtn');
                if (scrollButton) {
                    scrollButton.classList.add('visible');
                }
            }

            // Store in current chat if available
            if (currentChatId && chats[currentChatId]) {
                if (!chats[currentChatId].messages) {
                    chats[currentChatId].messages = [];
                }
                chats[currentChatId].messages.push({
                    type: 'html',
                    sender: sender,
                    content: htmlContent
                });
            }
        };

        // Function to check if the message is asking about chatbot identity
        function isIdentityQuestion(text) {
            const lowerText = text.toLowerCase().trim();

            // Check for common identity questions
            const identityPatterns = [
                /^who are you/,
                /^what are you/,
                /tell me about yourself/,
                /^who is legal ?mind/,
                /^what is legal ?mind/,
                /introduce yourself/,
                /your name/,
                /^who created you/,
                /^who made you/,
                /^who is your owner/,
                /^what do you do/,
                /^what can you do/
            ];

            return identityPatterns.some(pattern => pattern.test(lowerText));
        }

        // Function to handle identity questions
        function getIdentityResponse(text) {
            const lowerText = text.toLowerCase().trim();

            // Check if asking about creator/owner
            if (lowerText.includes("who made you") ||
                lowerText.includes("who created you") ||
                lowerText.includes("who is your owner") ||
                lowerText.includes("who developed you")) {
                return "I was created by Mohammad Suheb Abbas. You can find the project repository at https://github.com/SM-Abbas/Final-Year-Project-54";
            }

            // Default identity response
            return "I am LegalMind, an AI legal assistant that specializes in analyzing legal documents. I can help review contracts, legal agreements, and other documents, providing insights and suggestions for improvements. If you have a document you'd like me to analyze, please upload it using the paperclip icon in the chat input.";
        }

        // Function to determine if a question is a continuation of previous conversation
        function isContinuationQuestion(text, messages) {
            if (!text || !messages || messages.length < 2) return false;

            const lowerText = text.toLowerCase().trim();

            // Very short questions are often continuations
            if (lowerText.split(' ').length <= 5) {
                return true;
            }

            // Check for pronouns and continuation phrases
            const continuationPatterns = [
                /\b(it|this|that|they|them|these|those)\b/i,
                /\b(its|their|theirs)\b/i,
                /\b(why|how|what|when|where|who)\b.*\?$/i,
                /^(and|but|so|also|besides|additionally)\b/i,
                /\b(more|elaboration|clarify|explain|details)\b/i,
                /\bcan you/i,
                /\b(the|your|previous) (answer|response|explanation)\b/i
            ];

            return continuationPatterns.some(pattern => pattern.test(lowerText));
        }

        // Function to detect and filter inappropriate content related to intimacy
        function containsInappropriateContent(text) {
            if (!text) return false;

            const lowerText = text.toLowerCase().trim();

            // Define patterns for inappropriate content related to intimacy
            const inappropriatePatterns = [
                /\b(sex|sexual|sexuality|nude|naked|porn|explicit|adult content)\b/i,
                /\b(intercourse|foreplay|orgasm|climax|ejacul|penetrat)\w*\b/i,
                /\b(masturbat|genital|privates|private parts)\w*\b/i,
                /\b(erotic|erotica|69|bdsm|fetish|kink)\b/i,
                /\b(nsfw|xxx|x-rated|arousal|aroused)\b/i,
                /\b(boob|breast|tit|ass|butt|penis|vagina|dick|cock|pussy)\w*\b/i,
                /\b(fuck|fucking|fucked|anal|oral sex|blow job|hand job)\b/i,
                /\b(intimate|intimacy)\b.*\b(physical|detail|guide|how|instruct)/i,
                /\b(dirty talk|obscen|lewd|lust|horny|sensual pleasure)\b/i
            ];

            return inappropriatePatterns.some(pattern => pattern.test(lowerText));
        }

        // Improved send message function
        async function sendMessage() {
            const messageInput = document.getElementById("messageInput");
            const userMessageText = messageInput.value.trim();

            if (!userMessageText) return;

            // Reset the textarea height
            messageInput.style.height = "auto";
                messageInput.value = "";

            // Append the user message to the chat
                appendMessage("user", userMessageText);

                // Show thinking animation
                const thinkingIndicator = showThinkingAnimation();

            try {
                // Prepare context from previous messages
                let conversationContext = "";
                if (currentChatId && chats[currentChatId] && chats[currentChatId].messages) {
                    // Get the last 4 messages for context
                    const contextMessages = chats[currentChatId].messages.slice(-4);
                    
                    for (const msg of contextMessages) {
                        const role = msg.sender === "user" ? "User" : "Assistant";
                        conversationContext += `${role}: ${msg.content}\n`;
                    }
                }

                // Check for attached documents
                const attachedDocumentText = getAttachedDocumentText();
                let fullPrompt;

                // If we have attached documents, include them in the prompt
                if (attachedDocumentText) {
                    fullPrompt = `You are a legal assistant. The user has provided the following document content:\n\n${attachedDocumentText}\n\nThis is the conversation history:\n${conversationContext}\n\nUser: ${userMessageText}\n\nProvide a concise response. Focus on the legal aspects of the query. Be brief but thorough.`;
                } else {
                    // Handle different models
                    if (activeModel === "legalMind") {
                        // Get current date in readable format
                        const today = new Date();
                        const options = { year: 'numeric', month: 'long', day: 'numeric' };
                        const formattedDate = today.toLocaleDateString('en-US', options);
                        
                        // Construct prompt based on model
                        if (modelConfig.legalMind.usingFallbackModel) {
                            // Legacy prompt for the old 5B open-source model
                            fullPrompt = `You are a helpful legal assistant. Today is ${formattedDate}.\n\n${conversationContext}\n\nUser: ${userMessageText}\n\nAssistant: `;
                        } else {
                            // Gemini or Mistral prompt
                            // Check if it's an identity question
                            if (isIdentityQuestion(userMessageText)) {
                                removeThinkingAnimation(thinkingIndicator);
                                
                                appendMessage("bot", "I'm LegalMind, an AI assistant specialized in legal topics. I can help analyze legal documents, explain legal concepts, suggest improvements to legal agreements, and provide general legal information. While I aim to be helpful, please note that I'm not a licensed attorney and my responses shouldn't be considered legal advice.");
                                
                                return;
                            }
                            
                            // If this appears to be a general knowledge question, add a preface
                            if (!isLegalQuestion(userMessageText)) {
                                removeThinkingAnimation(thinkingIndicator);
                                
                                appendMessage("bot", `I'll answer your general question, but remember I specialize in legal topics.\n\n${generateConciseResponse(userMessageText)}`);
                                
                                return;
                            }

                            fullPrompt = `You are LegalMind, a specialized legal assistant powered by Google Gemini Pro. Today is ${formattedDate}.\n\n${conversationContext}\n\nUser: ${userMessageText}\nAssistant:`;
                        }
                    }
                }

                // Send the message to the API
                const response = await sendToAPI(fullPrompt);

                // Remove the thinking animation
                removeThinkingAnimation(thinkingIndicator);

                // Format the response to be more concise and add follow-up suggestions
                const formattedResponse = formatBotResponse(response, userMessageText);
                
                // Append the bot's response to the chat
                appendMessage("bot", formattedResponse);
            } catch (error) {
                console.error("Error sending message:", error);
                
                // Remove the thinking animation
                removeThinkingAnimation(thinkingIndicator);
                
                // Show error message
                appendMessage("bot", "I apologize, but I encountered an error processing your request. Please try again or ask a different question.");
            }
        }

        // Format bot responses to be more concise and add follow-up suggestions
        function formatBotResponse(response, userQuery) {
            // If response is very long, create a more concise version
            if (response.length > 500) {
                // Extract the most important parts of the response
                const sentences = response.split(/[.!?]\s+/);
                let conciseResponse = "";
                
                // Take the first 3-5 sentences for a summary
                const summaryLength = Math.min(4, Math.ceil(sentences.length / 3));
                for (let i = 0; i < summaryLength; i++) {
                    if (sentences[i] && sentences[i].trim().length > 0) {
                        conciseResponse += sentences[i] + ". ";
                    }
                }
                
                // Add a few key sentences from the middle/end if they seem important
                for (let i = summaryLength; i < sentences.length; i++) {
                    const sentence = sentences[i];
                    if (sentence && (sentence.includes("important") || 
                        sentence.includes("key") || 
                        sentence.includes("critical") || 
                        sentence.includes("essential") ||
                        sentence.includes("note that"))) {
                        conciseResponse += sentence + ". ";
                    }
                }
                
                // Generate relevant follow-up questions based on the user's query
                const followUps = generateFollowUpQuestions(userQuery, response);
                
                // Combine concise response with follow-up suggestions
                return conciseResponse + "\n\n" + followUps;
            }
            
            // For shorter responses, just add follow-up suggestions
            const followUps = generateFollowUpQuestions(userQuery, response);
            return response + "\n\n" + followUps;
        }

        // Generate follow-up questions based on the user query and bot response
        function generateFollowUpQuestions(userQuery, botResponse) {
            // Detect the type of question being asked
            const lowerQuery = userQuery.toLowerCase();
            const lowerResponse = botResponse.toLowerCase();
            
            // Prepare an array to hold potential follow-up questions
            const possibleFollowUps = [];
            
            // Contract related
            if (lowerQuery.includes("contract") || lowerQuery.includes("agreement") || lowerResponse.includes("contract") || lowerResponse.includes("agreement")) {
                possibleFollowUps.push("What are the most common pitfalls in this type of contract?");
                possibleFollowUps.push("What clauses should I pay special attention to?");
                possibleFollowUps.push("How can I negotiate better terms?");
            }
            
            // Legal concept explanation
            if (lowerQuery.includes("what is") || lowerQuery.includes("explain") || lowerQuery.includes("definition")) {
                possibleFollowUps.push("How does this apply in practical situations?");
                possibleFollowUps.push("Are there significant differences in how this is treated across jurisdictions?");
                possibleFollowUps.push("What are the latest legal developments in this area?");
            }
            
            // Document review
            if (lowerQuery.includes("review") || lowerQuery.includes("check") || lowerQuery.includes("analyze")) {
                possibleFollowUps.push("What potential risks should I be aware of?");
                possibleFollowUps.push("Are there any missing elements that should be added?");
                possibleFollowUps.push("How could this document be strengthened?");
            }
            
            // Legal procedure
            if (lowerQuery.includes("procedure") || lowerQuery.includes("process") || lowerQuery.includes("filing") || lowerQuery.includes("court")) {
                possibleFollowUps.push("What is the typical timeline for this process?");
                possibleFollowUps.push("What documentation will I need to prepare?");
                possibleFollowUps.push("What are common reasons this process might be delayed?");
            }
            
            // If no specific follow-ups generated, use generic ones
            if (possibleFollowUps.length === 0) {
                possibleFollowUps.push("Can you elaborate more on this topic?");
                possibleFollowUps.push("What practical implications does this have?");
                possibleFollowUps.push("Are there any recent legal changes I should know about?");
            }
            
            // Select up to 2 follow-up questions
            const selectedFollowUps = possibleFollowUps.slice(0, 2);
            
            return "Follow-up questions you might consider:\n " + selectedFollowUps.join("\n ");
        }

        // Check if a question is legal-related
        function isLegalQuestion(text) {
            const lowerText = text.toLowerCase();
            
            // Common legal terms to check for
            const legalTerms = [
                "legal", "law", "court", "judge", "attorney", "lawyer", "litigation",
                "contract", "agreement", "clause", "lawsuit", "plaintiff", "defendant",
                "liability", "damages", "tort", "statute", "regulation", "compliance",
                "copyright", "patent", "trademark", "intellectual property", "estate",
                "will", "trust", "probate", "divorce", "custody", "alimony", "criminal",
                "civil", "sue", "case", "precedent", "jurisdiction", "arbitra", "mediat",
                "settlement", "negotiat", "rights", "obligation", "breach", "remedy"
            ];
            
            // Check if any legal terms are present
            return legalTerms.some(term => lowerText.includes(term));
        }

        // Generate a concise response for general knowledge questions
        function generateConciseResponse(question) {
            // Simple canned responses for common general questions
            const lowerQuestion = question.toLowerCase();
            
            if (lowerQuestion.includes("weather") || lowerQuestion.includes("forecast")) {
                return "I don't have access to real-time weather data, but you can check weather forecasts on websites like Weather.com or AccuWeather.";
            }
            
            if (lowerQuestion.includes("time") && (lowerQuestion.includes("what") || lowerQuestion.includes("current"))) {
                return "I don't have access to real-time data like the current time. Your device should display that information.";
            }
            
            if (lowerQuestion.includes("news") || lowerQuestion.includes("current events")) {
                return "I don't have access to the latest news. For current events, please check reliable news sources.";
            }
            
            if (lowerQuestion.includes("who are you") || lowerQuestion.includes("what are you")) {
                return "I'm LegalMind, an AI assistant specialized in legal topics, though I can help with general questions too.";
            }
            
            return "I specialize in legal topics, but I'll try to help with your general question. Note that I don't have access to real-time data or the ability to browse the internet.";
        }

        // Toggle dark mode
        function toggleDarkMode() {
            const isDarkMode = document.body.classList.toggle("dark-mode");
            const darkModeIcon = document.getElementById('darkModeIcon');
            const darkModeText = document.getElementById('darkModeText');

            if (isDarkMode) {
                localStorage.setItem('darkMode', 'enabled');
                if (darkModeIcon) {
                    darkModeIcon.classList.remove('fa-moon');
                    darkModeIcon.classList.add('fa-sun');
                    darkModeText.textContent = 'Light Mode';
                }
            } else {
                localStorage.setItem('darkMode', 'disabled');
                if (darkModeIcon) {
                    darkModeIcon.classList.remove('fa-sun');
                    darkModeIcon.classList.add('fa-moon');
                    darkModeText.textContent = 'Dark Mode';
                }
            }
        }

        function togglePlansDropdown(event) {
            event.preventDefault();
            const dropdown = document.getElementById("plansDropdown");
            dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";
            document.getElementById("modelsDropdown").style.display = "none";
        }

        function toggleModelsDropdown(event) {
            event.preventDefault();
            const dropdown = document.getElementById("modelsDropdown");
            dropdown.style.display = (dropdown.style.display === "block") ? "none" : "block";
            document.getElementById("plansDropdown").style.display = "none";
        }

        // Profile menu toggle and settings functionality
        document.addEventListener('DOMContentLoaded', function () {
            // Check for saved dark mode preference
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').checked = true;
            }

            // Profile menu toggle - fix for both mobile and desktop
            const profilePic = document.getElementById('profilePicNav');
            const profileMenu = document.getElementById('profileMenu');

            if (profilePic && profileMenu) {
                profilePic.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    profileMenu.classList.toggle('active');
                    // Force repaint in case of rendering issues
                    profileMenu.offsetHeight;
                    // If menu is active, ensure it is displayed properly
                    if (profileMenu.classList.contains('active')) {
                        profileMenu.style.display = 'flex';
                        profileMenu.style.flexDirection = 'column';
                    }
                });
            }

            // Settings button
            const settingsButton = document.getElementById('settingsButton');
            const profileMainMenu = document.getElementById('profileMainMenu');
            const settingsPanel = document.getElementById('settingsPanel');

            if (settingsButton && profileMainMenu && settingsPanel) {
                settingsButton.addEventListener('click', function () {
                    profileMainMenu.style.display = 'none';
                    settingsPanel.classList.add('active');
                });
            }

            // Back to menu button
            const backToMenu = document.getElementById('backToMenu');
            if (backToMenu && profileMainMenu && settingsPanel) {
                backToMenu.addEventListener('click', function () {
                    profileMainMenu.style.display = 'flex';
                    settingsPanel.classList.remove('active');
                });
            }

            // Close profile menu when clicking outside
            document.addEventListener('click', function (event) {
                if (profileMenu && profileMenu.classList.contains('active')) {
                    if (!event.target.closest('.nav-profile') && !event.target.closest('.profile-menu')) {
                        profileMenu.classList.remove('active');
                        // Reset to main menu view when closing
                        if (profileMainMenu && settingsPanel) {
                            profileMainMenu.style.display = 'flex';
                            settingsPanel.classList.remove('active');
                        }
                    }
                }
            });
        });

        // Update the toggleSidebar function to properly handle document preview visibility
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const documentsPreview = document.querySelector('.documents-preview');

            if (sidebar) {
                sidebar.classList.toggle('collapsed');

                if (sidebar.classList.contains('collapsed')) {
                    if (documentsPreview) {
                        documentsPreview.style.display = 'none';
                    }
                } else {
                    if (documentsPreview) {
                        documentsPreview.style.display = 'flex';
                        const documentPreviews = document.getElementById('documentPreviews');
                        if (documentPreviews) {
                            documentPreviews.style.display = 'block';
                        }
                    }
                }
            }
        }

        function closeMobileMenu() {
            document.getElementById('mobileMenu').classList.remove('active');
            document.getElementById('mobileMenuOverlay').classList.remove('active');
        }

        function toggleDocumentPreview() {
            // For simplicity in mobile version, just toggle sidebar visibility
            const sidebar = document.querySelector('.sidebar');

            if (window.innerWidth <= 992) {
                // On mobile, show the sidebar which contains document preview
                if (sidebar.style.display === 'none' || sidebar.style.display === '') {
                    sidebar.style.display = 'flex';
                    sidebar.classList.remove('collapsed');

                    // Make sure documents preview is visible
                    const documentsPreview = document.querySelector('.documents-preview');
                    if (documentsPreview) {
                        documentsPreview.style.display = 'flex';
                        const documentPreviews = document.getElementById('documentPreviews');
                        if (documentPreviews) {
                            documentPreviews.style.display = 'block';
                        }
                    }
                } else {
                    sidebar.style.display = 'none';
                }
            } else {
                // On desktop, toggle collapsed state
                sidebar.classList.toggle('collapsed');

                if (sidebar.classList.contains('collapsed')) {
                    const documentsPreview = document.querySelector('.documents-preview');
                    if (documentsPreview) {
                        documentsPreview.style.display = 'none';
                    }
                } else {
                    const documentsPreview = document.querySelector('.documents-preview');
                    if (documentsPreview) {
                        documentsPreview.style.display = 'flex';
                        const documentPreviews = document.getElementById('documentPreviews');
                        if (documentPreviews) {
                            documentPreviews.style.display = 'block';
                        }
                    }
                }
            }

            closeMobileMenu();
        }

        // Function to update mobile chats list
        function updateMobileChats() {
            const todayContainer = document.getElementById('mobileTodayChats');
            const previousContainer = document.getElementById('mobilePreviousChats');

            if (!todayContainer || !previousContainer) return;

            todayContainer.innerHTML = '';
            previousContainer.innerHTML = '';

            const chatList = document.getElementById('chatList');
            const chatItems = chatList.querySelectorAll('li');

            chatItems.forEach((item, index) => {
                const chatId = item.getAttribute('data-chat-id');
                const chatName = item.querySelector('span').textContent;
                const isActive = item.classList.contains('active');

                const mobileItem = document.createElement('div');
                mobileItem.className = 'mobile-chat-item' + (isActive ? ' active' : '');
                mobileItem.setAttribute('data-chat-id', chatId);
                mobileItem.innerHTML = `
          <div class="chat-info">
            <i class="fas fa-message"></i>
            <span>${chatName}</span>
          </div>
          <button class="delete-chat" aria-label="Delete chat">
            <i class="fas fa-times"></i>
          </button>
        `;

                if (index < 2) {
                    todayContainer.appendChild(mobileItem);
                } else {
                    previousContainer.appendChild(mobileItem);
                }
            });
        }

        // Add event listener to close sidebar
        document.addEventListener('DOMContentLoaded', function () {
            const sidebarHeader = document.querySelector('.sidebar .chat-header');

            if (sidebarHeader) {
                sidebarHeader.addEventListener('click', function (e) {
                    // Check if clicked on the X icon (after pseudo-element)
                    const rect = sidebarHeader.getBoundingClientRect();
                    const isClickAfter = e.clientX > rect.x + rect.width - 30;

                    if (isClickAfter && window.innerWidth <= 992) {
                        const sidebar = document.querySelector('.sidebar');
                        sidebar.style.display = 'none';
                    }
                });
            }
        });

        // Mobile menu interaction improvements
        document.addEventListener('DOMContentLoaded', function () {
            const menuToggle = document.getElementById('mobileMenuToggle');
            const mobileMenu = document.getElementById('mobileMenu');
            const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');

            // Improved touch handling for mobile menu
            if (menuToggle && mobileMenu && mobileMenuOverlay) {
                // Add touch ripple effect
                menuToggle.addEventListener('touchstart', function () {
                    this.classList.add('touch-active');
                });

                menuToggle.addEventListener('touchend', function () {
                    this.classList.remove('touch-active');
                    setTimeout(() => {
                        mobileMenu.classList.add('active');
                        mobileMenuOverlay.classList.add('active');
                        updateMobileChats();
                    }, 50);
                });

                // Add swipe to close functionality
                let startX = 0;
                mobileMenu.addEventListener('touchstart', function (e) {
                    startX = e.touches[0].clientX;
                }, { passive: true });

                mobileMenu.addEventListener('touchmove', function (e) {
                    if (startX > 20) { // Only if started from left edge area
                        let diffX = e.touches[0].clientX - startX;
                        if (diffX < 0) {
                            mobileMenu.style.transform = `translateX(${diffX}px)`;
                        }
                    }
                }, { passive: true });

                mobileMenu.addEventListener('touchend', function (e) {
                    let diffX = e.changedTouches[0].clientX - startX;
                    if (diffX < -50) { // Swipe threshold
                        closeMobileMenu();
                    }
                    mobileMenu.style.transform = '';
                }, { passive: true });

                // Add vibration feedback on menu interactions
                function vibrateIfAvailable(duration) {
                    if ('vibrate' in navigator) {
                        navigator.vibrate(duration);
                    }
                }

                const allButtons = mobileMenu.querySelectorAll('.mobile-menu-btn, .mobile-chat-item');
                allButtons.forEach(btn => {
                    btn.addEventListener('touchstart', () => vibrateIfAvailable(20), { passive: true });
                });
            }
        });

        // Updated previewFile function
        function previewFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Clear previous preview of the same file if it exists
            const existingPreviews = document.querySelectorAll('.file-item');
            existingPreviews.forEach(preview => {
                const fileName = preview.querySelector('.file-name-container span').textContent;
                if (fileName === file.name) {
                    preview.remove();
                    // Also remove from uploadedDocuments
                    delete uploadedDocuments[file.name];
                }
            });

            // Show preview in documents section
            const filePreview = document.getElementById("documentPreviews");
            if (!filePreview) return;

            // Clear welcome message if it exists
            const welcomeMessage = filePreview.querySelector('.empty-preview-message');
            if (welcomeMessage) {
                filePreview.removeChild(welcomeMessage);
            }

            // Create and add new preview
            const fileItem = document.createElement("div");
            fileItem.classList.add("file-item");

            // Add file header with name and delete button
            const fileHeader = document.createElement("div");
            fileHeader.classList.add("file-header");

            const fileNameContainer = document.createElement("div");
            fileNameContainer.classList.add("file-name-container");

            const fileIcon = document.createElement('i');
            fileIcon.classList.add('fas');
            if (file.name.endsWith('.pdf')) {
                fileIcon.classList.add('fa-file-pdf', 'pdf-icon');
            } else if (file.name.endsWith('.txt')) {
                fileIcon.classList.add('fa-file-alt');
            } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
                fileIcon.classList.add('fa-file-word');
            } else if (file.type.startsWith('image/')) {
                fileIcon.classList.add('fa-file-image');
            } else {
                fileIcon.classList.add('fa-file');
            }

            const fileName = document.createElement('span');
            fileName.textContent = file.name;

            fileNameContainer.appendChild(fileIcon);
            fileNameContainer.appendChild(fileName);

            const deleteBtn = document.createElement("button");
            deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
            deleteBtn.classList.add("delete-file");
            deleteBtn.setAttribute('aria-label', 'Remove file');
            
            deleteBtn.addEventListener("click", function(e) {
                e.stopPropagation();
                fileItem.remove();
                delete uploadedDocuments[file.name];

                // Show welcome message if no files left
                if (filePreview.children.length === 0) {
                    const welcomeText = document.createElement('p');
                    welcomeText.className = 'empty-preview-message';
                    welcomeText.innerHTML = '<i class="fas fa-info-circle"></i> Upload files by clicking the paperclip icon in the chat input';
                    filePreview.appendChild(welcomeText);
                }
            });

            fileHeader.appendChild(fileNameContainer);
            fileHeader.appendChild(deleteBtn);
            fileItem.appendChild(fileHeader);

            // Add preview for images and PDFs
            if (file.type.startsWith('image/') || file.name.endsWith('.pdf')) {
                const reader = new FileReader();
                reader.onload = function() {
                    const previewContainer = document.createElement('div');
                    previewContainer.className = 'file-preview-container';

                    if (file.type.startsWith('image/')) {
                        const img = document.createElement('img');
                        img.src = reader.result;
                        img.alt = file.name;
                        previewContainer.appendChild(img);
                    } else if (file.name.endsWith('.pdf')) {
                        previewContainer.classList.add('pdf-preview');
                        const obj = document.createElement('object');
                        obj.data = reader.result;
                        obj.type = 'application/pdf';
                        obj.width = '100%';
                        obj.height = '200px';
                        previewContainer.appendChild(obj);
                    }

                    fileItem.appendChild(previewContainer);
                };
                reader.readAsDataURL(file);
            }

            filePreview.appendChild(fileItem);

            // Ensure document preview section is visible
            const previewSection = document.querySelector('.documents-preview');
            if (previewSection) {
            previewSection.style.display = 'block';
            previewSection.style.visibility = 'visible';
            previewSection.style.opacity = '1';
            }
        }

        // Simple scroll-to-bottom button handler
        document.addEventListener('DOMContentLoaded', function () {
            const chatBox = document.getElementById('chatBox');
            const scrollBottomBtn = document.getElementById('scrollBottomBtn');

            if (!chatBox || !scrollBottomBtn) return;

            // Simple scroll position check
            chatBox.addEventListener('scroll', function () {
                // Show button when not at bottom (with small threshold)
                const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight - chatBox.scrollTop < 50;

                if (isAtBottom) {
                    scrollBottomBtn.classList.remove('visible');
                } else {
                    scrollBottomBtn.classList.add('visible');
                }
            });

            // Simple click handler for scroll button
            scrollBottomBtn.addEventListener('click', function () {
                chatBox.scrollTo({
                    top: chatBox.scrollHeight,
                    behavior: 'smooth'
                });
            });
        });

        // Function to test API connection
        function testAPIConnection() {
            const model = modelConfig.legalMind;
            const endpoint = model.endpoints[model.currentEndpointIndex];
            const token = model.authTokens[model.currentTokenIndex];

            console.log("Testing API connection to:", endpoint);
            console.log("Using token index:", model.currentTokenIndex);

            // Show testing notification
            showNotification(`Testing API connection to endpoint ${model.currentEndpointIndex}...`, "info");

            // Check if token appears valid
            if (!token || !token.startsWith('hf_') || token.length < 10) {
                console.error("API Token appears invalid:", token);
                showNotification("API token appears invalid. Check console for details.", "error");
                return;
            }

            // Create a timeout promise that will reject after 15 seconds
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    reject(new Error('API request timed out after 15 seconds'));
                }, 15000); // 15 seconds timeout
            });

            // Race between the fetch request and the timeout
            Promise.race([
                // Make a simple test request
                fetch(endpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        inputs: "Hello, can you give me a very brief response to test the connection?",
                        parameters: {
                            max_new_tokens: 50,
                            temperature: 0.7,
                            top_p: 0.95,
                            do_sample: true,
                            return_full_text: false
                        }
                    })
                }),
                timeoutPromise
            ])
                .then(response => {
                    console.log("Test API Status:", response.status);
                    console.log("Test API Headers:", [...response.headers.entries()]);

                    if (!response.ok) {
                        return response.text().then(text => {
                            console.error("Test API Error Details:", text);
                            showNotification(`API connection failed (${response.status}): ${response.statusText}`, "error");

                            // Try next endpoint or token
                            if (tryNextEndpointOrToken("legalMind")) {
                                setTimeout(testAPIConnection, 1000);
                            }

                            return null;
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data) {
                        console.log("Test API Success:", data);

                        // Display the actual response in the notification
                        let responseText = "";
                        if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                            responseText = data[0].generated_text.substring(0, 50); // First 50 chars
                        } else if (data && data.generated_text) {
                            responseText = data.generated_text.substring(0, 50);
                        } else {
                            responseText = JSON.stringify(data).substring(0, 50);
                        }

                        showNotification(`API connection successful! Response: "${responseText}..."`, "success");

                        // Also append result to chat if a chat is active
                        if (currentChatId) {
                            let successMessage = `API Test Result: Connection successful! Using endpoint ${model.currentEndpointIndex} and token ${model.currentTokenIndex}.`;

                            // If we're using the DeepSeek fallback model, indicate this in the message
                            if (model.currentEndpointIndex === model.endpoints.length - 1) {
                                successMessage = "API Test Result: Connection successful using fallback model. The original model endpoints are not available, but this alternative will work.";
                            }

                            appendMessage("bot", successMessage);
                        }
                    }
                })
                .catch(error => {
                    console.error("Test API Error:", error);

                    // Specific handling for timeout errors
                    if (error.message.includes('timed out')) {
                        console.log("Test API request timed out - trying next endpoint");
                        showNotification("Test API connection timed out. Trying next model...", "warning");

                        // Try next endpoint or token
                        if (tryNextEndpointOrToken("legalMind")) {
                            setTimeout(testAPIConnection, 1000);
                        } else {
                            showNotification("All models timed out during testing. Please try again later.", "error");
                        }
                        return;
                    }

                    showNotification("API connection error: " + error.message, "error");

                    // Try next endpoint or token for other errors
                    if (tryNextEndpointOrToken("legalMind")) {
                        setTimeout(testAPIConnection, 1000);
                    }
                });
        }

        // Add a button to test the connection - button removed per user request
        document.addEventListener('DOMContentLoaded', function () {
            // No buttons added to UI
        });

        // Add buttons to test the connection and wake up the endpoint - buttons removed per user request
        document.addEventListener('DOMContentLoaded', function () {
            // No buttons added to UI
        });

        // Function to process document content
        function processDocumentContent(file) {
            console.log("Processing document:", file.name);
            showNotification("Processing document: " + file.name, "info");

            if (file.name.endsWith('.pdf')) {
                extractTextFromPDF(file)
                    .then(text => {
                        console.log("Extracted PDF text length:", text.length);
                        uploadedDocuments[file.name] = text;
                        showNotification("PDF processed successfully", "success");
                    })
                    .catch(error => {
                        console.error("Error extracting PDF text:", error);
                        showNotification("Error processing PDF", "error");
                    });
            } else if (file.name.endsWith('.txt')) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const text = e.target.result;
                    uploadedDocuments[file.name] = text;
                    console.log("Processed text file:", file.name);
                    showNotification("Text file processed successfully", "success");
                };
                reader.onerror = function () {
                    console.error("Error reading text file");
                    showNotification("Error processing text file", "error");
                };
                reader.readAsText(file);
            } else if (file.type.startsWith('image/')) {
                // For images, just store a placeholder
                uploadedDocuments[file.name] = "[Image: " + file.name + "]";
                showNotification("Image added to conversation", "success");
            } else {
                // For other files, store a note that they can't be processed
                uploadedDocuments[file.name] = "[File type not supported for content extraction: " + file.name + "]";
                showNotification("File type not supported for content processing", "warning");
            }
        }

        // Function to extract text from PDF
        async function extractTextFromPDF(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = async function (e) {
                    const typedArray = new Uint8Array(e.target.result);

                    try {
                        // Load the PDF document
                        const loadingTask = pdfjsLib.getDocument(typedArray);
                        const pdf = await loadingTask.promise;

                        let fullText = "";

                        // Loop through each page to extract text
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();

                            // Extract the text items
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += pageText + "\n\n"; // Add page breaks
                        }

                        resolve(fullText);
                    } catch (error) {
                        console.error("PDF.js error:", error);
                        reject(error);
                    }
                };

                reader.onerror = function () {
                    reject(new Error("Error reading the file"));
                };

                reader.readAsArrayBuffer(file);
            });
        }

        // Function to get document summary for the prompt
        function getDocumentSummary() {
            let summary = "";

            // Add a list of available documents
            const documentList = Object.keys(uploadedDocuments);
            if (documentList.length > 0) {
                summary += "\n\nAvailable documents:\n";
                documentList.forEach(filename => {
                    summary += `- ${filename}\n`;
                });
            }

            return summary;
        }

        // Function to get document context for the prompt
        function getDocumentContext(messageText) {
            // Look for document references in the message
            const documentList = Object.keys(uploadedDocuments);
            let context = "";

            if (documentList.length === 0) {
                return context; // No documents uploaded
            }

            // Always include document context by default
            // Check if we need to include all documents or specific ones
            const messageLower = messageText.toLowerCase();
            const mentionedDocuments = documentList.filter(filename =>
                messageLower.includes(filename.toLowerCase())
            );

            const documentsToInclude = mentionedDocuments.length > 0 ?
                mentionedDocuments : documentList;

            // Add relevant document content with clear delimiters
            documentsToInclude.forEach(filename => {
                let docContent = uploadedDocuments[filename];

                // Truncate very large documents (limit to ~10,000 chars)
                if (docContent.length > 10000) {
                    docContent = docContent.substring(0, 10000) +
                        "\n\n[Document content truncated due to length. This is only a portion of the full document.]";
                }

                context += `\n\n--- DOCUMENT: ${filename} ---\n`;
                context += docContent;
                context += "\n--- END OF DOCUMENT ---\n\n";
            });

            return context;
        }

        // Function to try the next endpoint or token
        function tryNextEndpointOrToken(activeModelKey) {
            const model = modelConfig[activeModelKey];

            // Try the next token with the same endpoint
            if (model.currentTokenIndex < model.authTokens.length - 1) {
                model.currentTokenIndex++;
                console.log(`Switching to alternative token ${model.currentTokenIndex} for endpoint ${model.currentEndpointIndex}`);
                return true;
            }
            // If we've tried all tokens, try the next endpoint with the first token
            else if (model.currentEndpointIndex < model.endpoints.length - 1) {
                model.currentEndpointIndex++;
                model.currentTokenIndex = 0;

                // Check if we're now using the DeepSeek fallback model (last endpoint)
                if (model.currentEndpointIndex === model.endpoints.length - 1) {
                    console.log("Switching to hidden fallback model Gemini Pro");
                    model.usingFallbackModel = true;
                    showNotification("Trying alternative model (fallback)...", "info");
                } else {
                    console.log(`Switching to alternative endpoint ${model.currentEndpointIndex} with token ${model.currentTokenIndex}`);
                }

                return true;
            }

            // If we've tried all endpoints and tokens, reset to the first combination for next time
            console.log("All endpoints and tokens attempted without success");
            model.currentEndpointIndex = 0;
            model.currentTokenIndex = 0;
            model.usingFallbackModel = false;
            return false;
        }

        // Function to get current endpoint and token info
        function getCurrentEndpointInfo(activeModelKey) {
            const model = modelConfig[activeModelKey];
            return {
                endpoint: model.endpoints[model.currentEndpointIndex],
                token: model.authTokens[model.currentTokenIndex],
                endpointIndex: model.currentEndpointIndex,
                tokenIndex: model.currentTokenIndex
            };
        }

        // Function to wake up a scaled-to-zero endpoint
        function wakeUpEndpoint() {
            const model = modelConfig.legalMind;
            // Force using the first endpoint (AWS endpoint) which is scaled to zero
            model.currentEndpointIndex = 0;
            model.currentTokenIndex = 0;

            const endpoint = model.endpoints[0];
            const token = model.authTokens[0];

            console.log("Attempting to wake up endpoint:", endpoint);
            showNotification("Attempting to wake up endpoint...", "info");

            // Create a timeout promise that will reject after 15 seconds
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    reject(new Error('Wake up request timed out after 15 seconds'));
                }, 15000); // 15 seconds timeout
            });

            // Race between the fetch request and the timeout
            Promise.race([
                // Make a simple test request to wake it up
                fetch(endpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        inputs: "Wake up",
                        parameters: {
                            max_new_tokens: 10,
                            temperature: 0.7,
                            do_sample: true
                        }
                    })
                }),
                timeoutPromise
            ])
                .then(response => {
                    console.log("Wake up status:", response.status);

                    if (!response.ok) {
                        return response.text().then(text => {
                            console.error("Wake up details:", text);

                            if (text.includes("scaled to zero") || response.status === 503) {
                                showNotification("Endpoint is scaled to zero. It may take a few minutes to wake up.", "warning");
                                if (currentChatId) {
                                    appendMessage("bot", "The endpoint is currently inactive (scaled to zero). I've sent a wake-up request. It may take 1-2 minutes to start. Please try again shortly.");
                                }
                            } else {
                                showNotification(`Wake up request failed: ${response.status}`, "error");
                            }
                            return null;
                        });
                    }

                    showNotification("Endpoint is waking up! Try your request again in a moment.", "success");
                    if (currentChatId) {
                        appendMessage("bot", "The endpoint is waking up! Please try your request again in about 30 seconds.");
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error("Wake up error:", error);

                    // Specific handling for timeout errors
                    if (error.message.includes('timed out')) {
                        showNotification("Wake up request timed out. The endpoint may be unavailable.", "warning");
                        if (currentChatId) {
                            appendMessage("bot", "The wake up request timed out. The endpoint appears to be unavailable. I'll automatically try alternative models for your requests.");
                        }
                        return;
                    }

                    showNotification("Error sending wake up request: " + error.message, "error");
                });
        }

        // Function to check if the message is asking about chatbot identity
        function isIdentityQuestion(text) {
            const lowerText = text.toLowerCase().trim();

            // Check for common identity questions
            const identityPatterns = [
                /^who are you/,
                /^what are you/,
                /tell me about yourself/,
                /^who is legal ?mind/,
                /^what is legal ?mind/,
                /introduce yourself/,
                /your name/,
                /^who created you/,
                /^who made you/,
                /^who is your owner/,
                /^what do you do/,
                /^what can you do/
            ];

            return identityPatterns.some(pattern => pattern.includes(lowerText));
        }

        // Mobile Menu Functions
        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            mobileMenu.classList.toggle('active');
            overlay.classList.toggle('active');
            updateMobileChats();
        }

        // Profile Menu Functions
        document.addEventListener('DOMContentLoaded', function() {
            const profilePic = document.getElementById('profilePicNav');
            const profileMenu = document.getElementById('profileMenu');
            const settingsButton = document.getElementById('settingsButton');
            const settingsPanel = document.getElementById('settingsPanel');
            const backToMenu = document.getElementById('backToMenu');
            const profileMainMenu = document.getElementById('profileMainMenu');

            if (profilePic && profileMenu) {
                profilePic.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    profileMenu.classList.toggle('active');
                    // Force repaint in case of rendering issues
                    profileMenu.offsetHeight;
                    // If menu is active, ensure it is displayed properly
                    if (profileMenu.classList.contains('active')) {
                        profileMenu.style.display = 'flex';
                        profileMenu.style.flexDirection = 'column';
                    }
                });
            }

            if (settingsButton && profileMainMenu && settingsPanel) {
                settingsButton.addEventListener('click', function() {
                    profileMainMenu.style.display = 'none';
                    settingsPanel.classList.add('active');
                });
            }

            if (backToMenu && profileMainMenu && settingsPanel) {
                backToMenu.addEventListener('click', function() {
                    profileMainMenu.style.display = 'flex';
                    settingsPanel.classList.remove('active');
                });
            }

            document.addEventListener('click', function(event) {
                if (profileMenu && profileMenu.classList.contains('active')) {
                    if (!event.target.closest('.nav-profile') && !event.target.closest('.profile-menu')) {
                        profileMenu.classList.remove('active');
                        if (profileMainMenu && settingsPanel) {
                            profileMainMenu.style.display = 'flex';
                            settingsPanel.classList.remove('active');
                        }
                    }
                }
            });
        });

        // Dark Mode Toggle
        function toggleDarkMode() {
            const isDarkMode = document.body.classList.toggle("dark-mode");
            localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');
        }

        // Initialize Dark Mode from preferences
        if (localStorage.getItem('darkMode') === 'enabled') {
            document.body.classList.add('dark-mode');
            document.getElementById('darkModeToggle').checked = true;
        }

        // Add these functions to your existing JavaScript
        function toggleLogoDropdown(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const dropdown = document.getElementById('logoDropdown');
            dropdown.classList.toggle('show');
            
            // Close when clicking outside
            document.addEventListener('click', function closeDropdown(e) {
                if (!e.target.closest('.model-dropdown')) {
                    dropdown.classList.remove('show');
                    document.removeEventListener('click', closeDropdown);
                }
            });
        }

        function selectModel(modelName, displayName) {
            // Don't redirect to plans, just update the selected model
            const modelNameDisplay = document.getElementById('selectedModelName');
            if (modelNameDisplay) {
                modelNameDisplay.textContent = displayName;
                
                // Show the selected model info
                const selectedModelInfo = document.getElementById('selectedModelInfo');
                if (selectedModelInfo) {
                    selectedModelInfo.classList.remove('hidden');
                }
            }
            
            // Close the dropdown
            const dropdown = document.getElementById('logoDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
            }
            
            // Highlight the selected model in the dropdown
            const modelLinks = document.querySelectorAll('#logoDropdown a[onclick^="selectModel"]');
            modelLinks.forEach(link => {
                link.classList.remove('active-model');
                if (link.getAttribute('onclick').includes(modelName)) {
                    link.classList.add('active-model');
                }
            });
            
            console.log(`Model selected: ${displayName}`);
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.model-dropdown')) {
                document.getElementById("logoDropdown").style.display = "none";
            }
        });

        // Implement smooth scrolling and auto-resize for textarea
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            const maxHeight = window.innerHeight * 0.3; // Max 30% of viewport height
            const newHeight = Math.min(textarea.scrollHeight, maxHeight);
            textarea.style.height = newHeight + 'px';
        }

        // Update existing appendMessage function to include smooth scrolling
        function appendMessage(sender, text) {
            const chatBox = document.getElementById("chatBox");
            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${sender}`;
            
            if (sender === 'bot') {
                // Format the text with proper spacing and structure
                const formattedText = text
                    // Format headers
                    .replace(/^([A-Z][A-Z\s]+:)/gm, '<h3>$1</h3>')
                    
                    // Format numbered points (1. Point)
                    .replace(/^(\d+\.\s+)(.+)$/gm, '<div class="point numbered">$1$2</div>')
                    
                    // Format bullet points (- Point)
                    .replace(/^(\s*-\s+)(.+)$/gm, '<div class="point bullet">$1$2</div>')
                    
                    // Format code blocks
                    .replace(/```([\s\S]*?)```/g, '<pre class="code-block"><code>$1</code></pre>')
                    
                    // Format inline code
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    
                    // Format steps in mathematical solutions
                    .replace(/^(Step \d+:)(.+)$/gm, '<div class="step">$1$2</div>')
                    
                    // Add spacing between sections
                    .replace(/\n\n/g, '<div class="section-break"></div>')
                    
                    // Convert remaining line breaks
                    .replace(/\n/g, '<br>');
                    
                messageDiv.innerHTML = formattedText;
            } else {
                messageDiv.textContent = text;
            }
            
            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Update existing appendHtmlMessage function to include smooth scrolling
        function appendHtmlMessage(sender, htmlContent) {
            const chatBox = document.getElementById("chatBox");
            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${sender}`;
            
            // Handle thinking animation differently
            if (htmlContent.includes('data-thinking="true"')) {
                const thinkingContainer = document.createElement("div");
                thinkingContainer.className = "thinking-container";
                thinkingContainer.innerHTML = `
                    <div class="thinking-dots">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                    <span>Connecting to model...</span>
                `;
                messageDiv.innerHTML = '';
                messageDiv.appendChild(thinkingContainer);
            } else {
                messageDiv.innerHTML = htmlContent;
            }
            
            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Store in current chat if available
            if (currentChatId && chats[currentChatId] && !htmlContent.includes('data-thinking="true"')) {
                if (!chats[currentChatId].messages) {
                    chats[currentChatId].messages = [];
                }
                chats[currentChatId].messages.push({
                    type: 'html',
                    sender: sender,
                    content: htmlContent
                });
            }
        }

        // Function to show thinking animation (matches temp3.html)
        function showThinkingAnimation() {
            const chatBox = document.getElementById('chatBox');
            const thinkingContainer = document.createElement('div');
            thinkingContainer.className = 'thinking-container';
            thinkingContainer.innerHTML = `
                <div class="thinking-dots">
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                </div>
                <span>Connecting to model...</span>
            `;
            chatBox.appendChild(thinkingContainer);
            chatBox.scrollTop = chatBox.scrollHeight;
            return thinkingContainer;
        }

        // Function to update thinking status
        function updateThinkingStatus(container, status) {
            const statusSpan = container.querySelector('span');
            if (statusSpan) {
                statusSpan.textContent = status;
            }
        }

        // Add smooth scroll function
        function smoothScrollToBottom(element) {
            const target = element.scrollHeight - element.clientHeight;
            const start = element.scrollTop;
            const distance = target - start;
            const duration = 300;
            let startTime = null;

            function animation(currentTime) {
                if (!startTime) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const progress = Math.min(timeElapsed / duration, 1);
                
                // Ease out cubic function for smoother end of scroll
                const ease = 1 - Math.pow(1 - progress, 3);
                element.scrollTop = start + (distance * ease);

                if (progress < 1) {
                    requestAnimationFrame(animation);
                }
            }

            requestAnimationFrame(animation);
        }

        // Initialize event listeners when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener for Enter key
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
                
                // Initialize auto-resize
                messageInput.addEventListener('focus', function() {
                    autoResize(this);
                });
            }
            
            // Add event listener for send button
            const sendBtn = document.getElementById('sendBtn');
            if (sendBtn) {
                sendBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    sendMessage();
                });
            }
        });

        // Add auto-resize function
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            const maxHeight = 120; // Maximum height in pixels
            const scrollHeight = textarea.scrollHeight;
            textarea.style.height = Math.min(scrollHeight, maxHeight) + 'px';
            
            // Show/hide scroll based on content
            textarea.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
        }

        // Initialize textarea on page load
        document.addEventListener('DOMContentLoaded', function() {
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                // Remove extra whitespace
                messageInput.value = messageInput.value.trim();
                // Initial resize
                autoResize(messageInput);
                
                // Focus handling
                messageInput.addEventListener('focus', function() {
                    document.querySelector('.input-container').classList.add('focused');
                });
                
                messageInput.addEventListener('blur', function() {
                    document.querySelector('.input-container').classList.remove('focused');
                });
            }
        });

        // Add CSS for formatted messages
        const messageStyles = `
            .message.bot {
                white-space: pre-wrap;
                line-height: 1.5;
            }
            
            .message.bot h3 {
                margin: 12px 0 8px 0;
                font-size: 1.1em;
                font-weight: 600;
                color: #2563eb;
            }
            
            .message.bot .point {
                margin: 8px 0;
                padding-left: 20px;
            }
            
            .message.bot .point.numbered {
                padding-left: 24px;
                text-indent: -24px;
            }
            
            .message.bot .point.bullet {
                padding-left: 20px;
                text-indent: -12px;
            }
            
            .message.bot .code-block {
                background: #f6f8fa;
                padding: 12px;
                border-radius: 6px;
                margin: 8px 0;
                font-family: monospace;
                white-space: pre;
                overflow-x: auto;
            }
            
            .message.bot code {
                background: rgba(0,0,0,0.05);
                padding: 2px 4px;
                border-radius: 4px;
                font-family: monospace;
            }
            
            .message.bot .step {
                margin: 8px 0;
                padding-left: 20px;
            }
            
            .message.bot .section-break {
                height: 12px;
            }
            
            body.dark-mode .message.bot h3 {
                color: #60a5fa;
            }
            
            body.dark-mode .message.bot .code-block {
                background: #2d3748;
            }
            
            body.dark-mode .message.bot code {
                background: rgba(255,255,255,0.1);
            }
        `;

        // Add styles to document
        const styleElement = document.createElement('style');
        styleElement.textContent = messageStyles;
        document.head.appendChild(styleElement);

        // Update the processDocumentModification function to show changes UI
        function processDocumentModification(message) {
            const docs = Object.keys(window.uploadedDocuments);
            if (docs.length === 0) {
                appendMessage("bot", "Please upload a document first.");
                return false;
            }

            const fileName = docs[docs.length - 1];
            const original = window.uploadedDocuments[fileName].original;

            if (typeof original !== 'string') {
                appendMessage("bot", "Sorry, I can only modify text documents.");
                return false;
            }

            // Show thinking indicator
            showTypingIndicator();

            setTimeout(() => {
                hideTypingIndicator();

                // Create modified version with tracked changes
                const changes = [];
                let modified = original;

                // Track each modification
                if (/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/g.test(modified)) {
                    changes.push({
                        type: 'date',
                        description: 'Format dates consistently (MM/DD/YYYY)'
                    });
                    modified = modified.replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/g, (m, p1, p2, p3) => {
                        return `${p1.padStart(2, '0')}/${p2.padStart(2, '0')}/${p3.length === 2 ? '20' + p3 : p3}`;
                    });
                }

                if (/(?:^|\s)i(?=\s|$)/g.test(modified)) {
                    changes.push({
                        type: 'capitalization',
                        description: 'Fix capitalization of "I"'
                    });
                    modified = modified.replace(/(?:^|\s)i(?=\s|$)/g, ' I');
                }

                // Create diff view
                const diff = createDiffView(original, modified);

                // Create changes review UI
                const reviewUI = `
                <div class="changes-review">
                    <div class="changes-header">
                        <div class="changes-title">
                            <i class="fas fa-file-alt"></i> Suggested Changes for ${fileName}
                        </div>
                        <div class="changes-actions">
                            <button class="changes-action-btn accept-btn" onclick="acceptChanges('${fileName}')">
                                <i class="fas fa-check"></i> Accept
                            </button>
                            <button class="changes-action-btn reject-btn" onclick="rejectChanges('${fileName}')">
                                <i class="fas fa-times"></i> Reject
                            </button>
                        </div>
                    </div>
                    <div class="changes-content">
                        <div class="diff-view">${diff}</div>
                        <div class="changes-summary">
                            <div class="change-item">
                                <i class="fas fa-info-circle"></i>
                                ${changes.length} changes suggested
                            </div>
                            ${changes.map(change => `
                                <div class="change-item">
                                    <i class="fas fa-check-circle"></i>
                                    ${change.description}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>`;

                // Store modified version temporarily
                window.uploadedDocuments[fileName].pendingModified = modified;

                // Show the review UI
                appendMessage("bot", reviewUI);
            }, 1500);

            return true;
        }

        // Function to create a simple diff view
        function createDiffView(original, modified) {
            const originalLines = original.split('\n');
            const modifiedLines = modified.split('\n');
            let diffHtml = '';

            // Simple diff visualization
            for (let i = 0; i < Math.max(originalLines.length, modifiedLines.length); i++) {
                const origLine = originalLines[i];
                const modLine = modifiedLines[i];

                if (origLine !== modLine) {
                    if (origLine !== undefined) {
                        diffHtml += `<div class="diff-line removed"><span class="diff-marker">-</span>${escapeHtml(origLine)}</div>`;
                    }
                    if (modLine !== undefined) {
                        diffHtml += `<div class="diff-line added"><span class="diff-marker">+</span>${escapeHtml(modLine)}</div>`;
                    }
                } else {
                    diffHtml += `<div class="diff-line"><span class="diff-marker"> </span>${escapeHtml(origLine)}</div>`;
                }
            }

            return diffHtml;
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Function to accept changes
        function acceptChanges(fileName) {
            if (!window.uploadedDocuments[fileName]?.pendingModified) return;

            // Apply pending changes
            window.uploadedDocuments[fileName].modified = window.uploadedDocuments[fileName].pendingModified;
            delete window.uploadedDocuments[fileName].pendingModified;

            // Show success message
            appendMessage("bot", `I've updated your document with the following changes:
            
-  Fixed formatting issues
-  Improved text consistency
-  Applied standard legal document formatting
  
Your modified document is ready to download.`);

            // Show modified download button
            const modBtn = document.getElementById(`mod-btn-${fileName.replace(/[^a-zA-Z0-9]/g, '')}`);
            if (modBtn) {
                modBtn.style.display = 'flex';
            }
        }

        // Function to reject changes
        function rejectChanges(fileName) {
            if (!window.uploadedDocuments[fileName]?.pendingModified) return;

            // Clear pending changes
            delete window.uploadedDocuments[fileName].pendingModified;

            // Show rejection message
            appendMessage("bot", ` Changes rejected. The document "${fileName}" remains unchanged.`);
        }

        // Fix the sendMessage function to properly handle original API calls
        window.sendMessage = function() {
            const messageInput = document.getElementById("messageInput");
            const userMessageText = messageInput.value.trim();
            
            if (userMessageText) {
                // Clear input immediately for better UX
                messageInput.value = "";
                
                // Initialize conversation history for this chat if it doesn't exist
                if (!window.conversationHistory) {
                    window.conversationHistory = {};
                }
                if (!window.conversationHistory[currentChatId]) {
                    window.conversationHistory[currentChatId] = [];
                }
                
                // Add user message to history
                window.conversationHistory[currentChatId].push({
                    role: "user",
                    content: userMessageText
                });
                
                // Append user's message to UI
                appendMessage("user", userMessageText);
                
                // Check if this is a document modification request
                if (window.uploadedDocuments && Object.keys(window.uploadedDocuments).length > 0 && 
                    (userMessageText.toLowerCase().includes('implement') || 
                    userMessageText.toLowerCase().includes('modify') || 
                    userMessageText.toLowerCase().includes('change') || 
                    userMessageText.toLowerCase().includes('update') || 
                    userMessageText.toLowerCase().includes('fix'))) {
                    
                    // Handle with our document modification logic
                    return processDocumentModification(userMessageText);
                } else {
                    // For non-document related messages, use the API
                    // Show loading indicator
                    showTypingIndicator();
                    
                    // Get last 5 messages for context
                    let contextMessages = window.conversationHistory[currentChatId]?.slice(-10) || [];
                    let conversationContext = contextMessages.map(msg => 
                        `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                    ).join('\n');
                    
                    // Add the current query
                    let fullPrompt = `You are LegalMind, a helpful legal assistant. Here is the recent conversation history for context:\n\n${conversationContext}\n\nPlease provide a response that takes into account the conversation history above. If the user's question refers to something mentioned earlier, use that context in your response.\n\nUser's current message: ${userMessageText}\n\nAssistant:`;
                    
                    // Get document context if applicable
                    const documentContext = getRelevantDocumentContext(userMessageText);
                    let finalPrompt = documentContext ? 
                        `${fullPrompt}\n\nRelevant documents:\n${documentContext}` : 
                        fullPrompt;
                    
                    console.log("Sending prompt with conversation history:", finalPrompt);
                    
                    // Prepare API request parameters
                    let requestParams = {
                        max_new_tokens: 1024,
                        temperature: 0.7,
                        top_p: 0.95,
                        do_sample: true,
                        return_full_text: false
                    };
                    
                    // Create a timeout promise that will reject after 15 seconds
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => {
                            reject(new Error('API request timed out after 15 seconds'));
                        }, 15000); // 15 seconds timeout
                    });
                    
                    // Race between the fetch request and the timeout
                    Promise.race([
                        fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                message: userMessageText,
                                prompt: finalPrompt,
                                chatId: currentChatId
                            }),
                        }),
                        timeoutPromise
                    ])
                    .then(response => {
                        console.log("API Response Status:", response.status);
                        
                        if (!response.ok) {
                            console.error("API Error:", response.status, response.statusText);
                            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        hideTypingIndicator();
                        
                        // Get bot response from the API
                        let botResponse = "";
                        
                        if (data && data.response) {
                            botResponse = data.response.trim();
                        } else if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                            botResponse = data[0].generated_text.trim();
                        } else if (data && data.generated_text) {
                            botResponse = data.generated_text.trim();
                        } else if (typeof data === 'string') {
                            botResponse = data.trim();
                        } else if (data && data.choices && data.choices.length > 0) {
                            botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
                        } else {
                            console.warn("Unexpected API response format:", data);
                            botResponse = "I apologize, but I received an unexpected response format. Please try again with your question.";
                        }
                        
                        // Add bot response to history
                        window.conversationHistory[currentChatId].push({
                            role: "assistant",
                            content: botResponse
                        });
                        
                        // Display the bot's response
                        appendMessage("bot", botResponse);
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        hideTypingIndicator();
                        // Fallback response if API fails
                        appendMessage("bot", "I'm sorry, I encountered an error processing your request. Please try again.");
                    });
                    
                    return true;
                }
            }
            
            return false;
        };

        // Function to get relevant document context based on user message
        function getRelevantDocumentContext(userMessage) {
            if (!window.uploadedDocuments || Object.keys(window.uploadedDocuments).length === 0) {
                return null;
            }
            
            // Simple implementation - just return the most recently uploaded document content
            const documentNames = Object.keys(window.uploadedDocuments);
            const latestDocument = documentNames[documentNames.length - 1];
            const documentContent = window.uploadedDocuments[latestDocument].content;
            
            // Return a summarized version if the content is available and is text
            if (documentContent && typeof documentContent === 'string') {
                // Limit to first 500 characters to avoid making the prompt too long
                return `Document name: ${latestDocument}\nContent preview: ${documentContent.substring(0, 500)}${documentContent.length > 500 ? '...' : ''}`;
            }
            
            return null;
        }

        // Make sure showTypingIndicator and hideTypingIndicator functions are defined properly
        function showTypingIndicator() {
            // Remove any existing indicator first
            hideTypingIndicator();
            
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'message bot typing-indicator';
            typingIndicator.innerHTML = `
                <div class="thinking-animation">
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                </div>
                <div class="thinking-text">Thinking...</div>
            `;
            
            // Add typing indicator to chat box
            const chatBox = document.getElementById('chatBox');
            if (chatBox) {
                chatBox.appendChild(typingIndicator);
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        }
        
        function hideTypingIndicator() {
            const existingIndicator = document.querySelector('.typing-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Add CSS for typing indicator if not already defined
        if (!document.getElementById('typing-indicator-css')) {
            const style = document.createElement('style');
            style.id = 'typing-indicator-css';
            style.textContent = `
                .typing-indicator {
                    display: flex;
                    flex-direction: column;
                    padding: 15px;
                    background: var(--light-surface);
                    border-radius: 15px;
                    max-width: 80%;
                    margin-right: auto;
                    position: relative;
                    animation: fadeIn 0.3s ease;
                }
                
                body.dark-mode .typing-indicator {
                    background: var(--dark-surface);
                }
                
                .thinking-animation {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin-bottom: 8px;
                }
                
                .thinking-dot {
                    width: 8px;
                    height: 8px;
                    margin: 0 4px;
                    background-color: var(--primary-color);
                    border-radius: 50%;
                    opacity: 0.8;
                    animation: thinking-bounce 1.4s infinite ease-in-out both;
                }
                
                .thinking-dot:nth-child(1) {
                    animation-delay: -0.32s;
                }
                
                .thinking-dot:nth-child(2) {
                    animation-delay: -0.16s;
                }
                
                .thinking-text {
                    font-size: 0.9rem;
                    color: var(--light-text);
                    opacity: 0.7;
                }
                
                body.dark-mode .thinking-text {
                    color: var(--dark-text);
                }
                
                @keyframes thinking-bounce {
                    0%, 80%, 100% { 
                        transform: translateY(0);
                    }
                    40% { 
                        transform: translateY(-8px);
                    }
                }
                
                @keyframes fadeIn {
                    from { opacity: 0; transform: translateY(10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
            `;
            document.head.appendChild(style);
        }

        // Make sure the fallback fetch API is properly defined if needed
        if (typeof fetch === 'undefined') {
            window.fetch = function(url, options) {
                return new Promise((resolve, reject) => {
                    // Simulate successful API response for testing
                    setTimeout(() => {
                        resolve({
                            json: () => Promise.resolve({
                                response: "I'm a simulated LegalMind response since the API connection is unavailable."
                            })
                        });
                    }, 1000);
                });
            };
        }

        // Enhanced createThinkingAnimation function if needed elsewhere
        function createThinkingAnimation(element) {
            // Clear previous content
            element.innerHTML = '';
            
            // Create thinking animation
            const thinkingAnimation = document.createElement('div');
            thinkingAnimation.className = 'thinking-animation';
            
            // Add dots
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'thinking-dot';
                thinkingAnimation.appendChild(dot);
            }
            
            // Add text
            const thinkingText = document.createElement('div');
            thinkingText.className = 'thinking-text';
            thinkingText.textContent = 'Thinking...';
            
            // Add to element
            element.appendChild(thinkingAnimation);
            element.appendChild(thinkingText);
            
            return element;
        }

        // Improved function to add messages with proper scrolling
        function appendMessage(sender, content) {
            const chatBox = document.getElementById("chatBox");
            if (!chatBox) return;
            
            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${sender}`;
            
            // If this is a "thinking" message, create the animation
            if (content === "Thinking...") {
                createThinkingAnimation(messageDiv);
            } else {
                messageDiv.innerHTML = content;
            }
            
            // Add the message to the chat box
            chatBox.appendChild(messageDiv);
            
            // Save the current scroll position and height
            const wasScrolledToBottom = isScrolledToBottom(chatBox);
            
            // Show or hide scroll to bottom button
            toggleScrollButton(chatBox);
            
            // Scroll to bottom only if user was already at the bottom
            if (wasScrolledToBottom) {
                scrollToBottom(chatBox);
            }
            
            return messageDiv;
        }
        
        // Function to check if chat is scrolled to bottom
        function isScrolledToBottom(element) {
            return element.scrollHeight - element.clientHeight <= element.scrollTop + 50;
        }
        
        // Function to scroll to bottom smoothly
        function scrollToBottom(element) {
            element.scrollTo({
                top: element.scrollHeight,
                behavior: 'smooth'
            });
        }
        
        // Function to toggle scroll button visibility
        function toggleScrollButton(chatBox) {
            const scrollBtn = document.getElementById('scrollBottomBtn');
            if (!scrollBtn) return;
            
            // Show button if not at bottom
            if (!isScrolledToBottom(chatBox)) {
                scrollBtn.classList.add('visible');
            } else {
                scrollBtn.classList.remove('visible');
            }
        }
        
        // Initialize scroll button functionality
        document.addEventListener('DOMContentLoaded', function() {
            const chatBox = document.getElementById('chatBox');
            const scrollBtn = document.getElementById('scrollBottomBtn');
            
            if (chatBox && scrollBtn) {
                // Show/hide button based on scroll position
                chatBox.addEventListener('scroll', function() {
                    toggleScrollButton(chatBox);
                });
                
                // Scroll to bottom when button is clicked
                scrollBtn.addEventListener('click', function() {
                    scrollToBottom(chatBox);
                });
                
                // Add button styles if not already defined
                if (!document.getElementById('scroll-button-css')) {
                    const style = document.createElement('style');
                    style.id = 'scroll-button-css';
                    style.textContent = `
                        .scroll-bottom-btn {
                            position: absolute;
                            bottom: 20px;
                            right: 20px;
                            width: 40px;
                            height: 40px;
                            border-radius: 50%;
                            background-color: var(--primary-color);
                            color: white;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                            opacity: 0;
                            transform: scale(0.9);
                            transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.3s ease;
                            z-index: 10;
                            border: none;
                        }
                        
                        .scroll-bottom-btn.visible {
                            opacity: 1;
                            transform: scale(1);
                        }
                        
                        .scroll-bottom-btn:hover {
                            background-color: var(--primary-hover);
                            transform: scale(1.05);
                        }
                        
                        .scroll-bottom-btn:active {
                            transform: scale(0.95);
                        }
                    `;
                    document.head.appendChild(style);
                }
            }
        });

        // Fix the sendMessage function to handle API calls correctly with thinking animation
        window.sendMessage = function() {
            const messageInput = document.getElementById("messageInput");
            const userMessageText = messageInput.value.trim();
            
            if (userMessageText) {
                // Clear input immediately for better UX
                messageInput.value = "";
                
                // Initialize conversation history for this chat if it doesn't exist
                if (!window.conversationHistory) {
                    window.conversationHistory = {};
                }
                if (!window.conversationHistory[currentChatId]) {
                    window.conversationHistory[currentChatId] = [];
                }
                
                // Add user message to history
                window.conversationHistory[currentChatId].push({
                    role: "user",
                    content: userMessageText
                });
                
                // Append user's message to UI
                appendMessage("user", userMessageText);
                
                // Check if this is a document modification request
                if (window.uploadedDocuments && Object.keys(window.uploadedDocuments).length > 0 && 
                    (userMessageText.toLowerCase().includes('implement') || 
                    userMessageText.toLowerCase().includes('modify') || 
                    userMessageText.toLowerCase().includes('change') || 
                    userMessageText.toLowerCase().includes('update') || 
                    userMessageText.toLowerCase().includes('fix'))) {
                    
                    // Handle with our document modification logic
                    return processDocumentModification(userMessageText);
                } else {
                    // For non-document related messages, use the API
                    // Show thinking animation with message
                    const thinkingMsg = appendMessage("bot", "Thinking...");
                    
                    // Get last 5 messages for context
                    let contextMessages = window.conversationHistory[currentChatId]?.slice(-10) || [];
                    let conversationContext = contextMessages.map(msg => 
                        `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
                    ).join('\n');
                    
                    // Add the current query
                    let fullPrompt = `You are LegalMind, a helpful legal assistant. Here is the recent conversation history for context:\n\n${conversationContext}\n\nPlease provide a response that takes into account the conversation history above. If the user's question refers to something mentioned earlier, use that context in your response.\n\nUser's current message: ${userMessageText}\n\nAssistant:`;
                    
                    // Get document context if applicable
                    const documentContext = getRelevantDocumentContext(userMessageText);
                    let finalPrompt = documentContext ? 
                        `${fullPrompt}\n\nRelevant documents:\n${documentContext}` : 
                        fullPrompt;
                    
                    console.log("Sending prompt with conversation history:", finalPrompt);
                    
                    // Prepare API request parameters
                    let requestParams = {
                        max_new_tokens: 1024,
                        temperature: 0.7,
                        top_p: 0.95,
                        do_sample: true,
                        return_full_text: false
                    };
                    
                    // Create a timeout promise that will reject after 15 seconds
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => {
                            reject(new Error('API request timed out after 15 seconds'));
                        }, 15000); // 15 seconds timeout
                    });
                    
                    // Race between the fetch request and the timeout
                    Promise.race([
                        fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                message: userMessageText,
                                prompt: finalPrompt,
                                chatId: currentChatId
                            }),
                        }),
                        timeoutPromise
                    ])
                    .then(response => {
                        console.log("API Response Status:", response.status);
                        
                        if (!response.ok) {
                            console.error("API Error:", response.status, response.statusText);
                            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Remove the thinking message
                        if (thinkingMsg && thinkingMsg.parentNode) {
                            thinkingMsg.parentNode.removeChild(thinkingMsg);
                        }
                        
                        // Get bot response from the API
                        let botResponse = "";
                        
                        if (data && data.response) {
                            botResponse = data.response.trim();
                        } else if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                            botResponse = data[0].generated_text.trim();
                        } else if (data && data.generated_text) {
                            botResponse = data.generated_text.trim();
                        } else if (typeof data === 'string') {
                            botResponse = data.trim();
                        } else if (data && data.choices && data.choices.length > 0) {
                            botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
                        } else {
                            console.warn("Unexpected API response format:", data);
                            botResponse = "I apologize, but I received an unexpected response format. Please try again with your question.";
                        }
                        
                        // Add bot response to history
                        window.conversationHistory[currentChatId].push({
                            role: "assistant",
                            content: botResponse
                        });
                        
                        // Display the bot's response
                        appendMessage("bot", botResponse);
                        
                        // Trim history if it gets too long (keep last 50 messages)
                        if (window.conversationHistory[currentChatId].length > 50) {
                            window.conversationHistory[currentChatId] = window.conversationHistory[currentChatId].slice(-50);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        
                        // Remove the thinking message
                        if (thinkingMsg && thinkingMsg.parentNode) {
                            thinkingMsg.parentNode.removeChild(thinkingMsg);
                        }
                        
                        // Fallback response if API fails
                        appendMessage("bot", "I'm sorry, I encountered an error processing your request. Please try again.");
                    });
                    
                    return true;
                }
            }
            
            return false;
        };

        // Function to warm up the API endpoint with a simple request
        function warmupEndpoint() {
            console.log("Warming up API endpoint...");
            
            // Get the current model configuration
            const model = modelConfig[activeModel];
            const endpoint = model.endpoints[model.currentEndpointIndex];
            const token = model.authTokens[model.currentTokenIndex];
            
            // Make a minimal request to wake up the endpoint
            fetch(endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`
                },
                body: JSON.stringify({
                    inputs: "Hello",
                    parameters: {
                        max_new_tokens: 5,
                        temperature: 0.7,
                        do_sample: true,
                        return_full_text: false
                    }
                })
            })
            .then(response => {
                if (response.ok) {
                    console.log("API endpoint successfully warmed up!");
                    showNotification("AI model ready", "success");
                } else {
                    console.log("Endpoint warming status:", response.status);
                    if (response.status === 503) {
                        console.log("Endpoint is scaled to zero, attempting to wake it up");
                        // Silently try to wake it up in the background
                        setTimeout(warmupEndpoint, 5000); // Try again in 5 seconds
                    }
                }
            })
            .catch(error => {
                console.error("Error warming up endpoint:", error);
                // Try next endpoint if current one fails
                if (tryNextEndpointOrToken(activeModel)) {
                    setTimeout(warmupEndpoint, 2000);
                }
            });
        }

        // Improved thinking animation function
        function showThinkingAnimation() {
            // Create container for the thinking animation
            const thinkingContainer = document.createElement('div');
            thinkingContainer.className = 'message bot-message thinking-message';
            
            // Generate unique IDs for this instance
            const step1Id = 'thinking-step1-' + Date.now();
            const step2Id = 'thinking-step2-' + Date.now();
            const step3Id = 'thinking-step3-' + Date.now();
            
            // Create more engaging content for the thinking animation
            thinkingContainer.innerHTML = `
                <div class="thinking-header">
                    <div class="thinking-brain-icon">
                        <i class="fas fa-brain"></i>
                    </div>
                    <div class="thinking-status">
                        <span>Processing your request</span>
                        <div class="thinking-progress">
                            <div class="thinking-progress-bar"></div>
                        </div>
                    </div>
                </div>
                <div class="thinking-steps">
                    <div class="thinking-step" id="${step1Id}">
                        <i class="fas fa-search"></i>
                        <span>Analyzing document context</span>
                    </div>
                    <div class="thinking-step" id="${step2Id}">
                        <i class="fas fa-lightbulb"></i>
                        <span>Generating response</span>
                    </div>
                    <div class="thinking-step" id="${step3Id}">
                        <i class="fas fa-check-circle"></i>
                        <span>Finalizing answer</span>
                    </div>
                </div>
            `;
            
            // Add to chat box
            const chatBox = document.getElementById('chatBox');
            chatBox.appendChild(thinkingContainer);
            
            // Scroll to the thinking animation
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Animate steps sequentially
            setTimeout(() => {
                document.getElementById(step1Id).classList.add('active');
                
                setTimeout(() => {
                    document.getElementById(step2Id).classList.add('active');
                    
                    setTimeout(() => {
                        document.getElementById(step3Id).classList.add('active');
                    }, 1500);
                }, 1500);
            }, 300);
            
            return thinkingContainer;
        }

        // Replace the existing showTypingIndicator and hideTypingIndicator functions
        function showTypingIndicator() {
            // Use the new thinking animation instead
            const thinkingAnimation = showThinkingAnimation();
            window.currentThinkingIndicator = thinkingAnimation;
            return thinkingAnimation;
        }

        function hideTypingIndicator() {
            if (window.currentThinkingIndicator) {
                window.currentThinkingIndicator.remove();
                window.currentThinkingIndicator = null;
            }
        }

        // Add this to the end of your document ready function to call warmupEndpoint on page load
        // Add this to the document ready event or create one if it doesn't exist
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Initialize API endpoint when page loads
            setTimeout(warmupEndpoint, 1000); // Slight delay to ensure page is fully loaded
            
            // ... rest of your existing code ...
        });
    </script>
    
    <!-- Fixed Integration for API and Document Handling -->
    <script>
        // =============================================
        // MAIN MESSAGE HANDLING FUNCTION
        // =============================================
        
        // Override the sendMessage function with our fixed implementation
        window.sendMessage = function() {
            const messageInput = document.getElementById("messageInput");
            const userMessageText = messageInput.value.trim();
            console.log("sendMessage called with text:", userMessageText);
            
            if (!userMessageText) return false;
            
            // Clear input and display user message
            messageInput.value = "";
            appendMessage("user", userMessageText);
            
            // Check if this is a document-related request when documents are available
            const hasDocuments = window.uploadedDocuments && 
                                Object.keys(window.uploadedDocuments).length > 0;
                                
            const isDocModRequest = userMessageText.toLowerCase().includes('implement') || 
                                   userMessageText.toLowerCase().includes('modify') || 
                                   userMessageText.toLowerCase().includes('change') || 
                                   userMessageText.toLowerCase().includes('update') || 
                                   userMessageText.toLowerCase().includes('fix');
            
            if (hasDocuments && isDocModRequest) {
                console.log("Processing document modification request");
                return processDocumentModification(userMessageText);
            } else {
                console.log("Processing regular API message");
                sendApiRequest(userMessageText);
                return true;
            }
        };
        
        // =============================================
        // API REQUEST HANDLING
        // =============================================
        
        // Function to send API requests
        function sendApiRequest(userMessage) {
            // Show thinking animation
            const thinkingMsg = appendMessage("bot", "Thinking...");
            
            // Initialize conversation history if needed
            if (!window.conversationHistory) {
                window.conversationHistory = {};
            }
            if (!window.conversationHistory[currentChatId]) {
                window.conversationHistory[currentChatId] = [];
            }
            
            // Add user message to history
            window.conversationHistory[currentChatId].push({
                role: "user",
                content: userMessage
            });
            
            // Get conversation context
            let contextMessages = window.conversationHistory[currentChatId].slice(-10);
            let conversationContext = contextMessages.map(msg => 
                `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`
            ).join('\n');
            
            // Create prompt with document context if available
            let fullPrompt = `You are LegalMind, a helpful legal assistant. Here is the conversation history:\n\n${conversationContext}\n\nUser's message: ${userMessage}\n\nAssistant:`;
            
            // Add document context if applicable
            const documentContext = getDocumentContext(userMessage);
            if (documentContext) {
                fullPrompt += `\n\nRelevant document content: ${documentContext}`;
            }
            
            // Get the current model configuration
            const model = modelConfig[activeModel];
            const endpoint = model.endpoints[model.currentEndpointIndex];
            const token = model.authTokens[model.currentTokenIndex];
            
            console.log("Using endpoint:", endpoint);
            
            // Create controller for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            // Send directly to the Hugging Face model endpoint
            fetch(endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`
                },
                body: JSON.stringify({
                    inputs: fullPrompt,
                    parameters: {
                        max_new_tokens: 1024,
                        temperature: 0.7,
                        top_p: 0.95,
                        do_sample: true,
                        return_full_text: false
                    }
                }),
                signal: controller.signal
            })
            .then(response => {
                clearTimeout(timeoutId);
                console.log("API Response Status:", response.status);
                
                if (!response.ok) {
                    if (response.status === 503) {
                        // Model is likely scaled to zero
                        appendMessage("bot", "The model endpoint is currently inactive (scaled to zero). It may take 1-2 minutes to start. Please try again shortly.");
                        throw new Error("Model endpoint is scaled to zero");
                    } else {
                        return response.text().then(text => {
                            throw new Error(`API error: ${response.status} - ${text}`);
                        });
                    }
                }
                return response.json();
            })
            .then(data => {
                console.log("API response received:", data);
                
                // Remove thinking message
                if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                // Process the response
                let botResponse = "";
                if (data && data.generated_text) {
                    botResponse = data.generated_text.trim();
                } else if (data && Array.isArray(data) && data.length > 0 && data[0].generated_text) {
                    botResponse = data[0].generated_text.trim();
                } else if (typeof data === 'string') {
                    botResponse = data.trim();
                } else if (data && data.choices && data.choices.length > 0) {
                    botResponse = (data.choices[0].message?.content || data.choices[0].text).trim();
                } else {
                    console.warn("Unexpected API response format:", data);
                    botResponse = "I apologize, but I received an unexpected response format. Please try again with your question.";
                }
                
                // Add bot response to conversation history
                window.conversationHistory[currentChatId].push({
                    role: "assistant",
                    content: botResponse
                });
                
                // Display the response
                appendMessage("bot", botResponse);
            })
            .catch(error => {
                clearTimeout(timeoutId);
                console.error("API Error:", error);
                
                // Remove thinking message
                if (thinkingMsg && thinkingMsg.parentNode) {
                    thinkingMsg.parentNode.removeChild(thinkingMsg);
                }
                
                if (error.name === 'AbortError') {
                    appendMessage("bot", "I'm sorry, the request timed out. The model might be taking too long to respond. Please try again or try a different model.");
                } else if (error.message.includes("scaled to zero")) {
                    // Already handled above
                } else {
                    // Try next endpoint
                    if (tryNextEndpointOrToken(activeModel)) {
                        appendMessage("bot", "I encountered an issue with the current model. Let me try with a different one.");
                        // Wait a moment and retry with new endpoint
                        setTimeout(() => sendApiRequest(userMessage), 1000);
                    } else {
                        // Show error message if all endpoints failed
                        appendMessage("bot", "I'm sorry, I encountered an error processing your request. All available models have been tried. Please try again later.");
                    }
                }
            });
        }
        
        // =============================================
        // DOCUMENT CONTEXT FUNCTIONS
        // =============================================
        
        // Function to get document context for API requests
        function getDocumentContext(userMessage) {
            if (!window.uploadedDocuments || Object.keys(window.uploadedDocuments).length === 0) {
                return null;
            }
            
            // Get most recent document
            const documentNames = Object.keys(window.uploadedDocuments);
            const latestDocument = documentNames[documentNames.length - 1];
            
            // Get content (checking both possible property names)
            const documentContent = window.uploadedDocuments[latestDocument].content || 
                                  window.uploadedDocuments[latestDocument].original;
            
            if (!documentContent || typeof documentContent !== 'string') {
                return null;
            }
            
            // Return a limited preview
            return `${latestDocument}: ${documentContent.substring(0, 500)}${documentContent.length > 500 ? '...' : ''}`;
        }
    </script>

    <!-- Add this before the DOMContentLoaded event listener at the end of the script section -->

    <!-- Function to warm up the API endpoint with a simple request -->
    <script>
        function warmupEndpoint() {
            console.log("Warming up API endpoint...");
            
            // Get the current model configuration
            const model = modelConfig[activeModel];
            const endpoint = model.endpoints[model.currentEndpointIndex];
            const token = model.authTokens[model.currentTokenIndex];
            
            // Make a minimal request to wake up the endpoint
            fetch(endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`
                },
                body: JSON.stringify({
                    inputs: "Hello",
                    parameters: {
                        max_new_tokens: 5,
                        temperature: 0.7,
                        do_sample: true,
                        return_full_text: false
                    }
                })
            })
            .then(response => {
                if (response.ok) {
                    console.log("API endpoint successfully warmed up!");
                    showNotification("AI model ready", "success");
                } else {
                    console.log("Endpoint warming status:", response.status);
                    if (response.status === 503) {
                        console.log("Endpoint is scaled to zero, attempting to wake it up");
                        // Silently try to wake it up in the background
                        setTimeout(warmupEndpoint, 5000); // Try again in 5 seconds
                    }
                }
            })
            .catch(error => {
                console.error("Error warming up endpoint:", error);
                // Try next endpoint if current one fails
                if (tryNextEndpointOrToken(activeModel)) {
                    setTimeout(warmupEndpoint, 2000);
                }
            });
        }

        // Improved thinking animation function
        function showThinkingAnimation() {
            // Create container for the thinking animation
            const thinkingContainer = document.createElement('div');
            thinkingContainer.className = 'message bot-message thinking-message';
            
            // Create more engaging content for the thinking animation
            thinkingContainer.innerHTML = `
                <div class="thinking-header">
                    <div class="thinking-brain-icon">
                        <i class="fas fa-brain"></i>
                    </div>
                    <div class="thinking-status">
                        <span>Processing your request</span>
                        <div class="thinking-progress">
                            <div class="thinking-progress-bar"></div>
                        </div>
                    </div>
                </div>
                <div class="thinking-steps">
                    <div class="thinking-step" id="step1">
                        <i class="fas fa-search"></i>
                        <span>Analyzing document context</span>
                    </div>
                    <div class="thinking-step" id="step2">
                        <i class="fas fa-lightbulb"></i>
                        <span>Generating response</span>
                    </div>
                    <div class="thinking-step" id="step3">
                        <i class="fas fa-check-circle"></i>
                        <span>Finalizing answer</span>
                    </div>
                </div>
            `;
            
            // Add to chat box
            const chatBox = document.getElementById('chatBox');
            chatBox.appendChild(thinkingContainer);
            
            // Scroll to the thinking animation
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Animate steps sequentially
            setTimeout(() => {
                document.getElementById('step1').classList.add('active');
                
                setTimeout(() => {
                    document.getElementById('step2').classList.add('active');
                    
                    setTimeout(() => {
                        document.getElementById('step3').classList.add('active');
                    }, 1500);
                }, 1500);
            }, 300);
            
            return thinkingContainer;
        }

        // Replace the existing showTypingIndicator and hideTypingIndicator functions
        function showTypingIndicator() {
            // Use the new thinking animation instead
            const thinkingAnimation = showThinkingAnimation();
            window.currentThinkingIndicator = thinkingAnimation;
            return thinkingAnimation;
        }

        function hideTypingIndicator() {
            if (window.currentThinkingIndicator) {
                window.currentThinkingIndicator.remove();
                window.currentThinkingIndicator = null;
            }
        }

        // Add this to the end of your document ready function to call warmupEndpoint on page load
        // Add this to the document ready event or create one if it doesn't exist
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            
            // Initialize API endpoint when page loads
            setTimeout(warmupEndpoint, 1000); // Slight delay to ensure page is fully loaded
            
            // ... rest of your existing code ...
        });
    </script>

    <!-- Function to warm up all API endpoints -->
    <script>
        function warmupEndpoint(endpointIndex = 0) {
            // Get the current model configuration
            const model = modelConfig[activeModel];
            
            // Check if endpointIndex is valid
            if (endpointIndex >= model.endpoints.length) {
                console.log("All endpoints warmed up!");
                return;
            }
            
            const endpoint = model.endpoints[endpointIndex];
            const token = model.authTokens[0]; // Use first token for warmup
            
            console.log(`Warming up API endpoint ${endpointIndex}:`, endpoint);
            
            // Make a minimal request to wake up the endpoint
            fetch(endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}`
                },
                body: JSON.stringify({
                    inputs: "Hello",
                    parameters: {
                        max_new_tokens: 5,
                        temperature: 0.7,
                        do_sample: true,
                        return_full_text: false
                    }
                })
            })
            .then(response => {
                if (response.ok) {
                    console.log(`API endpoint ${endpointIndex} successfully warmed up!`);
                    showNotification(`Model ${endpointIndex+1} ready`, "success");
                } else {
                    console.log(`Endpoint ${endpointIndex} warming status:`, response.status);
                    if (response.status === 503) {
                        console.log(`Endpoint ${endpointIndex} is scaled to zero, attempting to wake it up`);
                        // Silently try to wake it up in the background
                        setTimeout(() => warmupEndpoint(endpointIndex), 8000); // Try again in 8 seconds
                        return; // Don't proceed to next endpoint yet
                    }
                }
                
                // Warm up the next endpoint
                setTimeout(() => warmupEndpoint(endpointIndex + 1), 1000);
            })
            .catch(error => {
                console.error(`Error warming up endpoint ${endpointIndex}:`, error);
                // Move to next endpoint on error
                setTimeout(() => warmupEndpoint(endpointIndex + 1), 1000);
            });
        }
    </script>

    <!-- Immediate endpoint warmup -->
    <script>
        // Start warming up endpoints immediately
        setTimeout(function() {
            console.log("Starting immediate warmup of all endpoints");
            
            // Warm up each endpoint in the array
            const model = modelConfig.legalMind;
            for (let i = 0; i < model.endpoints.length; i++) {
                setTimeout(function() {
                    const endpoint = model.endpoints[i];
                    const token = model.authTokens[0];
                    
                    console.log(`Warming up endpoint ${i}: ${endpoint}`);
                    
                    fetch(endpoint, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${token}`
                        },
                        body: JSON.stringify({
                            inputs: "Hello",
                            parameters: {
                                max_new_tokens: 5,
                                temperature: 0.7,
                                do_sample: true
                            }
                        })
                    })
                    .then(response => {
                        console.log(`Endpoint ${i} response status: ${response.status}`);
                    })
                    .catch(error => {
                        console.error(`Error warming up endpoint ${i}:`, error);
                    });
                }, i * 2000); // Stagger requests every 2 seconds
            }
        }, 1000); // Start after 1 second
    </script>

    

    <!-- Add document click handler to close menu when clicking outside -->
    <script>
        document.addEventListener('click', function(event) {
            const profileMenu = document.getElementById('profileMenu');
            const profilePicNav = document.getElementById('profilePicNav');
            
            if (profileMenu && profileMenu.style.display === 'flex') {
                // Check if click is outside the menu and profile pic
                if (!profileMenu.contains(event.target) && event.target !== profilePicNav) {
                    profileMenu.style.display = 'none';
                    
                    // Also reset to main menu view when closing
                    const profileMainMenu = document.getElementById('profileMainMenu');
                    const settingsPanel = document.getElementById('settingsPanel');
                    if (profileMainMenu && settingsPanel) {
                        profileMainMenu.style.display = 'flex';
                        settingsPanel.classList.remove('active');
                    }
                }
            }
            
            // Also close dropdown menus when clicking outside
            const logoDropdown = document.getElementById('logoDropdown');
            if (logoDropdown && logoDropdown.classList.contains('show')) {
                if (!event.target.closest('.model-dropdown')) {
                    logoDropdown.classList.remove('show');
                }
            }
        });
    </script>

    <!-- Add response formatter and anticipated questions -->
    <script>
        // Modify sendToAPI to format shorter responses and add follow-up questions
        const originalSendToAPI = window.sendToAPI;
        window.sendToAPI = async function(prompt) {
            const response = await originalSendToAPI(prompt);
            
            // Format the response to be more concise
            const formattedResponse = formatResponse(response, prompt);
            return formattedResponse;
        };
        
        // Function to format responses and add anticipated follow-up questions
        function formatResponse(response, prompt) {
            // Extract user query from the prompt
            const userQuery = prompt.split('User: ').pop().split('\n')[0];
            
            // Check if user explicitly asked for a detailed response
            const wantsDetailedResponse = userQuery.toLowerCase().includes('explain in detail') || 
                userQuery.toLowerCase().includes('comprehensive') || 
                userQuery.toLowerCase().includes('thorough') || 
                userQuery.toLowerCase().includes('elaborate');
            
            // Format the response based on user preference
            let formattedResponse = response;
            
            // Make responses brief unless detailed response was requested
            if (!wantsDetailedResponse) {
                // Split by paragraphs and sentences
                const paragraphs = response.split('\n\n');
                
                // If multiple paragraphs, keep only essential ones
                if (paragraphs.length > 2) {
                    // Keep introduction paragraph
                    formattedResponse = paragraphs[0];
                    
                    // Find a paragraph with key information (containing important keywords)
                    const keywordParagraph = paragraphs.find(p => 
                        p.toLowerCase().includes('important') || 
                        p.toLowerCase().includes('key') || 
                        p.toLowerCase().includes('main') || 
                        p.toLowerCase().includes('summary') ||
                        p.toLowerCase().includes('conclusion'));
                    
                    // Add the key paragraph if found
                    if (keywordParagraph && keywordParagraph !== paragraphs[0]) {
                        formattedResponse += '\n\n' + keywordParagraph;
                    } else if (paragraphs[1] && paragraphs[1].length < 200) {
                        // Or add second paragraph if it's short
                        formattedResponse += '\n\n' + paragraphs[1];
                    }
                    
                    // If response is still too long, trim sentences
                    if (formattedResponse.length > 500) {
                        const sentences = formattedResponse.split(/(?<=[.!?])\s+/);
                        formattedResponse = sentences.slice(0, 5).join(' ');
                    }
                }
            }
            
            // Ensure proper formatting (bullet points, numbering, etc.)
            formattedResponse = ensureProperFormatting(formattedResponse);
            
            // Generate follow-up questions based on the user query
            const followUpQuestions = generateFollowUpQuestions(userQuery);
            
            // Add follow-up questions if we have them and response isn't too long
            if (followUpQuestions.length > 0 && formattedResponse.length < 800) {
                formattedResponse += '\n\nYou might also want to ask:\n';
                followUpQuestions.forEach(question => {
                    formattedResponse += ` "${question}"\n`;
                });
            }
            
            return formattedResponse;
        }
        
        // Ensure proper formatting for responses
        function ensureProperFormatting(text) {
            // Fix bullet points if they're malformed
            text = text.replace(/(?<=\n)[-*]\s+/g, ' ');
            
            // Fix numbered lists if they're malformed
            text = text.replace(/(?<=\n)\d+\.\s+/g, match => {
                // Keep the number and format consistently
                const number = match.match(/\d+/)[0];
                return `${number}. `;
            });
            
            // Ensure consistent paragraph spacing
            text = text.replace(/\n{3,}/g, '\n\n');
            
            // Ensure headings are properly formatted
            text = text.replace(/(?<=\n)([A-Z][A-Za-z\s]+):/g, '**$1:**');
            
            return text;
        }
        
        // Generate relevant follow-up questions based on user query
        function generateFollowUpQuestions(query) {
            const lowerQuery = query.toLowerCase();
            const questions = [];
            
            // Contract related
            if (lowerQuery.includes('contract') || lowerQuery.includes('agreement')) {
                questions.push('What are common pitfalls in this type of contract?');
                questions.push('What key clauses should be included?');
            }
            
            // Legal concept questions
            if (lowerQuery.includes('what is') || lowerQuery.includes('define') || lowerQuery.includes('explain')) {
                questions.push('How does this apply in practical situations?');
                questions.push('Are there recent legal developments in this area?');
            }
            
            // Document analysis
            if (lowerQuery.includes('review') || lowerQuery.includes('analyze') || lowerQuery.includes('document')) {
                questions.push('What are potential risks in this document?');
                questions.push('How could this document be improved?');
            }
            
            // Legal procedure
            if (lowerQuery.includes('court') || lowerQuery.includes('filing') || lowerQuery.includes('lawsuit')) {
                questions.push('What is the typical timeline for this process?');
                questions.push('What are the costs involved?');
            }
            
            // If no specific questions, add some general ones
            if (questions.length === 0) {
                questions.push('What are the practical implications of this?');
                questions.push('How does this vary by jurisdiction?');
            }
            
            // Return a max of 2 questions
            return questions.slice(0, 2);
        }
        
        // Override document processing to provide direct summaries
        const originalPreviewFile = window.previewFile;
        window.previewFile = async function(event) {
            // Call the original function first
            await originalPreviewFile(event);
            
            // Now provide a direct summary of the document
            const file = event.target.files[0];
            if (!file) return;
            
            // Get document text (either from OCR or direct extraction)
            let documentText = '';
            if (uploadedDocuments[file.name]) {
                documentText = uploadedDocuments[file.name].text;
            }
            
            // If we have text, provide a concise summary
            if (documentText && documentText.length > 0) {
                // Create a summary by extracting key info
                const summary = generateDocumentSummary(documentText, file.name);
                
                // Wait a short time for the UI to update before adding the summary
                    setTimeout(() => {
                    appendMessage("bot", summary);
            }, 500);
            }
        };
        
        // Generate a concise document summary from extracted text
        function generateDocumentSummary(text, fileName) {
            // Get document type from extension
            const fileExtension = fileName.split('.').pop().toUpperCase();
            
            // Get document length stats
            const wordCount = text.split(/\s+/).length;
            const paragraphCount = text.split(/\n\s*\n/).length;
            
            // Extract potential headers (lines with fewer than 50 chars that don't end with periods)
            const lines = text.split('\n');
            const potentialHeaders = lines
                .filter(line => line.trim().length > 0 && line.trim().length < 50 && !line.trim().endsWith('.'))
                .slice(0, 3); // Take just the first 3 potential headers
            
            // Create a short intro excerpt (first 100-150 chars)
            let excerpt = text.substring(0, 150).trim();
            if (excerpt.length === 150) excerpt += '...';
            
            // Format the summary
            let summary = ` **${fileName} Summary**\n\n`;
            
            // Document basics
            summary += `**Type:** ${fileExtension} document\n`;
            summary += `**Length:** ~${wordCount} words, ${paragraphCount} paragraphs\n\n`;
            
            // Include headers if found
            if (potentialHeaders.length > 0) {
                summary += `**Key sections:**\n`;
                potentialHeaders.forEach(header => {
                    summary += ` ${header.trim()}\n`;
                });
                summary += '\n';
            }
            
            // Add a brief excerpt
            summary += `**Preview:** "${excerpt}"\n\n`;
            
            // Add suggestions
            summary += `**How can I help?**\n`;
            summary += ` Ask me to analyze specific sections\n`;
            summary += ` Request a legal review of the document\n`;
            summary += ` Ask questions about terms or clauses\n`;
            
            return summary;
        }
    </script>

    <!-- Add layout adjustment script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Function to adjust chat box height based on viewport
            function adjustChatBoxHeight() {
                const chatBox = document.getElementById('chatBox');
                const windowHeight = window.innerHeight;
                
                if (chatBox) {
                    // Set chat box height to fill viewport
                    chatBox.style.height = `${windowHeight}px`;
                    
                    // Ensure content is scrolled to bottom
                    chatBox.scrollTop = chatBox.scrollHeight;
                }
            }
            
            // Initial adjustment
            adjustChatBoxHeight();
            
            // Adjust on window resize
            window.addEventListener('resize', adjustChatBoxHeight);
            
            // Adjust on orientation change for mobile
            window.addEventListener('orientationchange', function() {
                // Small delay to ensure orientation has completed
                setTimeout(adjustChatBoxHeight, 300);
            });
            
            // Make scroll to bottom button functional
            const scrollBottomBtn = document.getElementById('scrollBottomBtn');
            const chatBox = document.getElementById('chatBox');
            
            if (scrollBottomBtn && chatBox) {
                // Show button when scrolled up
                chatBox.addEventListener('scroll', function() {
                    const isScrolledUp = chatBox.scrollTop < (chatBox.scrollHeight - chatBox.clientHeight - 100);
                    
                    if (isScrolledUp) {
                        scrollBottomBtn.classList.add('visible');
                    } else {
                        scrollBottomBtn.classList.remove('visible');
                    }
                });
                
                // Scroll to bottom when button clicked
                scrollBottomBtn.addEventListener('click', function() {
                    chatBox.scrollTo({
                        top: chatBox.scrollHeight,
                        behavior: 'smooth'
                    });
                });
            }
        });
    </script>
</body>

</html>

